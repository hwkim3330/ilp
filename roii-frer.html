<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ROii Multi-Path Demo &mdash; Route Selection + GCL</title>
  <link rel="stylesheet" href="style.css" />
  <!-- Three.js r128 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <style>
    /* ═══════════════════════════════════════════════
       Light Theme Overrides (page-scoped)
       ═══════════════════════════════════════════════ */
    :root {
      --bg: #f8f9fa;
      --bg2: #f0f2f5;
      --card: #ffffff;
      --card-hi: #f8fafc;
      --border: rgba(59,130,246,0.2);
      --border-hi: rgba(59,130,246,0.4);
      --text: #1e293b;
      --text2: #475569;
      --text3: #64748b;
      --cyan: #0891b2;
      --blue: #3B82F6;
      --purple: #7c3aed;
      --orange: #d97706;
      --red: #dc2626;
      --green: #059669;
      --pink: #db2777;
      --flow-ctrl: #3B82F6;
      --flow-sensor: #059669;
      --flow-video: #db2777;
      --guard: #d97706;
      --be: #e2e8f0;
    }
    body {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 50%, #dee2e6 100%);
    }
    .bg-grid {
      background-image:
        radial-gradient(ellipse 80% 50% at 50% -20%, rgba(59,130,246,0.06), transparent),
        radial-gradient(ellipse 60% 40% at 80% 100%, rgba(6,182,212,0.04), transparent),
        linear-gradient(rgba(59,130,246,0.06) 1px, transparent 1px),
        linear-gradient(90deg, rgba(59,130,246,0.06) 1px, transparent 1px);
      background-size: 100% 100%, 100% 100%, 40px 40px, 40px 40px;
    }
    .card {
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      backdrop-filter: blur(20px);
      box-shadow: 0 2px 12px rgba(0,0,0,0.04);
    }
    .card:hover { border-color: rgba(59,130,246,0.3); }
    .card-title { color: var(--text2); }
    .card-title::before { background: var(--blue); }
    .metric-card {
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    }
    .metric-card::after { background: linear-gradient(90deg, var(--blue), transparent); }
    .metric-val { color: var(--blue); }
    .svg-container { background: rgba(248,250,252,0.8); }
    .tooltip {
      background: rgba(255,255,255,0.97);
      border: 1px solid rgba(59,130,246,0.25);
      color: var(--text);
      box-shadow: 0 8px 30px rgba(0,0,0,0.12);
    }
    .tooltip .tt-title { color: var(--blue); }
    .tooltip .tt-k { color: var(--text3); }
    textarea {
      background: rgba(248,250,252,0.9);
      color: var(--text);
      border-color: rgba(59,130,246,0.2);
    }
    textarea:focus { border-color: var(--blue); }
    pre {
      background: rgba(248,250,252,0.9);
      border-color: rgba(59,130,246,0.15);
      color: var(--text2);
    }
    .btn-primary {
      background: linear-gradient(135deg, #3B82F6 0%, #06B6D4 100%);
      color: #ffffff;
    }
    .btn-secondary {
      background: rgba(248,250,252,0.8);
      color: var(--text);
      border: 1px solid rgba(59,130,246,0.2);
    }
    .btn-secondary:hover {
      border-color: var(--blue);
      background: rgba(255,255,255,1);
    }
    .engine-badge.loading { background: rgba(217,119,6,0.1); color: var(--orange); border: 1px solid rgba(217,119,6,0.2); }
    .engine-badge.ready { background: rgba(5,150,105,0.1); color: var(--green); border: 1px solid rgba(5,150,105,0.2); }
    .auto-desc {
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    }
    .auto-desc h3 { color: var(--blue); }
    .auto-domain-legend .domain-tag {
      border: 1px solid rgba(59,130,246,0.15);
      background: rgba(255,255,255,0.8);
      color: var(--text2);
    }
    .pkt-table th { border-bottom: 1px solid rgba(59,130,246,0.15); color: var(--text3); }
    .pkt-table td { border-bottom: 1px solid rgba(59,130,246,0.08); }
    .pkt-table tr:hover td { background: rgba(59,130,246,0.04); }
    .topo-link { stroke: rgba(59,130,246,0.25); }
    .spinner { border-color: rgba(59,130,246,0.2); border-top-color: var(--blue); }

    /* ── KETI Logo Header ─────────────────────── */
    .keti-header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      margin-bottom: 8px;
    }
    .keti-header img {
      height: 40px;
      width: auto;
      object-fit: contain;
    }
    .keti-header .title-group {
      text-align: left;
    }
    .keti-header .title-group h1 {
      font-size: 2.2rem;
      font-weight: 800;
      letter-spacing: -0.02em;
      background: linear-gradient(135deg, #3B82F6 0%, #06B6D4 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    /* ── 3D Shuttle Card ──────────────────────── */
    .shuttle-3d-card {
      position: relative;
      border-radius: var(--radius);
      overflow: hidden;
      margin-bottom: 16px;
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      box-shadow: 0 2px 12px rgba(0,0,0,0.04);
      backdrop-filter: blur(20px);
    }
    #canvas3d {
      width: 100%;
      height: 500px;
      display: block;
      cursor: grab;
      background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
    }
    #canvas3d:active { cursor: grabbing; }
    .shuttle-3d-label {
      position: absolute;
      bottom: 12px;
      left: 16px;
      font-size: 0.72rem;
      color: var(--text3);
      background: rgba(255,255,255,0.85);
      padding: 4px 10px;
      border-radius: 8px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(59,130,246,0.1);
    }

    /* ── Per-Switch GCL Cards (white theme) ──── */
    .gcl-switch-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;
    }
    @media (max-width: 900px) { .gcl-switch-grid { grid-template-columns: 1fr; } }
    .gcl-switch-card {
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      border-radius: var(--radius); padding: 16px 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    }
    .gcl-switch-card .sw-header {
      display: flex; align-items: center; gap: 10px;
      margin-bottom: 12px; padding-bottom: 8px;
      border-bottom: 1px solid rgba(59,130,246,0.15);
    }
    .sw-dot { width: 12px; height: 12px; border-radius: 3px; flex-shrink: 0; }
    .sw-name { font-weight: 700; font-size: 0.95rem; color: var(--text); }
    .sw-chip {
      font-size: 0.7rem; padding: 2px 8px; border-radius: 6px;
      background: rgba(59,130,246,0.1); color: var(--blue); font-weight: 600;
    }
    .sw-stats { margin-left: auto; font-size: 0.75rem; color: var(--text3); }
    .gcl-entry-table { width: 100%; border-collapse: collapse; font-size: 0.78rem; }
    .gcl-entry-table th {
      text-align: left; padding: 4px 8px; color: var(--text3);
      border-bottom: 1px solid rgba(59,130,246,0.15); font-weight: 600;
    }
    .gcl-entry-table td { padding: 4px 8px; border-bottom: 1px solid rgba(0,0,0,0.06); }
    .gcl-entry-table tr:hover td { background: rgba(0,0,0,0.03); }
    .gate-mask {
      font-family: 'Courier New', monospace; font-size: 0.75rem;
      letter-spacing: 1px; font-weight: 700;
    }
    .gate-open  { color: var(--green); }
    .gate-guard { color: var(--orange); }
    .gate-closed { color: var(--text3); opacity: 0.5; }
    .entry-bar { height: 6px; border-radius: 3px; margin-top: 2px; }
    .link-label-dir { font-size: 0.8rem; font-weight: 600; color: var(--text2); margin-bottom: 4px; }

    /* ── Route table (white theme) ────────────── */
    .route-tbl { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
    .route-tbl th { text-align: left; padding: 6px 10px; color: var(--text3); font-weight: 600; border-bottom: 1px solid rgba(59,130,246,0.15); }
    .route-tbl td { padding: 6px 10px; border-bottom: 1px solid rgba(0,0,0,0.06); }
    .route-tbl tr:hover td { background: rgba(0,0,0,0.03); }
    .route-dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 6px; vertical-align: middle; }
    .route-path { font-weight: 600; color: var(--blue); }
    .route-path.alt { color: var(--green); }
  </style>
</head>
<body>
  <div class="bg-grid"></div>
  <div class="wrap">
    <!-- KETI Logo Header -->
    <div class="header">
      <div class="keti-header">
        <img src="keti.png" alt="KETI" onerror="this.style.display='none'">
        <div class="title-group">
          <h1>ROii Multi-Path Demo</h1>
        </div>
        <span class="engine-badge loading" id="engineBadge"><span class="spinner"></span>Loading GLPK/WASM...</span>
      </div>
      <div class="sub">Route Selection + IEEE 802.1Qbv GCL Scheduling &mdash; Triangle Switch Topology</div>
    </div>

    <!-- 3D Shuttle Visualization -->
    <div class="shuttle-3d-card">
      <div class="card-title" style="padding:16px 20px 0;">3D Shuttle Network Topology</div>
      <div id="canvas3d"></div>
      <div class="shuttle-3d-label">Drag to rotate &middot; Scroll to zoom &middot; Right-click to pan</div>
    </div>

    <!-- Solve Controls -->
    <div class="card" style="padding:12px 20px;">
      <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;">
        <button class="btn btn-primary" id="resolveBtn" disabled>Re-Solve</button>
        <button class="btn btn-secondary" id="resetBtn">Reset</button>
        <div id="status" style="font-size:0.82rem;"></div>
        <a href="gcl.html" class="btn btn-secondary" style="margin-left:auto;font-size:0.78rem;">GCL Detail View</a>
      </div>
    </div>

    <!-- Metrics -->
    <div class="metrics" id="metricsArea"></div>

    <!-- Scenario Description -->
    <div class="auto-desc" id="scenarioDesc"></div>
    <div class="auto-domain-legend" id="domainLegend"></div>

    <!-- Shuttle Architecture Topology -->
    <div class="card">
      <div class="card-title">Network Topology &mdash; Triangle + Hub</div>
      <div class="legend" id="topoLegend"></div>
      <div class="svg-container" id="topoContainer" style="height:520px;"></div>
    </div>

    <!-- Per-Switch GCL Detail -->
    <div class="card">
      <div class="card-title">Per-Switch GCL &mdash; Gate Control by Egress Port</div>
    </div>
    <div id="switchGclArea" class="gcl-switch-grid"></div>

    <!-- GCL Gantt -->
    <div class="card">
      <div class="card-title">Per-Link GCL Timeline (Gantt)</div>
      <div class="legend" id="gclLegend"></div>
      <div class="svg-container" id="gclContainer"></div>
    </div>

    <!-- Delay + Utilization -->
    <div class="two-col">
      <div class="card">
        <div class="card-title">Packet E2E Delay</div>
        <div class="svg-container" id="delayContainer" style="height:380px;"></div>
      </div>
      <div class="card">
        <div class="card-title">Link Utilization</div>
        <div class="svg-container" id="utilContainer" style="min-height:200px;"></div>
      </div>
    </div>

    <!-- Route Selection Summary -->
    <div class="card">
      <div class="card-title">Route Selection Summary</div>
      <div id="routeSelection" style="padding:10px 16px;"></div>
    </div>

    <!-- Table -->
    <div class="card">
      <div class="card-title">Packet Schedule Table</div>
      <div style="overflow-x:auto;">
        <table class="pkt-table">
          <thead><tr>
            <th>Packet</th><th>Flow</th><th>Route</th><th>Release</th><th>End</th><th>E2E</th><th>Deadline</th><th>Slack</th><th>Status</th>
          </tr></thead>
          <tbody id="pktTableBody"></tbody>
        </table>
      </div>
    </div>

    <!-- Collapsible JSON Editor -->
    <div class="card">
      <div class="card-title collapsible" id="jsonEditorToggle">
        <span class="arrow">&#9654;</span> Customize Model (JSON)
      </div>
      <div class="collapse-body">
        <textarea id="input" style="min-height:300px;"></textarea>
      </div>
    </div>

    <!-- Raw GCL -->
    <div class="card">
      <div class="card-title collapsible" id="gclJsonToggle">
        <span class="arrow">&#9654;</span> Raw GCL Output (JSON)
      </div>
      <div class="collapse-body">
        <pre id="jsonOut">-</pre>
      </div>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script src="vendor/d3.min.js"></script>
  <script type="module">
  import {
    initTooltip, solveGreedy, solveILP, renderMetrics, renderTopology,
    renderGCL, renderDelayChart, renderUtilization, renderTable
  } from './js/ilp-core.js';
  import {
    FRER_MODEL, getFrerPositions, FRER_NODE_COLORS, FRER_SCENARIO,
    FRER_SWITCHES, FRER_3D_POSITIONS, FRER_3D_TILTS
  } from './js/roii-frer-data.js?v=2';

  /* ── 3D Shuttle + Network Topology ────────────── */
  try { (function init3D() {
    const container = document.getElementById('canvas3d');
    if (!container || typeof THREE === 'undefined') return;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    scene.fog = new THREE.Fog(0xf0f0f0, 80, 250);

    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
    camera.position.set(50, 35, 70);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    function updateSize() {
      const w = container.clientWidth, h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }
    updateSize();
    container.appendChild(renderer.domElement);
    window.addEventListener('resize', updateSize);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.2;
    controls.minDistance = 20;
    controls.maxDistance = 120;
    controls.target.set(0, 0, 0);

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 1.2));
    const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
    mainLight.position.set(30, 50, 30);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.set(2048, 2048);
    mainLight.shadow.camera.near = 0.5;
    mainLight.shadow.camera.far = 200;
    mainLight.shadow.camera.left = -60;
    mainLight.shadow.camera.right = 60;
    mainLight.shadow.camera.top = 60;
    mainLight.shadow.camera.bottom = -60;
    scene.add(mainLight);
    const fillLight = new THREE.DirectionalLight(0xffffff, 1.0);
    fillLight.position.set(0, 50, 0);
    scene.add(fillLight);
    const pl1 = new THREE.PointLight(0x3B82F6, 2, 100);
    pl1.position.set(20, 15, 20);
    scene.add(pl1);
    const pl2 = new THREE.PointLight(0x06B6D4, 1.5, 80);
    pl2.position.set(-20, 15, -20);
    scene.add(pl2);

    // Grid + Ground
    const grid = new THREE.GridHelper(100, 50, 0x3B82F6, 0xCCCCCC);
    grid.material.opacity = 0.4;
    grid.material.transparent = true;
    grid.position.y = -0.5;
    scene.add(grid);
    const plane = new THREE.Mesh(
      new THREE.PlaneGeometry(100, 100),
      new THREE.ShadowMaterial({ opacity: 0.3 })
    );
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = -0.5;
    plane.receiveShadow = true;
    scene.add(plane);

    // Device Templates — all switches LAN9692, HUB_F orange
    const TMPL = {
      lidar:     { w: 1, h: 1, d: 1, color: 0x10B981 },
      radar:     { w: 1, h: 1, d: 1, color: 0x952aff },
      hub:       { w: 2, h: 1, d: 2, color: 0xf97316 },
      switch_f:  { w: 4, h: 2, d: 4, color: 0x3B82F6 },
      switch_r:  { w: 4, h: 2, d: 4, color: 0x06B6D4 },
      ecu:       { w: 4, h: 2, d: 4, color: 0x8B5CF6 }
    };

    function getType(id) {
      if (id.startsWith('LIDAR')) return 'lidar';
      if (id.startsWith('RADAR')) return 'radar';
      if (id === 'HUB_F') return 'hub';
      if (id === 'SW_REAR') return 'switch_r';
      if (id.startsWith('SW')) return 'switch_f';
      return 'ecu';
    }

    function createDevice(nodeId, position, label, tilt) {
      const type = getType(nodeId);
      const t = TMPL[type];
      const group = new THREE.Group();
      const { w, h, d } = t;

      let geometry;
      if (type === 'lidar') {
        geometry = label.includes('Center')
          ? new THREE.BoxGeometry(w, h, d)
          : new THREE.CylinderGeometry(w * 0.6, w * 0.6, h * 0.8, 16);
      } else {
        geometry = new THREE.BoxGeometry(w, h, d);
      }

      const mat = new THREE.MeshPhongMaterial({
        color: t.color, emissive: t.color, emissiveIntensity: 0.5,
        specular: 0x888888, shininess: 30
      });
      const mesh = new THREE.Mesh(geometry, mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      group.add(mesh);

      group.add(new THREE.LineSegments(
        new THREE.EdgesGeometry(geometry),
        new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 5 })
      ));

      // Label sprite
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 512; canvas.height = 128;
      ctx.fillStyle = 'rgba(26, 26, 46, 0.9)';
      ctx.fillRect(0, 0, 512, 128);
      ctx.fillStyle = '#FFFFFF';
      ctx.font = 'bold 48px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(label, 256, 75);
      const sprite = new THREE.Sprite(
        new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) })
      );
      const ls = Math.max(w, d) * 1.2;
      sprite.scale.set(ls, ls * 0.25, 1);
      sprite.position.y = h + 1;
      group.add(sprite);

      group.position.copy(position);
      if (tilt) {
        if (tilt.x !== undefined) group.rotation.x = tilt.x;
        if (tilt.y !== undefined) group.rotation.y = tilt.y;
        if (tilt.z !== undefined) group.rotation.z = tilt.z;
      }
      scene.add(group);
      return { mesh, group };
    }

    // Place devices using FRER positions (includes HUB_F)
    const nodePos3D = {};
    const nodeMeshes = {};
    const LABELS = {
      LIDAR_FL:'LiDAR-Front-Left', LIDAR_FR:'LiDAR-Front-Right',
      LIDAR_FC:'LiDAR-Front-Center', LIDAR_RC:'LiDAR-Rear-Center',
      RADAR_FC:'Radar-Front-Center', RADAR_FL:'Radar-Front-L',
      RADAR_FR:'Radar-Front-R', RADAR_RL:'Radar-Rear-L', RADAR_RR:'Radar-Rear-R',
      HUB_F:'Front-Hub',
      SW_FL:'Front-L ZC', SW_FR:'Front-R ZC', SW_REAR:'Rear-GW',
      ACU_IT:'ACU-IT'
    };

    for (const [id, pos] of Object.entries(FRER_3D_POSITIONS)) {
      const v = new THREE.Vector3(pos.x, pos.y, pos.z);
      const tilt = FRER_3D_TILTS[id] || null;
      const dev = createDevice(id, v, LABELS[id] || id, tilt);
      nodePos3D[id] = v;
      nodeMeshes[id] = dev.mesh;
    }

    // Connection Lines (FRER_MODEL.links)
    const drawnLinks = new Set();
    for (const link of FRER_MODEL.links) {
      const key = [link.from, link.to].sort().join('|');
      if (drawnLinks.has(key)) continue;
      drawnLinks.add(key);
      const p1 = nodePos3D[link.from], p2 = nodePos3D[link.to];
      if (!p1 || !p2) continue;

      const lineGeo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
      const lineMat = new THREE.LineBasicMaterial({
        color: 0x3B82F6, transparent: true, opacity: 0.3
      });
      scene.add(new THREE.Line(lineGeo, lineMat));

      const curve = new THREE.CatmullRomCurve3([p1.clone(), p2.clone()]);
      const tubeGeo = new THREE.TubeGeometry(curve, 20, 0.08, 8, false);
      const tubeMat = new THREE.MeshStandardMaterial({
        color: 0x3B82F6, emissive: 0x3B82F6, emissiveIntensity: 0.9,
        transparent: true, opacity: 0.95
      });
      scene.add(new THREE.Mesh(tubeGeo, tubeMat));

      const glowGeo = new THREE.TubeGeometry(curve, 20, 0.2, 8, false);
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0x3B82F6, transparent: true, opacity: 0.35
      });
      scene.add(new THREE.Mesh(glowGeo, glowMat));
    }

    // Animated Data Particles (FRER paths: sensor→HUB_F→SW→SW_REAR→ACU_IT)
    const particles = [];
    const flowPaths = [
      { path: ['LIDAR_FL','HUB_F','SW_FL','SW_REAR','ACU_IT'], color: 0x10B981 },
      { path: ['LIDAR_FC','HUB_F','SW_FL','SW_REAR','ACU_IT'], color: 0x10B981 },
      { path: ['LIDAR_FR','HUB_F','SW_FR','SW_REAR','ACU_IT'], color: 0x10B981 },
      { path: ['LIDAR_RC','SW_REAR','ACU_IT'],                  color: 0x10B981 },
      { path: ['RADAR_FC','HUB_F','SW_FL','SW_REAR','ACU_IT'],  color: 0x952aff },
      { path: ['RADAR_FL','HUB_F','SW_FL','SW_REAR','ACU_IT'],  color: 0x952aff },
      { path: ['RADAR_FR','HUB_F','SW_FR','SW_REAR','ACU_IT'],  color: 0x952aff },
      { path: ['RADAR_RL','SW_REAR','ACU_IT'],                   color: 0x952aff },
      { path: ['RADAR_RR','SW_REAR','ACU_IT'],                   color: 0x952aff }
    ];

    flowPaths.forEach((fp, fi) => {
      const pts = fp.path.map(id => nodePos3D[id]).filter(Boolean);
      if (pts.length < 2) return;
      const segs = []; let totalLen = 0;
      for (let i = 0; i < pts.length - 1; i++) { const d = pts[i].distanceTo(pts[i+1]); segs.push(d); totalLen += d; }
      const pMesh = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8),
        new THREE.MeshBasicMaterial({ color: fp.color, transparent: true, opacity: 0.9 }));
      const pgMesh = new THREE.Mesh(new THREE.SphereGeometry(0.9, 8, 8),
        new THREE.MeshBasicMaterial({ color: fp.color, transparent: true, opacity: 0.25 }));
      scene.add(pMesh); scene.add(pgMesh);
      particles.push({ mesh: pMesh, glow: pgMesh, points: pts, segs, totalLen,
        t: fi / flowPaths.length, speed: 0.12 + Math.random() * 0.06 });
    });

    // Load GLB Model
    const loader = new THREE.GLTFLoader();
    loader.load('./roii.glb',
      (gltf) => {
        const model = gltf.scene;
        const box = new THREE.Box3().setFromObject(model);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());

        const targetSize = 40;
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = targetSize / maxDim;
        model.scale.set(scale, scale, scale);

        const scaledHeight = size.y * scale;
        model.position.x = -center.x;
        model.position.y = -center.y + (scaledHeight * 0.5) + 0.5;
        model.position.z = -center.z;

        model.traverse((child) => {
          if (!child.isMesh) return;
          const mats = Array.isArray(child.material) ? child.material : [child.material];
          mats.forEach(mat => {
            mat.transparent = true;
            mat.opacity = 0.3;
            mat.side = THREE.DoubleSide;
            mat.depthWrite = true;
            if (mat.color) mat.color.multiplyScalar(1.5);
            mat.emissive = mat.color ? mat.color.clone().multiplyScalar(0.3) : new THREE.Color(0xffffff);
            mat.emissiveIntensity = 0.4;
          });
          child.castShadow = true;
          child.receiveShadow = true;
        });
        scene.add(model);
      },
      undefined,
      (err) => { console.warn('GLB load failed:', err); }
    );

    // Animation Loop
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      controls.update();

      const pulse = Math.sin(clock.elapsedTime * 2.5) * 0.06;
      for (const m of Object.values(nodeMeshes)) m.material.emissiveIntensity = 0.2 + pulse;

      particles.forEach(p => {
        p.t += dt * p.speed;
        if (p.t > 1) p.t -= 1;
        let dist = p.t * p.totalLen, si = 0;
        while (si < p.segs.length - 1 && dist > p.segs[si]) { dist -= p.segs[si]; si++; }
        const pos = new THREE.Vector3().lerpVectors(p.points[si], p.points[si + 1], dist / p.segs[si]);
        p.mesh.position.copy(pos);
        p.glow.position.copy(pos);
        const fade = Math.min(p.t * 4, (1 - p.t) * 4, 1);
        p.mesh.material.opacity = 0.9 * fade;
        p.glow.material.opacity = 0.25 * fade;
      });

      renderer.render(scene, camera);
    }
    animate();
  })(); } catch(e) { console.warn('3D init error:', e); }

  /* ── Flow Colors ── */
  function frerFlowColor(fid) {
    return (fid || '').toLowerCase().includes('lidar') ? '#10B981' : '#952aff';
  }
  const fcopts = { flowColorFn: frerFlowColor, beColor: '#e2e8f0', beBorder: 'rgba(59,130,246,0.15)' };

  /* ── State ── */
  let glpk = null;
  let currentModel = JSON.parse(JSON.stringify(FRER_MODEL));
  let currentResult = null;

  /* ── Init ── */
  initTooltip();

  document.getElementById("scenarioDesc").innerHTML = `
    <h3>${FRER_SCENARIO.title}</h3>
    <p>${FRER_SCENARIO.description}</p>
    <ul class="auto-flow-list">
      ${FRER_SCENARIO.flows.map(f => `<li><span class="dot" style="background:${f.color}"></span><strong>${f.name}</strong> &mdash; ${f.desc}</li>`).join("")}
    </ul>
  `;
  document.getElementById("domainLegend").innerHTML = FRER_SCENARIO.domains.map(d =>
    `<div class="domain-tag"><span class="dsq" style="background:${d.color}"></span>${d.name}</div>`
  ).join("");

  // Collapsibles
  ["jsonEditorToggle", "gclJsonToggle"].forEach(id => {
    document.getElementById(id).addEventListener("click", function() {
      this.classList.toggle("open");
      this.parentElement.querySelector(".collapse-body").classList.toggle("show");
    });
  });

  const inputEl = document.getElementById("input");
  const statusEl = document.getElementById("status");
  const resolveBtn = document.getElementById("resolveBtn");
  const resetBtn = document.getElementById("resetBtn");
  inputEl.value = JSON.stringify(FRER_MODEL, null, 2);

  resetBtn.addEventListener("click", () => {
    inputEl.value = JSON.stringify(FRER_MODEL, null, 2);
    statusEl.textContent = "Reset to default"; statusEl.className = "status-ok";
  });
  resolveBtn.addEventListener("click", runILPSolve);

  /* ── Greedy Solver ── */
  function runGreedy() {
    try {
      const model = JSON.parse(inputEl.value);
      const t0 = performance.now();
      const result = solveGreedy(model);
      const wallMs = Math.round(performance.now() - t0);
      currentModel = model; currentResult = result;
      renderAll();
      statusEl.innerHTML = `<strong style="color:var(--green)">Greedy solved in ${wallMs}ms</strong> &mdash; ${result.packetRows.length} packets scheduled`;
      statusEl.className = "status-ok";
    } catch (e) { statusEl.textContent = "Error: " + e.message; statusEl.className = "status-err"; }
  }

  /* ── ILP Solver ── */
  async function runILPSolve() {
    if (!glpk) { runGreedy(); return; }
    try {
      const model = JSON.parse(inputEl.value);
      resolveBtn.disabled = true;
      const t0 = performance.now();
      statusEl.innerHTML = '<span class="spinner"></span> Solving ILP (tmlim=15s)...';
      statusEl.className = "";
      await new Promise(r => setTimeout(r, 50));

      const result = await solveILP(model, glpk, { tmlim: 15 });
      const wallMs = Math.round(performance.now() - t0);
      currentModel = model; currentResult = result;
      renderAll();
      const label = result.stats.status === 5 ? 'optimal' : 'feasible';
      statusEl.innerHTML = `<strong style="color:var(--green)">ILP ${label} in ${wallMs}ms</strong> &mdash; ${result.stats.variables} vars, ${result.stats.binaries} bins, ${result.stats.constraints} constraints`;
      statusEl.className = "status-ok";
    } catch (e) {
      statusEl.textContent = "ILP failed: " + e.message + " — using greedy instead";
      statusEl.className = "status-err";
      runGreedy();
    }
    resolveBtn.disabled = false;
  }

  /* ── Render All ── */
  function renderAll() {
    if (!currentResult) return;
    const container = document.getElementById("topoContainer");
    const W = container.clientWidth;
    renderMetrics(currentModel, currentResult);
    renderTopology(currentModel, currentResult, {
      nodePositions: getFrerPositions(W, 520), nodeColors: FRER_NODE_COLORS, height: 520
    });
    renderGCL(currentModel, currentResult, fcopts);
    renderDelayChart(currentModel, currentResult, fcopts);
    renderUtilization(currentModel, currentResult, fcopts);
    renderTable(currentResult, fcopts);
    renderSwitchGCL(currentModel, currentResult);
    renderRouteSelection();
    document.getElementById("jsonOut").textContent = JSON.stringify(currentResult.gcl, null, 2);
  }

  /* ═══════════════════════════════════════════════
     Per-Switch GCL Detail Cards
     ═══════════════════════════════════════════════ */
  function renderSwitchGCL(model, result) {
    const area = document.getElementById("switchGclArea");
    area.innerHTML = "";

    FRER_SWITCHES.forEach(sw => {
      const egressLinks = model.links.filter(l => l.from === sw.id);
      const activeEgress = egressLinks.filter(l => {
        const entries = result.gcl.links[l.id]?.entries || [];
        return entries.some(e => !e.note.includes("best-effort"));
      });
      if (activeEgress.length === 0) return;

      let totalFlow = 0, totalGuard = 0, tsnCount = 0;
      activeEgress.forEach(l => {
        const entries = result.gcl.links[l.id]?.entries || [];
        entries.forEach(e => {
          if (e.note.includes("guard")) totalGuard += e.duration_us;
          else if (!e.note.includes("best-effort")) { totalFlow += e.duration_us; tsnCount++; }
        });
      });
      const utilPct = ((totalFlow + totalGuard) / model.cycle_time_us / activeEgress.length * 100).toFixed(1);

      const card = document.createElement("div");
      card.className = "gcl-switch-card";

      card.innerHTML = `
        <div class="sw-header">
          <div class="sw-dot" style="background:${sw.color};"></div>
          <span class="sw-name">${sw.label}</span>
          <span class="sw-chip">${sw.chip}</span>
          <span class="sw-stats">${activeEgress.length} port${activeEgress.length > 1 ? 's' : ''} &middot; ${tsnCount} entries &middot; ${utilPct}% util</span>
        </div>
      `;

      activeEgress.forEach(link => {
        const entries = result.gcl.links[link.id]?.entries || [];
        const linkDiv = document.createElement("div");
        linkDiv.style.marginBottom = "14px";

        let html = `<div class="link-label-dir">${link.from} &rarr; ${link.to}</div>`;
        html += `<table class="gcl-entry-table">
          <thead><tr><th>#</th><th>Gate Mask</th><th>TC</th><th>Start (µs)</th><th>End (µs)</th><th>Duration</th><th>Type</th></tr></thead><tbody>`;

        entries.forEach(e => {
          const isBE = e.note.includes("best-effort");
          const isGuard = e.note.includes("guard");
          const cls = isGuard ? "gate-guard" : isBE ? "gate-closed" : "gate-open";
          let tcLabel = "-";
          if (!isBE && !isGuard) {
            const oneIdx = e.gate_mask.indexOf('1');
            if (oneIdx >= 0) tcLabel = "TC" + (7 - oneIdx);
          } else if (isGuard) { tcLabel = "guard"; }
          const typeLabel = isGuard ? "Guard Band" : isBE ? "BE Window" : e.note.split("#")[0].replace("f_","");
          const barColor = isGuard ? "#f59e0b" : isBE ? "rgba(0,0,0,0.08)" : frerFlowColor(e.note);
          const barW = Math.max((e.duration_us / model.cycle_time_us * 100), 1.5).toFixed(1);

          html += `<tr>
            <td>${e.index}</td>
            <td class="gate-mask ${cls}">${e.gate_mask}</td>
            <td style="font-weight:600;${isGuard ? 'color:#f59e0b' : isBE ? 'opacity:0.4' : 'color:' + barColor}">${tcLabel}</td>
            <td>${e.start_us}</td><td>${e.end_us}</td>
            <td>${e.duration_us} µs</td>
            <td><span style="color:${isBE ? 'var(--text3)' : barColor};font-weight:600;">${typeLabel}</span>
              <div class="entry-bar" style="background:${barColor};width:${barW}%;opacity:${isBE ? 0.15 : 0.7};"></div>
            </td></tr>`;
        });

        html += `</tbody></table>`;
        linkDiv.innerHTML = html;
        card.appendChild(linkDiv);
      });

      area.appendChild(card);
    });
  }

  /* ═══════════════════════════════════════════════
     Route Selection Summary
     ═══════════════════════════════════════════════ */
  function renderRouteSelection() {
    const el = document.getElementById("routeSelection");
    if (!el || !currentResult) return;

    const flowMap = {};
    for (const r of currentResult.packetRows) {
      if (!flowMap[r.flow_id]) flowMap[r.flow_id] = [];
      flowMap[r.flow_id].push(r);
    }

    let html = `<table class="route-tbl">
      <thead><tr><th>Flow</th><th>TC</th><th>Selected Path</th><th>Hops</th><th>Avg E2E</th><th>Status</th></tr></thead><tbody>`;

    for (const [fid, pkts] of Object.entries(flowMap)) {
      const color = frerFlowColor(fid);
      const tc = fid.includes('lidar') ? 'TC7' : 'TC6';
      const routes = [...new Set(pkts.map(p => p.selected_route))];
      const avgE2e = (pkts.reduce((s, p) => s + p.e2e_delay_us, 0) / pkts.length).toFixed(1);
      const allOk = pkts.every(p => p.status === 'OK' || p.status === 'BE');

      const samplePkt = pkts[0];
      const hopLinks = samplePkt.hops.map(h => h.link_id);
      let pathDesc = "direct";
      if (hopLinks.some(l => l.includes("swfl") || l.includes("hub_swfl"))) {
        if (hopLinks.some(l => l.includes("swfr"))) pathDesc = "SW_FL + SW_FR";
        else pathDesc = "via SW_FL";
      } else if (hopLinks.some(l => l.includes("swfr") || l.includes("hub_swfr"))) {
        pathDesc = "via SW_FR";
      }

      const pathClass = routes[0] === 0 ? "route-path" : "route-path alt";

      html += `<tr>
        <td><span class="route-dot" style="background:${color}"></span>${fid}</td>
        <td style="font-weight:600;color:${color}">${tc}</td>
        <td><span class="${pathClass}">${pathDesc}</span>${routes.length > 1 ? ' (mixed)' : ''}</td>
        <td>${samplePkt.hops.length} hops</td>
        <td>${avgE2e} µs</td>
        <td style="color:${allOk ? 'var(--green)' : 'var(--red)'}; font-weight:700;">${allOk ? 'OK' : 'MISS'}</td>
      </tr>`;
    }

    html += `</tbody></table>`;
    el.innerHTML = html;
  }

  /* ── Responsive ── */
  let resizeTimer;
  window.addEventListener("resize", () => { clearTimeout(resizeTimer); resizeTimer = setTimeout(renderAll, 300); });

  /* ── Auto-Solve with Greedy ── */
  const badge = document.getElementById("engineBadge");
  badge.className = "engine-badge ready";
  badge.innerHTML = "&#9679; Greedy Scheduler Ready";
  resolveBtn.disabled = false;
  statusEl.textContent = "Auto-solving multi-path scenario...";
  runGreedy();

  /* ── Load GLPK/WASM in background ── */
  (async () => {
    try {
      const GLPK = (await import('./vendor/glpk.js')).default;
      glpk = await GLPK();
      const ver = typeof glpk.version === 'function' ? glpk.version() : (glpk.version || '?');
      badge.innerHTML = `&#9679; GLPK ${ver} + Greedy Ready`;
      resolveBtn.textContent = "Re-Solve (ILP)";
    } catch (e) {
      console.warn('GLPK load failed (greedy still works):', e);
      resolveBtn.textContent = "Re-Solve (Greedy)";
    }
  })();
  </script>
</body>
</html>
