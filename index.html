<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TSN/GCL ILP Solver</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <style>
    @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');
    :root {
      --bg: #060d1f;
      --bg2: #0c1632;
      --card: #111d3d;
      --card-hi: #162450;
      --border: #1e3060;
      --border-hi: #2a4080;
      --text: #e4ecff;
      --text2: #8fa4d0;
      --text3: #5e7099;
      --cyan: #00f5d4;
      --blue: #4895ef;
      --purple: #7b61ff;
      --orange: #f9a825;
      --red: #ff5252;
      --green: #69f0ae;
      --pink: #f06292;
      --flow-ctrl: #4895ef;
      --flow-sensor: #00f5d4;
      --flow-video: #f06292;
      --guard: #f9a825;
      --be: #1a3050;
      --radius: 14px;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Pretendard', -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      overflow-x: hidden;
    }
    .bg-grid {
      position: fixed; inset: 0; z-index: 0; pointer-events: none;
      background-image:
        radial-gradient(ellipse 80% 50% at 50% -20%, rgba(72,149,239,.08), transparent),
        radial-gradient(ellipse 60% 40% at 80% 100%, rgba(0,245,212,.05), transparent),
        linear-gradient(rgba(30,48,96,.15) 1px, transparent 1px),
        linear-gradient(90deg, rgba(30,48,96,.15) 1px, transparent 1px);
      background-size: 100% 100%, 100% 100%, 40px 40px, 40px 40px;
    }
    .wrap { position: relative; z-index: 1; max-width: 1400px; margin: 0 auto; padding: 24px 20px 60px; }

    /* Header */
    .header { text-align: center; margin-bottom: 32px; }
    .header h1 {
      font-size: 2.2rem; font-weight: 800; letter-spacing: -0.02em;
      background: linear-gradient(135deg, var(--cyan), var(--blue), var(--purple));
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .header .sub { color: var(--text2); font-size: 0.95rem; margin-top: 6px; }
    .badge {
      display: inline-block; margin-top: 10px; padding: 4px 14px;
      border: 1px solid var(--border); border-radius: 20px;
      font-size: 0.75rem; color: var(--cyan); background: rgba(0,245,212,.06);
    }

    /* Cards */
    .card {
      background: linear-gradient(160deg, var(--card) 0%, var(--bg2) 100%);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 16px;
      backdrop-filter: blur(8px);
      transition: border-color .2s;
    }
    .card:hover { border-color: var(--border-hi); }
    .card-title {
      font-size: 0.8rem; font-weight: 600; color: var(--text2);
      text-transform: uppercase; letter-spacing: 0.08em;
      margin-bottom: 14px;
      display: flex; align-items: center; gap: 8px;
    }
    .card-title::before {
      content: ''; display: block; width: 3px; height: 14px;
      border-radius: 2px; background: var(--cyan);
    }

    /* Metrics */
    .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin-bottom: 16px; }
    .metric-card {
      background: linear-gradient(160deg, var(--card) 0%, rgba(6,13,31,.8) 100%);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px 18px;
      position: relative;
      overflow: hidden;
    }
    .metric-card::after {
      content: ''; position: absolute; top: 0; left: 0; right: 0; height: 2px;
      background: linear-gradient(90deg, var(--cyan), transparent);
    }
    .metric-card.warn::after { background: linear-gradient(90deg, var(--orange), transparent); }
    .metric-card.ok::after { background: linear-gradient(90deg, var(--green), transparent); }
    .metric-val { font-size: 1.6rem; font-weight: 800; color: var(--cyan); font-variant-numeric: tabular-nums; }
    .metric-card.warn .metric-val { color: var(--orange); }
    .metric-card.ok .metric-val { color: var(--green); }
    .metric-label { font-size: 0.72rem; color: var(--text3); margin-top: 4px; text-transform: uppercase; letter-spacing: 0.06em; }
    .metric-sub { font-size: 0.7rem; color: var(--text2); margin-top: 2px; }

    /* Two-column layout */
    .two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    @media (max-width: 900px) { .two-col { grid-template-columns: 1fr; } }

    /* SVG */
    svg { width: 100%; display: block; }
    .svg-container { position: relative; overflow: hidden; border-radius: 10px; background: rgba(6,13,31,.6); }

    /* Topology */
    .topo-node { cursor: grab; }
    .topo-node:active { cursor: grabbing; }
    .topo-node circle { transition: r .2s; }
    .topo-node:hover circle { r: 28; }
    .topo-link { stroke: var(--border); stroke-width: 1.5; }
    .topo-link-active { stroke-width: 2.5; }
    .topo-arrow { fill: var(--text3); }
    .topo-label { font-size: 11px; fill: var(--text); font-weight: 600; text-anchor: middle; dominant-baseline: central; pointer-events: none; }
    .topo-type { font-size: 8px; fill: var(--text3); text-anchor: middle; pointer-events: none; }
    .flow-path { fill: none; stroke-width: 3; stroke-linecap: round; opacity: 0.7; }
    .flow-particle { opacity: 0.9; }

    /* GCL Gantt */
    .gcl-bar { cursor: pointer; rx: 3; ry: 3; }
    .gcl-bar:hover { filter: brightness(1.3); }
    .gcl-label { font-size: 9px; fill: var(--text); pointer-events: none; }
    .gcl-row-label { font-size: 11px; fill: var(--text2); font-weight: 500; }
    .gcl-axis text { fill: var(--text3); font-size: 10px; }
    .gcl-axis line, .gcl-axis path { stroke: var(--border); }
    .gcl-grid line { stroke: var(--border); stroke-dasharray: 2,3; opacity: 0.4; }

    /* Delay chart */
    .delay-bar { rx: 4; ry: 4; cursor: pointer; }
    .delay-bar:hover { filter: brightness(1.3); }
    .delay-axis text { fill: var(--text3); font-size: 10px; }
    .delay-axis line, .delay-axis path { stroke: var(--border); }
    .deadline-line { stroke: var(--red); stroke-width: 1.5; stroke-dasharray: 5,4; }

    /* Utilization */
    .util-arc { cursor: pointer; }
    .util-arc:hover { filter: brightness(1.2); }
    .util-label { font-size: 12px; fill: var(--text); font-weight: 700; text-anchor: middle; dominant-baseline: central; }
    .util-name { font-size: 9px; fill: var(--text3); text-anchor: middle; }

    /* Tooltip */
    .tooltip {
      position: fixed; z-index: 100; pointer-events: none;
      background: rgba(10,18,42,.95); border: 1px solid var(--border-hi);
      border-radius: 10px; padding: 10px 14px;
      font-size: 0.78rem; color: var(--text);
      box-shadow: 0 8px 30px rgba(0,0,0,.5);
      backdrop-filter: blur(10px);
      opacity: 0; transition: opacity .15s;
      max-width: 280px;
    }
    .tooltip.show { opacity: 1; }
    .tooltip .tt-title { font-weight: 700; margin-bottom: 4px; color: var(--cyan); }
    .tooltip .tt-row { display: flex; justify-content: space-between; gap: 16px; }
    .tooltip .tt-k { color: var(--text3); }
    .tooltip .tt-v { font-weight: 600; font-variant-numeric: tabular-nums; }

    /* Table */
    .pkt-table { width: 100%; border-collapse: collapse; font-size: 0.78rem; }
    .pkt-table th {
      text-align: left; padding: 8px 10px; color: var(--text3);
      font-weight: 500; font-size: 0.72rem; text-transform: uppercase;
      letter-spacing: 0.05em; border-bottom: 1px solid var(--border);
    }
    .pkt-table td { padding: 7px 10px; border-bottom: 1px solid rgba(30,48,96,.4); font-variant-numeric: tabular-nums; }
    .pkt-table tr:hover td { background: rgba(72,149,239,.04); }
    .pkt-table .ok { color: var(--green); font-weight: 700; }
    .pkt-table .miss { color: var(--red); font-weight: 700; }
    .pkt-table .be { color: var(--text3); }
    .pkt-table .flow-badge {
      display: inline-block; padding: 2px 8px; border-radius: 10px;
      font-size: 0.7rem; font-weight: 600;
    }

    /* Input area */
    .collapsible { cursor: pointer; user-select: none; }
    .collapsible .arrow { display: inline-block; transition: transform .2s; font-size: 0.7rem; }
    .collapsible.open .arrow { transform: rotate(90deg); }
    .collapse-body { display: none; margin-top: 12px; }
    .collapse-body.show { display: block; }
    textarea {
      width: 100%; min-height: 260px; resize: vertical;
      border: 1px solid var(--border); border-radius: 10px;
      background: rgba(6,13,31,.8); color: var(--text);
      padding: 12px; font-family: 'JetBrains Mono', 'Consolas', monospace;
      font-size: 0.78rem; line-height: 1.5;
    }
    textarea:focus { outline: none; border-color: var(--blue); }
    .toolbar { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    .btn {
      border: none; border-radius: 10px; padding: 10px 20px;
      cursor: pointer; font-weight: 700; font-size: 0.85rem;
      transition: all .2s; position: relative; overflow: hidden;
    }
    .btn-primary {
      background: linear-gradient(135deg, var(--cyan), var(--blue));
      color: #060d1f;
    }
    .btn-primary:hover { filter: brightness(1.1); transform: translateY(-1px); box-shadow: 0 4px 20px rgba(0,245,212,.2); }
    .btn-secondary {
      background: rgba(30,48,96,.5); color: var(--text);
      border: 1px solid var(--border);
    }
    .btn-secondary:hover { border-color: var(--blue); background: rgba(30,48,96,.8); }
    .btn:disabled { opacity: .5; cursor: not-allowed; }
    #status { margin-top: 8px; font-size: 0.82rem; color: var(--text2); }
    .status-ok { color: var(--green) !important; }
    .status-err { color: var(--red) !important; }
    pre {
      border: 1px solid var(--border); border-radius: 10px;
      background: rgba(6,13,31,.8); padding: 14px;
      color: var(--text2); font-size: 0.75rem;
      white-space: pre-wrap; overflow-x: auto;
      max-height: 400px; overflow-y: auto;
      font-family: 'JetBrains Mono', 'Consolas', monospace;
    }

    /* Flow legend */
    .legend { display: flex; flex-wrap: wrap; gap: 14px; margin-bottom: 12px; }
    .legend-item { display: flex; align-items: center; gap: 6px; font-size: 0.78rem; color: var(--text2); }
    .legend-dot { width: 10px; height: 10px; border-radius: 3px; }

    /* Responsive */
    @media (max-width: 600px) {
      .header h1 { font-size: 1.5rem; }
      .metrics { grid-template-columns: repeat(2, 1fr); }
    }

    /* Animate in */
    .card { animation: fadeUp .5s ease both; }
    .card:nth-child(2) { animation-delay: .05s; }
    .card:nth-child(3) { animation-delay: .1s; }
    .card:nth-child(4) { animation-delay: .15s; }
    @keyframes fadeUp { from { opacity: 0; transform: translateY(16px); } to { opacity: 1; transform: translateY(0); } }
  </style>
</head>
<body>
  <div class="bg-grid"></div>
  <div class="wrap">
    <div class="header">
      <h1>TSN / GCL ILP Solver</h1>
      <div class="sub">IEEE 802.1Qbv Time-Aware Shaper &mdash; Integer Linear Programming Optimization</div>
      <div class="badge">3-Switch Triangle Topology &bull; Multi-Flow Scheduling &bull; k-Path Routing</div>
    </div>

    <div class="metrics" id="metricsArea"></div>

    <div class="two-col">
      <div class="card">
        <div class="card-title">Network Topology</div>
        <div class="legend" id="topoLegend"></div>
        <div class="svg-container" id="topoContainer" style="height:380px;"></div>
      </div>
      <div class="card">
        <div class="card-title">Packet E2E Delay</div>
        <div class="svg-container" id="delayContainer" style="height:380px;"></div>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Per-Link GCL Timeline (Gantt)</div>
      <div class="legend" id="gclLegend"></div>
      <div class="svg-container" id="gclContainer"></div>
    </div>

    <div class="two-col">
      <div class="card">
        <div class="card-title">Link Utilization</div>
        <div class="svg-container" id="utilContainer" style="min-height:200px;"></div>
      </div>
      <div class="card">
        <div class="card-title">Packet Schedule Table</div>
        <div style="overflow-x:auto;">
          <table class="pkt-table">
            <thead><tr>
              <th>Packet</th><th>Flow</th><th>Route</th><th>Release</th><th>End</th><th>E2E</th><th>Deadline</th><th>Slack</th><th>Status</th>
            </tr></thead>
            <tbody id="pktTableBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-title collapsible" onclick="toggleCollapse(this)">
        <span class="arrow">&#9654;</span> Input Model (JSON)
      </div>
      <div class="collapse-body">
        <textarea id="input"></textarea>
        <div class="toolbar">
          <button class="btn btn-secondary" onclick="loadSample()">Load Sample</button>
          <button class="btn btn-primary" id="solveBtn" onclick="runSolve()">Solve ILP</button>
        </div>
        <div id="status"></div>
      </div>
    </div>

    <div class="card">
      <div class="card-title collapsible" onclick="toggleCollapse(this)">
        <span class="arrow">&#9654;</span> Raw GCL Output (JSON)
      </div>
      <div class="collapse-body">
        <pre id="jsonOut">-</pre>
      </div>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script>
  /* ═══════════════════════════════════════════════
     DATA
  ═══════════════════════════════════════════════ */
  const SAMPLE = {
    cycle_time_us: 1000, guard_band_us: 2, processing_delay_us: 2,
    nodes: [
      { id: "esA", type: "endstation" }, { id: "esB", type: "endstation" },
      { id: "esC", type: "endstation" }, { id: "s1", type: "switch" },
      { id: "s2", type: "switch" }, { id: "s3", type: "switch" }
    ],
    links: [
      { id: "l_esA_s1", from: "esA", to: "s1", rate_mbps: 1000, prop_delay_us: 0.8 },
      { id: "l_s1_s2", from: "s1", to: "s2", rate_mbps: 1000, prop_delay_us: 0.8 },
      { id: "l_s2_s1", from: "s2", to: "s1", rate_mbps: 1000, prop_delay_us: 0.8 },
      { id: "l_s2_s3", from: "s2", to: "s3", rate_mbps: 1000, prop_delay_us: 0.8 },
      { id: "l_s3_s2", from: "s3", to: "s2", rate_mbps: 1000, prop_delay_us: 0.8 },
      { id: "l_s3_s1", from: "s3", to: "s1", rate_mbps: 1000, prop_delay_us: 0.8 },
      { id: "l_s1_s3", from: "s1", to: "s3", rate_mbps: 1000, prop_delay_us: 0.8 },
      { id: "l_s2_esB", from: "s2", to: "esB", rate_mbps: 1000, prop_delay_us: 0.8 },
      { id: "l_s3_esC", from: "s3", to: "esC", rate_mbps: 1000, prop_delay_us: 0.8 }
    ],
    flows: [
      { id: "f_ctrl_A_to_B", priority: 7, payload_bytes: 280, period_us: 250, deadline_us: 130, traffic_type: "control", src: "esA", dst: "esB", k_paths: 3 },
      { id: "f_sensor_A_to_C", priority: 6, payload_bytes: 220, period_us: 500, deadline_us: 180, traffic_type: "sensor", src: "esA", dst: "esC", k_paths: 3 },
      { id: "f_video_A_loop", priority: 3, payload_bytes: 900, period_us: 1000, deadline_us: null, traffic_type: "video", src: "esA", dst: "s1", k_paths: 4 }
    ]
  };

  const DEMO_RESULT = {"method":"ILP(GLPK, Route+Schedule)","objective":89.44,"worst_util_percent":3.381,"packetRows":[{"packet_id":"f_sensor_A_to_C#0","flow_id":"f_sensor_A_to_C","priority":6,"selected_route":0,"release_us":0,"end_us":12.592,"e2e_delay_us":12.592,"deadline_abs_us":180,"slack_us":167.408,"status":"OK","hops":[{"link_id":"l_esA_s1","start_us":0,"end_us":2.064,"duration_us":2.064},{"link_id":"l_s1_s3","start_us":4.864,"end_us":6.928,"duration_us":2.064},{"link_id":"l_s3_esC","start_us":9.728,"end_us":11.792,"duration_us":2.064}]},{"packet_id":"f_video_A_loop#0","flow_id":"f_video_A_loop","priority":3,"selected_route":0,"release_us":0,"end_us":16.912,"e2e_delay_us":16.912,"deadline_abs_us":null,"slack_us":null,"status":"BE","hops":[{"link_id":"l_esA_s1","start_us":8.608,"end_us":16.112,"duration_us":7.504}]},{"packet_id":"f_ctrl_A_to_B#0","flow_id":"f_ctrl_A_to_B","priority":7,"selected_route":0,"release_us":0,"end_us":18.096,"e2e_delay_us":18.096,"deadline_abs_us":130,"slack_us":111.904,"status":"OK","hops":[{"link_id":"l_esA_s1","start_us":4.064,"end_us":6.608,"duration_us":2.544},{"link_id":"l_s1_s2","start_us":9.408,"end_us":11.952,"duration_us":2.544},{"link_id":"l_s2_esB","start_us":14.752,"end_us":17.296,"duration_us":2.544}]},{"packet_id":"f_ctrl_A_to_B#1","flow_id":"f_ctrl_A_to_B","priority":7,"selected_route":0,"release_us":250,"end_us":264.032,"e2e_delay_us":14.032,"deadline_abs_us":380,"slack_us":115.968,"status":"OK","hops":[{"link_id":"l_esA_s1","start_us":250,"end_us":252.544,"duration_us":2.544},{"link_id":"l_s1_s2","start_us":255.344,"end_us":257.888,"duration_us":2.544},{"link_id":"l_s2_esB","start_us":260.688,"end_us":263.232,"duration_us":2.544}]},{"packet_id":"f_sensor_A_to_C#1","flow_id":"f_sensor_A_to_C","priority":6,"selected_route":0,"release_us":500,"end_us":512.592,"e2e_delay_us":12.592,"deadline_abs_us":680,"slack_us":167.408,"status":"OK","hops":[{"link_id":"l_esA_s1","start_us":500,"end_us":502.064,"duration_us":2.064},{"link_id":"l_s1_s3","start_us":504.864,"end_us":506.928,"duration_us":2.064},{"link_id":"l_s3_esC","start_us":509.728,"end_us":511.792,"duration_us":2.064}]},{"packet_id":"f_ctrl_A_to_B#2","flow_id":"f_ctrl_A_to_B","priority":7,"selected_route":0,"release_us":500,"end_us":518.096,"e2e_delay_us":18.096,"deadline_abs_us":630,"slack_us":111.904,"status":"OK","hops":[{"link_id":"l_esA_s1","start_us":504.064,"end_us":506.608,"duration_us":2.544},{"link_id":"l_s1_s2","start_us":509.408,"end_us":511.952,"duration_us":2.544},{"link_id":"l_s2_esB","start_us":514.752,"end_us":517.296,"duration_us":2.544}]},{"packet_id":"f_ctrl_A_to_B#3","flow_id":"f_ctrl_A_to_B","priority":7,"selected_route":0,"release_us":750,"end_us":764.032,"e2e_delay_us":14.032,"deadline_abs_us":880,"slack_us":115.968,"status":"OK","hops":[{"link_id":"l_esA_s1","start_us":750,"end_us":752.544,"duration_us":2.544},{"link_id":"l_s1_s2","start_us":755.344,"end_us":757.888,"duration_us":2.544},{"link_id":"l_s2_esB","start_us":760.688,"end_us":763.232,"duration_us":2.544}]}],"gcl":{"cycle_time_us":1000,"base_time_us":0,"links":{"l_esA_s1":{"from":"esA","to":"s1","entries":[{"index":0,"gate_mask":"01000000","start_us":0,"end_us":2.064,"duration_us":2.064,"note":"f_sensor_A_to_C#0"},{"index":1,"gate_mask":"00000000","start_us":2.064,"end_us":4.064,"duration_us":2,"note":"guard band"},{"index":2,"gate_mask":"10000000","start_us":4.064,"end_us":6.608,"duration_us":2.544,"note":"f_ctrl_A_to_B#0"},{"index":3,"gate_mask":"00000000","start_us":6.608,"end_us":8.608,"duration_us":2,"note":"guard band"},{"index":4,"gate_mask":"00001000","start_us":8.608,"end_us":16.112,"duration_us":7.504,"note":"f_video_A_loop#0"},{"index":5,"gate_mask":"00001111","start_us":16.112,"end_us":250,"duration_us":233.888,"note":"best-effort gap"},{"index":6,"gate_mask":"10000000","start_us":250,"end_us":252.544,"duration_us":2.544,"note":"f_ctrl_A_to_B#1"},{"index":7,"gate_mask":"00000000","start_us":252.544,"end_us":254.544,"duration_us":2,"note":"guard band"},{"index":8,"gate_mask":"00001111","start_us":254.544,"end_us":500,"duration_us":245.456,"note":"best-effort gap"},{"index":9,"gate_mask":"01000000","start_us":500,"end_us":502.064,"duration_us":2.064,"note":"f_sensor_A_to_C#1"},{"index":10,"gate_mask":"00000000","start_us":502.064,"end_us":504.064,"duration_us":2,"note":"guard band"},{"index":11,"gate_mask":"10000000","start_us":504.064,"end_us":506.608,"duration_us":2.544,"note":"f_ctrl_A_to_B#2"},{"index":12,"gate_mask":"00000000","start_us":506.608,"end_us":508.608,"duration_us":2,"note":"guard band"},{"index":13,"gate_mask":"00001111","start_us":508.608,"end_us":750,"duration_us":241.392,"note":"best-effort gap"},{"index":14,"gate_mask":"10000000","start_us":750,"end_us":752.544,"duration_us":2.544,"note":"f_ctrl_A_to_B#3"},{"index":15,"gate_mask":"00000000","start_us":752.544,"end_us":754.544,"duration_us":2,"note":"guard band"},{"index":16,"gate_mask":"00001111","start_us":754.544,"end_us":1000,"duration_us":245.456,"note":"best-effort remainder"}]},"l_s1_s2":{"from":"s1","to":"s2","entries":[{"index":0,"gate_mask":"00001111","start_us":0,"end_us":9.408,"duration_us":9.408,"note":"best-effort gap"},{"index":1,"gate_mask":"10000000","start_us":9.408,"end_us":11.952,"duration_us":2.544,"note":"f_ctrl_A_to_B#0"},{"index":2,"gate_mask":"00000000","start_us":11.952,"end_us":13.952,"duration_us":2,"note":"guard band"},{"index":3,"gate_mask":"00001111","start_us":13.952,"end_us":255.344,"duration_us":241.392,"note":"best-effort gap"},{"index":4,"gate_mask":"10000000","start_us":255.344,"end_us":257.888,"duration_us":2.544,"note":"f_ctrl_A_to_B#1"},{"index":5,"gate_mask":"00000000","start_us":257.888,"end_us":259.888,"duration_us":2,"note":"guard band"},{"index":6,"gate_mask":"00001111","start_us":259.888,"end_us":509.408,"duration_us":249.52,"note":"best-effort gap"},{"index":7,"gate_mask":"10000000","start_us":509.408,"end_us":511.952,"duration_us":2.544,"note":"f_ctrl_A_to_B#2"},{"index":8,"gate_mask":"00000000","start_us":511.952,"end_us":513.952,"duration_us":2,"note":"guard band"},{"index":9,"gate_mask":"00001111","start_us":513.952,"end_us":755.344,"duration_us":241.392,"note":"best-effort gap"},{"index":10,"gate_mask":"10000000","start_us":755.344,"end_us":757.888,"duration_us":2.544,"note":"f_ctrl_A_to_B#3"},{"index":11,"gate_mask":"00000000","start_us":757.888,"end_us":759.888,"duration_us":2,"note":"guard band"},{"index":12,"gate_mask":"00001111","start_us":759.888,"end_us":1000,"duration_us":240.112,"note":"best-effort remainder"}]},"l_s2_s1":{"from":"s2","to":"s1","entries":[{"index":0,"gate_mask":"00001111","start_us":0,"end_us":1000,"duration_us":1000,"note":"best-effort remainder"}]},"l_s2_s3":{"from":"s2","to":"s3","entries":[{"index":0,"gate_mask":"00001111","start_us":0,"end_us":1000,"duration_us":1000,"note":"best-effort remainder"}]},"l_s3_s2":{"from":"s3","to":"s2","entries":[{"index":0,"gate_mask":"00001111","start_us":0,"end_us":1000,"duration_us":1000,"note":"best-effort remainder"}]},"l_s3_s1":{"from":"s3","to":"s1","entries":[{"index":0,"gate_mask":"00001111","start_us":0,"end_us":1000,"duration_us":1000,"note":"best-effort remainder"}]},"l_s1_s3":{"from":"s1","to":"s3","entries":[{"index":0,"gate_mask":"00001111","start_us":0,"end_us":4.864,"duration_us":4.864,"note":"best-effort gap"},{"index":1,"gate_mask":"01000000","start_us":4.864,"end_us":6.928,"duration_us":2.064,"note":"f_sensor_A_to_C#0"},{"index":2,"gate_mask":"00000000","start_us":6.928,"end_us":8.928,"duration_us":2,"note":"guard band"},{"index":3,"gate_mask":"00001111","start_us":8.928,"end_us":504.864,"duration_us":495.936,"note":"best-effort gap"},{"index":4,"gate_mask":"01000000","start_us":504.864,"end_us":506.928,"duration_us":2.064,"note":"f_sensor_A_to_C#1"},{"index":5,"gate_mask":"00000000","start_us":506.928,"end_us":508.928,"duration_us":2,"note":"guard band"},{"index":6,"gate_mask":"00001111","start_us":508.928,"end_us":1000,"duration_us":491.072,"note":"best-effort remainder"}]},"l_s2_esB":{"from":"s2","to":"esB","entries":[{"index":0,"gate_mask":"00001111","start_us":0,"end_us":14.752,"duration_us":14.752,"note":"best-effort gap"},{"index":1,"gate_mask":"10000000","start_us":14.752,"end_us":17.296,"duration_us":2.544,"note":"f_ctrl_A_to_B#0"},{"index":2,"gate_mask":"00000000","start_us":17.296,"end_us":19.296,"duration_us":2,"note":"guard band"},{"index":3,"gate_mask":"00001111","start_us":19.296,"end_us":260.688,"duration_us":241.392,"note":"best-effort gap"},{"index":4,"gate_mask":"10000000","start_us":260.688,"end_us":263.232,"duration_us":2.544,"note":"f_ctrl_A_to_B#1"},{"index":5,"gate_mask":"00000000","start_us":263.232,"end_us":265.232,"duration_us":2,"note":"guard band"},{"index":6,"gate_mask":"00001111","start_us":265.232,"end_us":514.752,"duration_us":249.52,"note":"best-effort gap"},{"index":7,"gate_mask":"10000000","start_us":514.752,"end_us":517.296,"duration_us":2.544,"note":"f_ctrl_A_to_B#2"},{"index":8,"gate_mask":"00000000","start_us":517.296,"end_us":519.296,"duration_us":2,"note":"guard band"},{"index":9,"gate_mask":"00001111","start_us":519.296,"end_us":760.688,"duration_us":241.392,"note":"best-effort gap"},{"index":10,"gate_mask":"10000000","start_us":760.688,"end_us":763.232,"duration_us":2.544,"note":"f_ctrl_A_to_B#3"},{"index":11,"gate_mask":"00000000","start_us":763.232,"end_us":765.232,"duration_us":2,"note":"guard band"},{"index":12,"gate_mask":"00001111","start_us":765.232,"end_us":1000,"duration_us":234.768,"note":"best-effort remainder"}]},"l_s3_esC":{"from":"s3","to":"esC","entries":[{"index":0,"gate_mask":"00001111","start_us":0,"end_us":9.728,"duration_us":9.728,"note":"best-effort gap"},{"index":1,"gate_mask":"01000000","start_us":9.728,"end_us":11.792,"duration_us":2.064,"note":"f_sensor_A_to_C#0"},{"index":2,"gate_mask":"00000000","start_us":11.792,"end_us":13.792,"duration_us":2,"note":"guard band"},{"index":3,"gate_mask":"00001111","start_us":13.792,"end_us":509.728,"duration_us":495.936,"note":"best-effort gap"},{"index":4,"gate_mask":"01000000","start_us":509.728,"end_us":511.792,"duration_us":2.064,"note":"f_sensor_A_to_C#1"},{"index":5,"gate_mask":"00000000","start_us":511.792,"end_us":513.792,"duration_us":2,"note":"guard band"},{"index":6,"gate_mask":"00001111","start_us":513.792,"end_us":1000,"duration_us":486.208,"note":"best-effort remainder"}]}}},"stats":{"constraints":433,"variables":205,"binaries":162,"status":5},"runtime_ms":1854};

  /* Flow color mapping */
  const FLOW_COLORS = {
    control: "var(--flow-ctrl)",
    sensor: "var(--flow-sensor)",
    video: "var(--flow-video)"
  };
  const FLOW_COLORS_HEX = { control: "#4895ef", sensor: "#00f5d4", video: "#f06292" };

  function flowColor(flowId) {
    if (flowId.includes("ctrl")) return FLOW_COLORS_HEX.control;
    if (flowId.includes("sensor")) return FLOW_COLORS_HEX.sensor;
    if (flowId.includes("video")) return FLOW_COLORS_HEX.video;
    return "#7b61ff";
  }

  function flowType(flowId) {
    if (flowId.includes("ctrl")) return "control";
    if (flowId.includes("sensor")) return "sensor";
    if (flowId.includes("video")) return "video";
    return "unknown";
  }

  let currentModel = SAMPLE;
  let currentResult = DEMO_RESULT;

  /* ═══════════════════════════════════════════════
     TOOLTIP
  ═══════════════════════════════════════════════ */
  const tooltip = document.getElementById("tooltip");

  function showTip(evt, html) {
    tooltip.innerHTML = html;
    tooltip.classList.add("show");
    const x = Math.min(evt.clientX + 14, window.innerWidth - 300);
    const y = Math.min(evt.clientY - 10, window.innerHeight - 200);
    tooltip.style.left = x + "px";
    tooltip.style.top = y + "px";
  }

  function hideTip() { tooltip.classList.remove("show"); }

  /* ═══════════════════════════════════════════════
     COLLAPSIBLE
  ═══════════════════════════════════════════════ */
  function toggleCollapse(el) {
    el.classList.toggle("open");
    const body = el.parentElement.querySelector(".collapse-body");
    body.classList.toggle("show");
  }

  /* ═══════════════════════════════════════════════
     METRICS
  ═══════════════════════════════════════════════ */
  function renderMetrics(model, result) {
    const area = document.getElementById("metricsArea");
    const tsnPkts = result.packetRows.filter(p => p.status !== "BE");
    const allOk = tsnPkts.every(p => p.status === "OK");
    const avgDelay = tsnPkts.length ? (tsnPkts.reduce((s, p) => s + p.e2e_delay_us, 0) / tsnPkts.length).toFixed(2) : "-";

    const items = [
      { val: model.nodes.length, label: "Nodes", sub: `${model.nodes.filter(n=>n.type==="switch").length} switches`, cls: "" },
      { val: model.links.length, label: "Links", sub: "bidirectional", cls: "" },
      { val: model.flows.length, label: "Flows", sub: `${result.packetRows.length} pkts/cycle`, cls: "" },
      { val: result.method.split("(")[0], label: "Solver", sub: `${result.stats.variables} vars, ${result.stats.binaries} bins`, cls: "" },
      { val: result.objective + " us", label: "Objective", sub: "TSN delay sum", cls: "warn" },
      { val: result.worst_util_percent + "%", label: "Worst Util", sub: "link utilization", cls: result.worst_util_percent > 80 ? "warn" : "" },
      { val: avgDelay + " us", label: "Avg TSN Delay", sub: `${tsnPkts.length} TSN packets`, cls: "" },
      { val: allOk ? "ALL OK" : "MISS", label: "Feasibility", sub: `${result.stats.constraints} constraints`, cls: allOk ? "ok" : "warn" }
    ];

    area.innerHTML = items.map(m => `
      <div class="metric-card ${m.cls}">
        <div class="metric-val">${m.val}</div>
        <div class="metric-label">${m.label}</div>
        <div class="metric-sub">${m.sub}</div>
      </div>
    `).join("");
  }

  /* ═══════════════════════════════════════════════
     D3: TOPOLOGY (Force Graph)
  ═══════════════════════════════════════════════ */
  function renderTopology(model, result) {
    const container = document.getElementById("topoContainer");
    container.innerHTML = "";

    const W = container.clientWidth;
    const H = 380;

    // Build legend
    const legendEl = document.getElementById("topoLegend");
    legendEl.innerHTML = "";
    const flowTypes = [...new Set(model.flows.map(f => f.traffic_type))];
    flowTypes.forEach(ft => {
      const c = FLOW_COLORS_HEX[ft] || "#7b61ff";
      legendEl.innerHTML += `<div class="legend-item"><div class="legend-dot" style="background:${c}"></div>${ft} (P${model.flows.find(f=>f.traffic_type===ft).priority})</div>`;
    });
    legendEl.innerHTML += `<div class="legend-item"><div class="legend-dot" style="background:#2a4080"></div>switch</div>`;
    legendEl.innerHTML += `<div class="legend-item"><div class="legend-dot" style="background:#1a5040"></div>endstation</div>`;

    const svg = d3.select(container).append("svg")
      .attr("viewBox", `0 0 ${W} ${H}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    // Defs
    const defs = svg.append("defs");

    // Glow filter
    const glow = defs.append("filter").attr("id", "glow");
    glow.append("feGaussianBlur").attr("stdDeviation", "3").attr("result", "blur");
    glow.append("feMerge").selectAll("feMergeNode")
      .data(["blur", "SourceGraphic"]).enter()
      .append("feMergeNode").attr("in", d => d);

    // Arrow marker
    defs.append("marker")
      .attr("id", "arrowhead")
      .attr("viewBox", "0 0 10 7").attr("refX", 35).attr("refY", 3.5)
      .attr("markerWidth", 8).attr("markerHeight", 6)
      .attr("orient", "auto")
      .append("polygon").attr("points", "0 0, 10 3.5, 0 7").attr("fill", "#3a5590");

    // Build unique links (no duplicates for same pair)
    const linkPairs = new Map();
    model.links.forEach(l => {
      const key = [l.from, l.to].sort().join("-");
      if (!linkPairs.has(key)) linkPairs.set(key, []);
      linkPairs.get(key).push(l);
    });

    const nodes = model.nodes.map(n => ({
      id: n.id, type: n.type,
      color: n.type === "switch" ? "#2a4080" : "#1a5040",
      stroke: n.type === "switch" ? "#4895ef" : "#00f5d4"
    }));

    const uniqueLinks = [];
    linkPairs.forEach((links, key) => {
      const [a, b] = key.split("-");
      uniqueLinks.push({
        source: links[0].from, target: links[0].to,
        bidir: links.length > 1, ids: links.map(l => l.id)
      });
    });

    // Fixed positions for triangle layout
    const positions = {
      s1: { x: W / 2, y: 80 },
      s2: { x: W / 2 - 140, y: 240 },
      s3: { x: W / 2 + 140, y: 240 },
      esA: { x: W / 2 - 30, y: 20 },
      esB: { x: W / 2 - 240, y: 310 },
      esC: { x: W / 2 + 240, y: 310 }
    };

    nodes.forEach(n => {
      if (positions[n.id]) {
        n.fx = positions[n.id].x;
        n.fy = positions[n.id].y;
      }
    });

    const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(uniqueLinks).id(d => d.id).distance(120))
      .force("charge", d3.forceManyBody().strength(-200))
      .force("center", d3.forceCenter(W / 2, H / 2))
      .alphaDecay(0.05);

    // Draw links
    const linkG = svg.append("g");
    const linkLine = linkG.selectAll("line")
      .data(uniqueLinks).enter().append("line")
      .attr("class", "topo-link")
      .attr("marker-end", "url(#arrowhead)");

    // Draw flow paths from result
    const flowPaths = [];
    if (result) {
      result.packetRows.forEach(p => {
        if (p.selected_route === 0 && !flowPaths.some(fp => fp.flow_id === p.flow_id)) {
          const pathNodes = [];
          // Build path from hops
          p.hops.forEach(h => {
            const link = model.links.find(l => l.id === h.link_id);
            if (link) {
              if (pathNodes.length === 0) pathNodes.push(link.from);
              pathNodes.push(link.to);
            }
          });
          flowPaths.push({ flow_id: p.flow_id, path: pathNodes, color: flowColor(p.flow_id) });
        }
      });
    }

    // Flow path lines (curved)
    const flowG = svg.append("g");
    const flowLines = flowG.selectAll("path")
      .data(flowPaths).enter().append("path")
      .attr("class", "flow-path")
      .attr("stroke", d => d.color)
      .attr("stroke-dasharray", "8,4")
      .attr("filter", "url(#glow)");

    // Animate flow dashes
    function animateFlows() {
      flowLines.attr("stroke-dashoffset", 0)
        .transition().duration(2000).ease(d3.easeLinear)
        .attr("stroke-dashoffset", -24)
        .on("end", animateFlows);
    }

    // Particles
    const particleG = svg.append("g");

    function createParticles() {
      flowPaths.forEach(fp => {
        const nodeMap = new Map(nodes.map(n => [n.id, n]));
        const points = fp.path.map(id => nodeMap.get(id)).filter(Boolean);
        if (points.length < 2) return;

        const particle = particleG.append("circle")
          .attr("class", "flow-particle")
          .attr("r", 4)
          .attr("fill", fp.color)
          .attr("filter", "url(#glow)");

        function animateParticle() {
          let chain = particle
            .attr("cx", points[0].x || points[0].fx)
            .attr("cy", points[0].y || points[0].fy)
            .attr("opacity", 0.9);

          for (let i = 1; i < points.length; i++) {
            chain = chain.transition()
              .duration(600)
              .ease(d3.easeLinear)
              .attr("cx", points[i].x || points[i].fx)
              .attr("cy", points[i].y || points[i].fy);
          }
          chain.transition().duration(200)
            .attr("opacity", 0)
            .transition().delay(500 + Math.random() * 1000)
            .on("end", animateParticle);
        }

        setTimeout(animateParticle, Math.random() * 2000);
      });
    }

    // Draw nodes
    const nodeG = svg.append("g");
    const node = nodeG.selectAll("g")
      .data(nodes).enter().append("g")
      .attr("class", "topo-node")
      .call(d3.drag()
        .on("start", (e, d) => { if (!e.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
        .on("drag", (e, d) => { d.fx = e.x; d.fy = e.y; })
        .on("end", (e, d) => { if (!e.active) simulation.alphaTarget(0); })
      );

    // Outer glow ring
    node.append("circle")
      .attr("r", 30)
      .attr("fill", "none")
      .attr("stroke", d => d.stroke)
      .attr("stroke-width", 1)
      .attr("opacity", 0.15);

    // Main circle
    node.append("circle")
      .attr("r", 22)
      .attr("fill", d => d.color)
      .attr("stroke", d => d.stroke)
      .attr("stroke-width", 2);

    // Icon (text)
    node.append("text")
      .attr("class", "topo-label")
      .attr("dy", -1)
      .text(d => d.id);

    // Type label
    node.append("text")
      .attr("class", "topo-type")
      .attr("dy", 12)
      .text(d => d.type === "switch" ? "SW" : "ES");

    simulation.on("tick", () => {
      linkLine
        .attr("x1", d => d.source.x).attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x).attr("y2", d => d.target.y);

      node.attr("transform", d => `translate(${d.x},${d.y})`);

      // Update flow paths
      flowLines.attr("d", fp => {
        const nodeMap = new Map(nodes.map(n => [n.id, n]));
        const points = fp.path.map(id => nodeMap.get(id)).filter(Boolean);
        if (points.length < 2) return "";
        const lineGen = d3.line()
          .x(d => d.x).y(d => d.y)
          .curve(d3.curveCatmullRom.alpha(0.5));
        // Offset slightly based on flow
        const offset = flowPaths.indexOf(fp) * 3 - 3;
        return lineGen(points.map(p => ({ x: p.x + offset, y: p.y + offset })));
      });
    });

    setTimeout(() => {
      animateFlows();
      createParticles();
    }, 500);
  }

  /* ═══════════════════════════════════════════════
     D3: GCL TIMELINE (Gantt Chart)
  ═══════════════════════════════════════════════ */
  function renderGCL(model, result) {
    const container = document.getElementById("gclContainer");
    container.innerHTML = "";

    // Legend
    const legendEl = document.getElementById("gclLegend");
    legendEl.innerHTML = [
      `<div class="legend-item"><div class="legend-dot" style="background:${FLOW_COLORS_HEX.control}"></div>Control</div>`,
      `<div class="legend-item"><div class="legend-dot" style="background:${FLOW_COLORS_HEX.sensor}"></div>Sensor</div>`,
      `<div class="legend-item"><div class="legend-dot" style="background:${FLOW_COLORS_HEX.video}"></div>Video</div>`,
      `<div class="legend-item"><div class="legend-dot" style="background:#f9a825"></div>Guard Band</div>`,
      `<div class="legend-item"><div class="legend-dot" style="background:#1a3050"></div>Best-Effort</div>`,
    ].join("");

    // Filter to only links with TSN entries
    const activeLinks = model.links.filter(l => {
      const entries = result.gcl.links[l.id]?.entries || [];
      return entries.some(e => !e.note.includes("best-effort"));
    });

    const margin = { top: 30, right: 30, bottom: 40, left: 110 };
    const rowH = 44;
    const W = container.clientWidth;
    const H = margin.top + activeLinks.length * rowH + margin.bottom;

    const svg = d3.select(container).append("svg")
      .attr("viewBox", `0 0 ${W} ${H}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
    const innerW = W - margin.left - margin.right;
    const innerH = activeLinks.length * rowH;

    // Scales
    const x = d3.scaleLinear().domain([0, model.cycle_time_us]).range([0, innerW]);
    const y = d3.scaleBand().domain(activeLinks.map(l => l.id)).range([0, innerH]).padding(0.2);

    // Grid
    const xTicks = x.ticks(10);
    g.append("g").attr("class", "gcl-grid")
      .selectAll("line").data(xTicks).enter().append("line")
      .attr("x1", d => x(d)).attr("x2", d => x(d))
      .attr("y1", 0).attr("y2", innerH);

    // X axis
    g.append("g").attr("class", "gcl-axis")
      .attr("transform", `translate(0,${innerH})`)
      .call(d3.axisBottom(x).ticks(10).tickFormat(d => d + " us"))
      .selectAll("text").attr("fill", "var(--text3)");

    // Y axis
    g.append("g").attr("class", "gcl-axis")
      .call(d3.axisLeft(y).tickSize(0).tickPadding(8))
      .selectAll("text")
      .attr("fill", "var(--text2)")
      .attr("font-size", "10px")
      .text(d => {
        const link = model.links.find(l => l.id === d);
        return link ? `${link.from} → ${link.to}` : d;
      });

    // Row backgrounds
    g.selectAll(".row-bg")
      .data(activeLinks).enter().append("rect")
      .attr("x", 0).attr("y", d => y(d.id))
      .attr("width", innerW).attr("height", y.bandwidth())
      .attr("fill", "rgba(255,255,255,.015)")
      .attr("rx", 4);

    // GCL bars
    activeLinks.forEach(link => {
      const entries = result.gcl.links[link.id]?.entries || [];
      const barG = g.append("g");

      barG.selectAll("rect")
        .data(entries).enter().append("rect")
        .attr("class", "gcl-bar")
        .attr("x", d => x(d.start_us))
        .attr("y", y(link.id))
        .attr("width", 0)
        .attr("height", y.bandwidth())
        .attr("fill", d => {
          if (d.note.includes("guard")) return "#f9a825";
          if (d.note.includes("best-effort")) return "#0d1a30";
          return flowColor(d.note);
        })
        .attr("stroke", d => {
          if (d.note.includes("best-effort")) return "rgba(30,48,96,.5)";
          return "none";
        })
        .attr("stroke-width", 0.5)
        .attr("opacity", d => d.note.includes("best-effort") ? 0.3 : 0.85)
        .on("mouseover", (evt, d) => {
          showTip(evt, `
            <div class="tt-title">${d.note}</div>
            <div class="tt-row"><span class="tt-k">Gate</span><span class="tt-v">${d.gate_mask}</span></div>
            <div class="tt-row"><span class="tt-k">Start</span><span class="tt-v">${d.start_us} us</span></div>
            <div class="tt-row"><span class="tt-k">End</span><span class="tt-v">${d.end_us} us</span></div>
            <div class="tt-row"><span class="tt-k">Duration</span><span class="tt-v">${d.duration_us} us</span></div>
          `);
        })
        .on("mousemove", (evt) => {
          tooltip.style.left = (evt.clientX + 14) + "px";
          tooltip.style.top = (evt.clientY - 10) + "px";
        })
        .on("mouseout", hideTip)
        .transition().duration(800).delay((d, i) => i * 30)
        .attr("width", d => Math.max(x(d.duration_us) - x(0), 1));

      // Labels on flow bars
      barG.selectAll("text")
        .data(entries.filter(e => !e.note.includes("best-effort") && !e.note.includes("guard") && (x(e.duration_us) - x(0)) > 30))
        .enter().append("text")
        .attr("class", "gcl-label")
        .attr("x", d => x(d.start_us) + (x(d.duration_us) - x(0)) / 2)
        .attr("y", d => y(link.id) + y.bandwidth() / 2)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "central")
        .attr("opacity", 0)
        .text(d => d.note.split("#")[0].replace("f_", "").substring(0, 8))
        .transition().delay(800).duration(300).attr("opacity", 1);
    });

    // Cycle markers
    svg.append("text")
      .attr("x", margin.left).attr("y", margin.top - 10)
      .attr("fill", "var(--text3)").attr("font-size", "10px")
      .text(`Cycle: ${model.cycle_time_us} us | Guard: ${model.guard_band_us} us | Active Links: ${activeLinks.length}/${model.links.length}`);
  }

  /* ═══════════════════════════════════════════════
     D3: PACKET DELAY CHART
  ═══════════════════════════════════════════════ */
  function renderDelayChart(model, result) {
    const container = document.getElementById("delayContainer");
    container.innerHTML = "";

    const margin = { top: 20, right: 20, bottom: 60, left: 55 };
    const W = container.clientWidth;
    const H = 380;

    const svg = d3.select(container).append("svg")
      .attr("viewBox", `0 0 ${W} ${H}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
    const innerW = W - margin.left - margin.right;
    const innerH = H - margin.top - margin.bottom;

    const pkts = result.packetRows;

    const x = d3.scaleBand().domain(pkts.map(p => p.packet_id)).range([0, innerW]).padding(0.25);
    const maxDelay = Math.max(...pkts.map(p => Math.max(p.e2e_delay_us, p.deadline_abs_us || 0)));
    const y = d3.scaleLinear().domain([0, maxDelay * 1.15]).range([innerH, 0]);

    // Grid
    g.append("g").attr("class", "gcl-grid")
      .selectAll("line").data(y.ticks(6)).enter().append("line")
      .attr("x1", 0).attr("x2", innerW)
      .attr("y1", d => y(d)).attr("y2", d => y(d));

    // Deadline lines
    const deadlineGroups = {};
    pkts.forEach(p => {
      if (p.deadline_abs_us != null) {
        const dlRel = p.deadline_abs_us - p.release_us;
        const key = p.flow_id;
        if (!deadlineGroups[key]) deadlineGroups[key] = { flow_id: key, deadline: dlRel };
      }
    });

    Object.values(deadlineGroups).forEach(dg => {
      g.append("line")
        .attr("class", "deadline-line")
        .attr("x1", 0).attr("x2", innerW)
        .attr("y1", y(dg.deadline)).attr("y2", y(dg.deadline));

      g.append("text")
        .attr("x", innerW - 4).attr("y", y(dg.deadline) - 5)
        .attr("text-anchor", "end")
        .attr("fill", "var(--red)").attr("font-size", "9px")
        .text(`Deadline: ${dg.flow_id.replace("f_", "")} (${dg.deadline} us)`);
    });

    // Bars
    g.selectAll(".delay-bar")
      .data(pkts).enter().append("rect")
      .attr("class", "delay-bar")
      .attr("x", d => x(d.packet_id))
      .attr("y", innerH)
      .attr("width", x.bandwidth())
      .attr("height", 0)
      .attr("fill", d => flowColor(d.flow_id))
      .attr("opacity", 0.85)
      .on("mouseover", (evt, d) => {
        showTip(evt, `
          <div class="tt-title">${d.packet_id}</div>
          <div class="tt-row"><span class="tt-k">E2E Delay</span><span class="tt-v">${d.e2e_delay_us} us</span></div>
          <div class="tt-row"><span class="tt-k">Release</span><span class="tt-v">${d.release_us} us</span></div>
          <div class="tt-row"><span class="tt-k">Finish</span><span class="tt-v">${d.end_us} us</span></div>
          ${d.deadline_abs_us != null ? `<div class="tt-row"><span class="tt-k">Slack</span><span class="tt-v" style="color:${d.slack_us > 0 ? 'var(--green)' : 'var(--red)'}">${d.slack_us} us</span></div>` : ''}
          <div class="tt-row"><span class="tt-k">Status</span><span class="tt-v">${d.status}</span></div>
        `);
      })
      .on("mousemove", (evt) => {
        tooltip.style.left = (evt.clientX + 14) + "px";
        tooltip.style.top = (evt.clientY - 10) + "px";
      })
      .on("mouseout", hideTip)
      .transition().duration(800).delay((d, i) => i * 80).ease(d3.easeCubicOut)
      .attr("y", d => y(d.e2e_delay_us))
      .attr("height", d => innerH - y(d.e2e_delay_us));

    // Value labels on bars
    g.selectAll(".bar-val")
      .data(pkts).enter().append("text")
      .attr("x", d => x(d.packet_id) + x.bandwidth() / 2)
      .attr("y", d => y(d.e2e_delay_us) - 6)
      .attr("text-anchor", "middle")
      .attr("fill", "var(--text2)")
      .attr("font-size", "9px")
      .attr("font-weight", "600")
      .attr("opacity", 0)
      .text(d => d.e2e_delay_us.toFixed(1))
      .transition().delay(800).duration(300).attr("opacity", 1);

    // Axes
    g.append("g").attr("class", "delay-axis")
      .attr("transform", `translate(0,${innerH})`)
      .call(d3.axisBottom(x).tickSize(0).tickPadding(8))
      .selectAll("text")
      .attr("transform", "rotate(-35)")
      .attr("text-anchor", "end")
      .attr("font-size", "8px")
      .text(d => d.replace("f_", "").replace("_A_to_", "→"));

    g.append("g").attr("class", "delay-axis")
      .call(d3.axisLeft(y).ticks(6).tickFormat(d => d + " us"));

    // Y label
    svg.append("text")
      .attr("transform", `rotate(-90)`)
      .attr("x", -H / 2).attr("y", 14)
      .attr("text-anchor", "middle")
      .attr("fill", "var(--text3)").attr("font-size", "10px")
      .text("E2E Delay (us)");
  }

  /* ═══════════════════════════════════════════════
     D3: LINK UTILIZATION (Donut Charts)
  ═══════════════════════════════════════════════ */
  function renderUtilization(model, result) {
    const container = document.getElementById("utilContainer");
    container.innerHTML = "";

    // Filter active links
    const linkData = model.links.map(l => {
      const entries = result.gcl.links[l.id]?.entries || [];
      let flowTime = 0, guardTime = 0, beTime = 0;
      entries.forEach(e => {
        if (e.note.includes("best-effort")) beTime += e.duration_us;
        else if (e.note.includes("guard")) guardTime += e.duration_us;
        else flowTime += e.duration_us;
      });
      return {
        id: l.id, from: l.from, to: l.to,
        flow: flowTime, guard: guardTime, be: beTime,
        util: ((flowTime + guardTime) / model.cycle_time_us * 100).toFixed(1)
      };
    }).filter(l => l.flow > 0 || l.guard > 0);

    const donutSize = 90;
    const cols = Math.min(linkData.length, Math.floor(container.clientWidth / (donutSize + 30)));
    const rows = Math.ceil(linkData.length / cols);
    const W = container.clientWidth;
    const H = rows * (donutSize + 40) + 20;

    const svg = d3.select(container).append("svg")
      .attr("viewBox", `0 0 ${W} ${H}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const pie = d3.pie().value(d => d.value).sort(null);
    const arc = d3.arc().innerRadius(28).outerRadius(40);

    linkData.forEach((link, i) => {
      const col = i % cols;
      const row = Math.floor(i / cols);
      const cx = (W / cols) * (col + 0.5);
      const cy = 50 + row * (donutSize + 40);

      const g = svg.append("g").attr("transform", `translate(${cx},${cy})`);

      const data = [
        { label: "Flow", value: link.flow, color: "#4895ef" },
        { label: "Guard", value: link.guard, color: "#f9a825" },
        { label: "BE", value: link.be, color: "#0d1a30" }
      ];

      const arcs = g.selectAll(".util-arc")
        .data(pie(data)).enter().append("path")
        .attr("class", "util-arc")
        .attr("fill", d => d.data.color)
        .attr("stroke", "var(--bg)")
        .attr("stroke-width", 1.5)
        .attr("opacity", d => d.data.label === "BE" ? 0.3 : 0.85)
        .on("mouseover", (evt, d) => {
          showTip(evt, `
            <div class="tt-title">${link.from} → ${link.to}</div>
            <div class="tt-row"><span class="tt-k">${d.data.label}</span><span class="tt-v">${d.data.value.toFixed(1)} us</span></div>
          `);
        })
        .on("mouseout", hideTip);

      // Animate arcs
      arcs.transition().duration(800).delay(i * 100)
        .attrTween("d", function(d) {
          const interp = d3.interpolate({ startAngle: 0, endAngle: 0 }, d);
          return t => arc(interp(t));
        });

      // Center text
      g.append("text").attr("class", "util-label")
        .attr("dy", 1)
        .text(link.util + "%")
        .attr("opacity", 0)
        .transition().delay(800 + i * 100).duration(300).attr("opacity", 1);

      // Name
      g.append("text").attr("class", "util-name")
        .attr("y", 52)
        .text(`${link.from} → ${link.to}`);
    });
  }

  /* ═══════════════════════════════════════════════
     PACKET TABLE
  ═══════════════════════════════════════════════ */
  function renderTable(result) {
    const tbody = document.getElementById("pktTableBody");
    tbody.innerHTML = result.packetRows.map(p => {
      const ft = flowType(p.flow_id);
      const badgeColor = FLOW_COLORS_HEX[ft] || "#7b61ff";
      const statusCls = p.status === "OK" ? "ok" : p.status === "MISS" ? "miss" : "be";
      return `<tr>
        <td>${p.packet_id.replace("f_", "")}</td>
        <td><span class="flow-badge" style="background:${badgeColor}20;color:${badgeColor};border:1px solid ${badgeColor}40">${ft}</span></td>
        <td>R${p.selected_route}</td>
        <td>${p.release_us}</td>
        <td>${p.end_us}</td>
        <td>${p.e2e_delay_us}</td>
        <td>${p.deadline_abs_us ?? "-"}</td>
        <td>${p.slack_us != null ? p.slack_us : "-"}</td>
        <td class="${statusCls}">${p.status}</td>
      </tr>`;
    }).join("");
  }

  /* ═══════════════════════════════════════════════
     SOLVER WORKER (Client-side GLPK/WASM)
  ═══════════════════════════════════════════════ */
  let solverWorker = null;
  let solverReady = false;
  let solveCallbacks = {};
  let solveIdCounter = 0;

  function initSolverWorker() {
    try {
      solverWorker = new Worker('solver-worker.js');
      solverWorker.onmessage = function(evt) {
        const msg = evt.data;
        if (msg.type === 'ready') {
          solverReady = true;
          console.log('GLPK/WASM solver ready, version:', msg.version);
          const badge = document.querySelector('.badge');
          if (badge) badge.innerHTML += ' &bull; <span style="color:var(--green)">GLPK v' + msg.version + ' (WASM)</span>';
        } else if (msg.type === 'error') {
          console.warn('Solver worker error:', msg.error);
        } else if (msg.type === 'result') {
          const cb = solveCallbacks[msg.id];
          if (cb) {
            delete solveCallbacks[msg.id];
            cb(msg);
          }
        }
      };
      solverWorker.onerror = function(e) {
        console.warn('Worker error:', e.message);
      };
    } catch (e) {
      console.warn('Worker init failed:', e);
    }
  }

  function solveWithWorker(model) {
    return new Promise((resolve, reject) => {
      if (!solverWorker || !solverReady) {
        reject(new Error('Solver not ready yet. Wait for GLPK/WASM to load.'));
        return;
      }
      const id = ++solveIdCounter;
      solveCallbacks[id] = function(msg) {
        if (msg.ok) resolve(msg.result);
        else reject(new Error(msg.error));
      };
      solverWorker.postMessage({ type: 'solve', id: id, model: model });
    });
  }

  initSolverWorker();

  /* ═══════════════════════════════════════════════
     INPUT / SOLVE
  ═══════════════════════════════════════════════ */
  const inputEl = document.getElementById("input");
  const statusEl = document.getElementById("status");

  function loadSample() {
    inputEl.value = JSON.stringify(SAMPLE, null, 2);
    statusEl.textContent = "Sample loaded";
    statusEl.className = "status-ok";
  }

  async function runSolve() {
    const btn = document.getElementById("solveBtn");
    try {
      const model = JSON.parse(inputEl.value);
      btn.disabled = true;
      statusEl.className = "";

      // 1) Try client-side GLPK/WASM solver (Web Worker)
      if (solverReady) {
        statusEl.innerHTML = 'Solving ILP in browser (GLPK/WASM)... <span style="color:var(--text3)">may take a few seconds</span>';
        try {
          const result = await solveWithWorker(model);
          currentModel = model;
          currentResult = result;
          renderAll();
          statusEl.textContent = `Solved in ${result.runtime_ms}ms | ${result.stats.variables} vars, ${result.stats.binaries} binaries, ${result.stats.constraints} constraints`;
          statusEl.className = "status-ok";
          btn.disabled = false;
          return;
        } catch (workerErr) {
          statusEl.textContent = "Solver error: " + workerErr.message;
          statusEl.className = "status-err";
          btn.disabled = false;
          return;
        }
      }

      // 2) Fallback: try server API
      statusEl.textContent = "WASM solver not loaded. Trying server API...";
      try {
        const res = await fetch("/api/solve", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(model)
        });
        const data = await res.json();
        if (data.ok) {
          currentModel = model;
          currentResult = data.result;
          renderAll();
          statusEl.textContent = `Solved via server in ${data.result.runtime_ms}ms | ${data.result.stats.variables} vars`;
          statusEl.className = "status-ok";
          btn.disabled = false;
          return;
        }
        throw new Error(data.error);
      } catch (fetchErr) {
        statusEl.textContent = "Solver not available. Please wait for WASM to load, or run server.js locally.";
        statusEl.className = "status-err";
      }
    } catch (e) {
      statusEl.textContent = "JSON parse error: " + e.message;
      statusEl.className = "status-err";
    }
    btn.disabled = false;
  }

  /* ═══════════════════════════════════════════════
     RENDER ALL
  ═══════════════════════════════════════════════ */
  function renderAll() {
    renderMetrics(currentModel, currentResult);
    renderTopology(currentModel, currentResult);
    renderGCL(currentModel, currentResult);
    renderDelayChart(currentModel, currentResult);
    renderUtilization(currentModel, currentResult);
    renderTable(currentResult);
    document.getElementById("jsonOut").textContent = JSON.stringify(currentResult.gcl, null, 2);
  }

  // Init
  inputEl.value = JSON.stringify(SAMPLE, null, 2);
  renderAll();

  // Responsive re-render
  let resizeTimer;
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(renderAll, 300);
  });
  </script>
</body>
</html>
