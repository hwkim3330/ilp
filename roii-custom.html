<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>TSN/GCL Custom Playground</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <style>
    /* ═══════════════════════════════════════════════
       CSS Architecture — Full-Viewport Canvas-First
       ═══════════════════════════════════════════════ */
    :root {
      --bg: #f8f9fa; --bg2: #f0f2f5;
      --card: #ffffff; --card-hi: #f8fafc;
      --border: rgba(59,130,246,0.2); --border-hi: rgba(59,130,246,0.4);
      --text: #1e293b; --text2: #475569; --text3: #64748b;
      --cyan: #0891b2; --blue: #3B82F6; --purple: #7c3aed;
      --orange: #d97706; --red: #dc2626; --green: #059669; --pink: #db2777;
      --flow-ctrl: #3B82F6; --flow-sensor: #059669; --flow-video: #db2777;
      --guard: #d97706; --be: #e2e8f0;
      --radius: 14px;
      --drawer-collapsed: 48px;
      --drawer-half: 40vh;
      --drawer-full: 85vh;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f0f2f5;
      color: var(--text);
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    /* Dot-grid background */
    .bg-dots {
      position: fixed; inset: 0; z-index: 0; pointer-events: none;
      background-image:
        radial-gradient(circle at 1px 1px, rgba(59,130,246,0.08) 1px, transparent 0);
      background-size: 24px 24px;
    }

    /* ── Full-Viewport Topology SVG ── */
    #topoSvg {
      position: fixed; inset: 0; z-index: 1;
      width: 100vw; height: 100vh;
      touch-action: none;
      cursor: grab;
    }
    #topoSvg:active { cursor: grabbing; }

    /* ── Glassmorphism base ── */
    .glass {
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      background: rgba(255,255,255,0.88);
      border: 1px solid rgba(59,130,246,0.15);
      box-shadow: 0 4px 24px rgba(0,0,0,0.08);
    }

    /* ── Top Bar ── */
    .top-bar {
      position: fixed; top: 0; left: 0; right: 0; z-index: 50;
      display: flex; align-items: center; gap: 8px;
      padding: 8px 16px; height: 48px;
      background: rgba(255,255,255,0.82);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid rgba(59,130,246,0.1);
    }
    .top-bar .logo {
      font-size: 0.9rem; font-weight: 800;
      background: linear-gradient(135deg, #3B82F6 0%, #06B6D4 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
      white-space: nowrap;
    }
    .preset-pills {
      display: flex; gap: 4px; margin-left: 8px;
    }
    .preset-pill {
      padding: 4px 12px; border-radius: 20px; font-size: 0.72rem;
      font-weight: 600; cursor: pointer;
      border: 1px solid rgba(59,130,246,0.2);
      background: rgba(255,255,255,0.6); color: var(--text2);
      transition: all 0.15s; white-space: nowrap;
    }
    .preset-pill.active {
      background: var(--blue); color: #fff; border-color: var(--blue);
    }
    .preset-pill:hover:not(.active) {
      border-color: var(--blue); color: var(--blue);
    }
    .top-spacer { flex: 1; }
    .top-btn {
      padding: 5px 14px; border-radius: 8px; font-size: 0.75rem;
      font-weight: 700; cursor: pointer; border: 1px solid rgba(59,130,246,0.2);
      background: rgba(255,255,255,0.6); color: var(--text2);
      transition: all 0.15s; display: flex; align-items: center; gap: 5px;
    }
    .top-btn:hover { border-color: var(--blue); color: var(--blue); }
    .top-btn.primary { background: var(--blue); color: #fff; border-color: var(--blue); }
    .top-btn.primary:hover { filter: brightness(1.1); }
    .solve-dot {
      width: 6px; height: 6px; border-radius: 50%;
      background: var(--green); display: inline-block;
    }
    .solve-dot.solving { background: var(--orange); animation: pulse-dot 0.6s infinite; }
    @keyframes pulse-dot { 0%,100% { opacity:1; } 50% { opacity:0.3; } }

    .engine-badge {
      font-size: 0.65rem; font-weight: 700; padding: 2px 8px;
      border-radius: 10px; white-space: nowrap;
    }
    .engine-badge.loading { background: rgba(217,119,6,0.1); color: var(--orange); border: 1px solid rgba(217,119,6,0.2); }
    .engine-badge.ready { background: rgba(5,150,105,0.1); color: var(--green); border: 1px solid rgba(5,150,105,0.2); }
    .spinner {
      display: inline-block; width: 10px; height: 10px;
      border: 2px solid rgba(217,119,6,0.2); border-top-color: var(--orange);
      border-radius: 50%; animation: spin 0.6s linear infinite; margin-right: 4px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .kbd-hint {
      font-size: 0.65rem; color: var(--text3); padding: 2px 6px;
      border: 1px solid rgba(0,0,0,0.1); border-radius: 4px;
      background: rgba(0,0,0,0.03); font-family: monospace;
    }

    /* ── Metrics Ribbon ── */
    .metrics-ribbon {
      position: fixed; bottom: 56px; left: 12px; z-index: 40;
      display: flex; gap: 4px; flex-wrap: wrap;
      max-width: calc(100vw - 370px);
      transition: bottom 0.3s ease;
    }
    .metrics-ribbon.drawer-half { bottom: calc(40vh + 8px); }
    .metrics-ribbon.drawer-full { bottom: calc(85vh + 8px); }
    .metric-pill {
      padding: 4px 10px; border-radius: 8px; font-size: 0.7rem;
      font-weight: 600; white-space: nowrap; cursor: default;
      background: rgba(255,255,255,0.88); border: 1px solid rgba(59,130,246,0.12);
      backdrop-filter: blur(10px); color: var(--text2);
      transition: all 0.15s;
    }
    .metric-pill.ok { color: var(--green); border-color: rgba(5,150,105,0.25); }
    .metric-pill.warn { color: var(--orange); border-color: rgba(217,119,6,0.25); }
    .metric-pill.miss { color: var(--red); border-color: rgba(220,38,38,0.25); }

    /* ── Three.js PiP Window ── */
    .pip {
      position: fixed; z-index: 45;
      border-radius: 12px; overflow: hidden;
      transition: all 0.3s ease;
      box-shadow: 0 8px 32px rgba(0,0,0,0.15);
      border: 1px solid rgba(59,130,246,0.2);
    }
    .pip.normal {
      width: 340px; height: 260px;
      right: 16px; bottom: 64px;
    }
    .pip.expanded {
      width: 50vw; height: 50vh;
      right: 16px; bottom: 64px;
    }
    .pip.minimized {
      width: 48px; height: 48px;
      right: 16px; bottom: 64px;
      border-radius: 50%; cursor: pointer;
    }
    .pip-titlebar {
      display: flex; align-items: center; gap: 6px;
      padding: 4px 8px; height: 28px;
      background: rgba(255,255,255,0.92);
      border-bottom: 1px solid rgba(59,130,246,0.1);
      cursor: grab; font-size: 0.7rem; font-weight: 600; color: var(--text2);
      user-select: none;
    }
    .pip-titlebar:active { cursor: grabbing; }
    .pip.minimized .pip-titlebar { display: none; }
    .pip-btn {
      width: 18px; height: 18px; border-radius: 50%;
      border: none; cursor: pointer; font-size: 0.6rem;
      display: flex; align-items: center; justify-content: center;
      background: rgba(59,130,246,0.1); color: var(--blue);
      transition: all 0.15s;
    }
    .pip-btn:hover { background: rgba(59,130,246,0.2); }
    .pip-canvas-wrap {
      width: 100%; height: calc(100% - 28px);
      background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
    }
    .pip.minimized .pip-canvas-wrap {
      height: 100%;
      display: flex; align-items: center; justify-content: center;
      background: var(--blue); color: #fff; font-size: 1.2rem; font-weight: 800;
    }
    .pip-resize-handle {
      position: absolute; bottom: 0; right: 0;
      width: 16px; height: 16px; cursor: nwse-resize;
      background: linear-gradient(135deg, transparent 50%, rgba(59,130,246,0.3) 50%);
      border-radius: 0 0 12px 0;
    }
    .pip.minimized .pip-resize-handle { display: none; }

    /* ── Command Palette ── */
    .cmd-overlay {
      position: fixed; inset: 0; z-index: 100;
      background: rgba(0,0,0,0.25);
      display: none; align-items: flex-start; justify-content: center;
      padding-top: 15vh;
    }
    .cmd-overlay.open { display: flex; }
    .cmd-palette {
      width: 520px; max-width: 90vw; max-height: 60vh;
      border-radius: 16px; overflow: hidden;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(24px);
      border: 1px solid rgba(59,130,246,0.2);
      box-shadow: 0 12px 48px rgba(0,0,0,0.15);
      display: flex; flex-direction: column;
    }
    .cmd-search {
      padding: 14px 18px; border: none; outline: none;
      font-size: 0.95rem; background: transparent;
      color: var(--text); border-bottom: 1px solid rgba(59,130,246,0.1);
      width: 100%;
    }
    .cmd-search::placeholder { color: var(--text3); }
    .cmd-list {
      overflow-y: auto; max-height: calc(60vh - 52px);
      padding: 6px;
    }
    .cmd-list::-webkit-scrollbar { width: 4px; }
    .cmd-list::-webkit-scrollbar-thumb { background: rgba(59,130,246,0.15); border-radius: 3px; }
    .cmd-item {
      display: flex; align-items: center; gap: 10px;
      padding: 8px 12px; border-radius: 8px; cursor: pointer;
      font-size: 0.82rem; color: var(--text);
      transition: background 0.1s;
    }
    .cmd-item:hover, .cmd-item.active { background: rgba(59,130,246,0.08); }
    .cmd-item .cmd-icon { width: 20px; text-align: center; font-size: 0.9rem; flex-shrink: 0; }
    .cmd-item .cmd-label { flex: 1; font-weight: 500; }
    .cmd-item .cmd-hint { font-size: 0.7rem; color: var(--text3); }
    .cmd-group-title {
      font-size: 0.68rem; font-weight: 700; color: var(--text3);
      text-transform: uppercase; letter-spacing: 0.05em;
      padding: 8px 12px 4px;
    }
    .cmd-inline-form {
      padding: 12px 16px; border-top: 1px solid rgba(59,130,246,0.1);
      background: rgba(248,250,252,0.5);
    }
    .cmd-inline-form label { font-size: 0.75rem; font-weight: 600; color: var(--text2); display: block; margin-bottom: 4px; }
    .cmd-inline-form input, .cmd-inline-form select {
      width: 100%; padding: 6px 10px; font-size: 0.82rem;
      border: 1px solid rgba(59,130,246,0.2); border-radius: 6px;
      background: #fff; color: var(--text); margin-bottom: 8px;
    }
    .cmd-inline-form input[type="range"] { padding: 0; }
    .cmd-inline-form .cmd-form-row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
    .cmd-inline-form .cmd-form-val { font-size: 0.78rem; font-weight: 700; color: var(--blue); min-width: 60px; text-align: right; }

    /* ── Bottom Drawer ── */
    .drawer {
      position: fixed; bottom: 0; left: 0; right: 0; z-index: 35;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border-top: 1px solid rgba(59,130,246,0.15);
      box-shadow: 0 -4px 24px rgba(0,0,0,0.06);
      transition: height 0.3s ease;
      display: flex; flex-direction: column;
    }
    .drawer.collapsed { height: var(--drawer-collapsed); }
    .drawer.half { height: var(--drawer-half); }
    .drawer.full { height: var(--drawer-full); }
    .drawer-handle {
      display: flex; align-items: center; justify-content: center;
      height: 20px; cursor: ns-resize; flex-shrink: 0;
      touch-action: none;
    }
    .drawer-handle-bar {
      width: 40px; height: 4px; border-radius: 2px;
      background: rgba(59,130,246,0.25);
    }
    .drawer-tabs {
      display: flex; gap: 2px; padding: 0 12px; flex-shrink: 0;
      border-bottom: 1px solid rgba(59,130,246,0.1);
      overflow-x: auto; -webkit-overflow-scrolling: touch;
    }
    .drawer-tabs::-webkit-scrollbar { display: none; }
    .drawer-tab {
      padding: 6px 14px; font-size: 0.72rem; font-weight: 600;
      color: var(--text3); cursor: pointer; white-space: nowrap;
      border-bottom: 2px solid transparent;
      transition: all 0.15s;
    }
    .drawer-tab.active { color: var(--blue); border-bottom-color: var(--blue); }
    .drawer-tab:hover:not(.active) { color: var(--text2); }
    .drawer-content {
      flex: 1; overflow: auto; padding: 12px 16px;
    }
    .drawer-content::-webkit-scrollbar { width: 5px; }
    .drawer-content::-webkit-scrollbar-thumb { background: rgba(59,130,246,0.15); border-radius: 3px; }
    .drawer-panel { display: none; }
    .drawer-panel.active { display: block; }

    /* Drawer panel containers */
    .drawer-panel .svg-container { background: transparent; }
    .drawer-panel .pkt-table { width: 100%; border-collapse: collapse; font-size: 0.78rem; }
    .drawer-panel .pkt-table th { border-bottom: 1px solid rgba(59,130,246,0.15); color: var(--text3); text-align: left; padding: 6px 8px; font-weight: 600; }
    .drawer-panel .pkt-table td { border-bottom: 1px solid rgba(59,130,246,0.08); padding: 6px 8px; }
    .drawer-panel .pkt-table tr:hover td { background: rgba(59,130,246,0.04); }
    .drawer-panel pre { background: rgba(248,250,252,0.9); border: 1px solid rgba(59,130,246,0.15); color: var(--text2); padding: 12px; border-radius: 8px; font-size: 0.75rem; overflow: auto; max-height: 100%; }
    .drawer-panel .gcl-switch-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }

    /* Switch GCL cards in drawer */
    .gcl-switch-card {
      background: rgba(255,255,255,0.7);
      border: 1px solid rgba(59,130,246,0.12);
      border-radius: 10px; padding: 12px 14px;
    }
    .gcl-switch-card .sw-header {
      display: flex; align-items: center; gap: 8px;
      margin-bottom: 10px; padding-bottom: 6px;
      border-bottom: 1px solid rgba(59,130,246,0.1);
    }
    .sw-dot { width: 10px; height: 10px; border-radius: 3px; flex-shrink: 0; }
    .sw-name { font-weight: 700; font-size: 0.85rem; color: var(--text); }
    .sw-chip { font-size: 0.65rem; padding: 2px 6px; border-radius: 6px; background: rgba(59,130,246,0.1); color: var(--blue); font-weight: 600; }
    .sw-stats { margin-left: auto; font-size: 0.7rem; color: var(--text3); }
    .link-label-dir { font-size: 0.75rem; font-weight: 600; color: var(--text2); margin-bottom: 4px; }

    /* ── Node/Link Popovers ── */
    .popover {
      position: absolute; z-index: 60;
      min-width: 200px; max-width: 320px;
      border-radius: 12px; padding: 12px 16px;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(59,130,246,0.2);
      box-shadow: 0 8px 32px rgba(0,0,0,0.12);
      font-size: 0.78rem;
    }
    .popover-title { font-weight: 700; font-size: 0.85rem; color: var(--text); margin-bottom: 8px; }
    .popover-row { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
    .popover-row label { font-size: 0.72rem; font-weight: 600; color: var(--text3); min-width: 60px; }
    .popover-row input, .popover-row select {
      flex: 1; padding: 4px 8px; font-size: 0.75rem;
      border: 1px solid rgba(59,130,246,0.2); border-radius: 6px; background: #fff;
    }
    .popover-actions { display: flex; gap: 6px; margin-top: 8px; }
    .popover-btn {
      padding: 4px 12px; border-radius: 6px; font-size: 0.72rem;
      font-weight: 700; cursor: pointer; border: 1px solid rgba(59,130,246,0.2);
      background: #fff; color: var(--blue); transition: all 0.15s;
    }
    .popover-btn:hover { background: rgba(59,130,246,0.08); }
    .popover-btn.primary { background: var(--blue); color: #fff; border-color: var(--blue); }
    .popover-btn.danger { color: var(--red); border-color: rgba(220,38,38,0.2); }
    .popover-btn.danger:hover { background: rgba(220,38,38,0.08); }

    /* Link GCL popover mini gantt */
    .link-popover-gantt { margin: 8px 0; height: 24px; background: rgba(0,0,0,0.03); border-radius: 6px; overflow: hidden; position: relative; }
    .link-popover-util { font-size: 0.82rem; font-weight: 700; color: var(--blue); }
    .link-popover-entries { font-size: 0.7rem; color: var(--text3); margin-top: 4px; }

    /* ── Solve Wave Animation ── */
    .solve-wave {
      pointer-events: none;
      fill: none; stroke: var(--blue); stroke-width: 2;
      opacity: 0.6;
    }

    /* ── Toast Notifications ── */
    .toast-container {
      position: fixed; bottom: 56px; right: 16px; z-index: 200;
      display: flex; flex-direction: column-reverse; gap: 8px;
      pointer-events: none;
    }
    .toast {
      padding: 8px 16px; border-radius: 10px; font-size: 0.78rem;
      font-weight: 600; backdrop-filter: blur(20px);
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      animation: toastIn 0.3s ease; pointer-events: auto;
    }
    .toast.success { background: rgba(5,150,105,0.12); color: var(--green); border: 1px solid rgba(5,150,105,0.25); }
    .toast.error { background: rgba(220,38,38,0.12); color: var(--red); border: 1px solid rgba(220,38,38,0.25); }
    .toast.info { background: rgba(59,130,246,0.12); color: var(--blue); border: 1px solid rgba(59,130,246,0.25); }
    .toast.fadeout { animation: toastOut 0.3s ease forwards; }
    @keyframes toastIn { from { opacity:0; transform:translateY(20px); } to { opacity:1; transform:translateY(0); } }
    @keyframes toastOut { from { opacity:1; } to { opacity:0; transform:translateY(10px); } }

    /* ── Tooltip ── */
    .tooltip {
      position: fixed; z-index: 150; pointer-events: none;
      padding: 10px 14px; border-radius: 10px;
      background: rgba(255,255,255,0.97);
      border: 1px solid rgba(59,130,246,0.25);
      color: var(--text); box-shadow: 0 8px 30px rgba(0,0,0,0.12);
      font-size: 0.78rem; max-width: 300px;
      opacity: 0; transition: opacity 0.15s;
    }
    .tooltip.show { opacity: 1; }
    .tooltip .tt-title { font-weight: 700; color: var(--blue); margin-bottom: 4px; }
    .tooltip .tt-row { display: flex; justify-content: space-between; gap: 12px; }
    .tooltip .tt-k { color: var(--text3); }
    .tooltip .tt-v { font-weight: 600; }

    /* ── D3 Topology Styles ── */
    .topo-node-circle { cursor: pointer; transition: r 0.15s; }
    .topo-node-circle:hover { filter: brightness(1.1); }
    .topo-node-label {
      font-size: 10px; font-weight: 700; text-anchor: middle;
      fill: var(--text); pointer-events: none;
    }
    .topo-node-type {
      font-size: 7.5px; font-weight: 600; text-anchor: middle;
      fill: var(--text3); pointer-events: none;
    }
    .topo-link-line {
      stroke: rgba(59,130,246,0.2); stroke-width: 2;
      transition: stroke 0.3s, stroke-width 0.3s;
    }
    .topo-link-hit {
      stroke: transparent; stroke-width: 14; cursor: pointer;
      fill: none;
    }
    .flow-particle {
      pointer-events: none;
    }
    .rubber-band-line {
      stroke: var(--blue); stroke-width: 2; stroke-dasharray: 6,4;
      pointer-events: none; fill: none;
    }
    .node-pulse-ring {
      fill: none; stroke-width: 2; pointer-events: none;
      animation: pulse-ring 1.5s infinite;
    }
    @keyframes pulse-ring {
      0% { r: 22; opacity: 0.5; }
      100% { r: 36; opacity: 0; }
    }

    /* animated dashes on high-util links */
    .link-animated-dash {
      animation: dash-flow 1s linear infinite;
    }
    @keyframes dash-flow {
      to { stroke-dashoffset: -16; }
    }

    /* ── Responsive ── */
    @media (max-width: 900px) {
      .pip.normal { width: 200px; height: 150px; right: 8px; bottom: 56px; }
      .pip.expanded { width: 80vw; height: 40vh; right: 8px; bottom: 56px; }
      .metrics-ribbon { max-width: calc(100vw - 220px); left: 8px; }
      .preset-pills { display: none; }
      .top-bar .logo { font-size: 0.78rem; }
      .drawer-panel .gcl-switch-grid { grid-template-columns: 1fr; }
      .cmd-palette { max-width: 95vw; }
      .kbd-hint { display: none; }
    }

    /* Flow badge */
    .flow-badge {
      font-size: 0.7rem; font-weight: 600; padding: 1px 8px;
      border-radius: 8px; display: inline-block;
    }
    .ok { color: var(--green); font-weight: 700; }
    .miss { color: var(--red); font-weight: 700; }
    .be { color: var(--text3); }

    /* Legend in drawer */
    .legend { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; }
    .legend-item { display: flex; align-items: center; gap: 5px; font-size: 0.72rem; color: var(--text2); }
    .legend-dot { width: 10px; height: 10px; border-radius: 3px; flex-shrink: 0; }

    /* ── Floating Flow Sidebar (on topology) ── */
    .flow-sidebar {
      position: fixed; left: 12px; top: 56px; z-index: 40;
      width: 200px; max-height: calc(100vh - 120px);
      overflow-y: auto; padding: 8px;
      border-radius: 12px; font-size: 0.72rem;
      transition: opacity 0.2s;
    }
    .flow-sidebar::-webkit-scrollbar { width: 3px; }
    .flow-sidebar::-webkit-scrollbar-thumb { background: rgba(59,130,246,0.15); border-radius: 3px; }
    .flow-sidebar .fs-title {
      font-size: 0.68rem; font-weight: 700; color: var(--text3);
      text-transform: uppercase; letter-spacing: 0.04em;
      margin-bottom: 6px; display: flex; align-items: center; gap: 4px;
    }
    .flow-sidebar .fs-flow {
      display: flex; align-items: center; gap: 6px;
      padding: 5px 8px; border-radius: 8px; cursor: pointer;
      transition: all 0.12s; margin-bottom: 2px;
      border: 1px solid transparent;
    }
    .flow-sidebar .fs-flow:hover { background: rgba(59,130,246,0.06); }
    .flow-sidebar .fs-flow.active {
      background: rgba(59,130,246,0.08);
      border-color: rgba(59,130,246,0.25);
    }
    .flow-sidebar .fs-dot {
      width: 8px; height: 8px; border-radius: 3px; flex-shrink: 0;
    }
    .flow-sidebar .fs-name {
      flex: 1; font-weight: 600; color: var(--text);
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .flow-sidebar .fs-info {
      font-size: 0.62rem; color: var(--text3); white-space: nowrap;
    }
    .flow-sidebar .fs-add {
      display: flex; align-items: center; justify-content: center;
      padding: 4px; border-radius: 6px; margin-top: 4px;
      border: 1px dashed rgba(59,130,246,0.25); background: transparent;
      color: var(--blue); font-size: 0.68rem; font-weight: 600;
      cursor: pointer; width: 100%;
    }
    .flow-sidebar .fs-add:hover { background: rgba(59,130,246,0.06); }
    @media (max-width: 900px) {
      .flow-sidebar { width: 160px; left: 6px; top: 52px; }
    }

    /* ── Flow Path Overlays on Topology ── */
    .flow-path-line {
      fill: none; stroke-width: 3; stroke-linecap: round; stroke-linejoin: round;
      opacity: 0.35; cursor: pointer; pointer-events: visibleStroke;
      transition: opacity 0.15s, stroke-width 0.15s;
    }
    .flow-path-line:hover { opacity: 0.7; stroke-width: 5; }
    .flow-path-line.active { opacity: 0.85; stroke-width: 6; stroke-dasharray: none; }
    .flow-path-line.dimmed { opacity: 0.06; stroke-width: 2; pointer-events: none; }

    /* ── Flow Edit Popover (on canvas) ── */
    .flow-popover {
      position: absolute; z-index: 60; width: 260px;
      border-radius: 12px; padding: 12px 14px;
      background: rgba(255,255,255,0.96);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(59,130,246,0.2);
      box-shadow: 0 8px 32px rgba(0,0,0,0.12);
      font-size: 0.78rem; pointer-events: auto;
    }
    .flow-popover .fp-header {
      display: flex; align-items: center; gap: 6px;
      margin-bottom: 8px; padding-bottom: 6px;
      border-bottom: 1px solid rgba(59,130,246,0.1);
    }
    .flow-popover .fp-tag { width: 12px; height: 12px; border-radius: 4px; flex-shrink: 0; }
    .flow-popover .fp-id { font-weight: 700; font-size: 0.85rem; flex: 1; }
    .flow-popover .fp-grid {
      display: grid; grid-template-columns: 70px 1fr; gap: 4px 8px;
      align-items: center;
    }
    .flow-popover .fp-grid label { font-size: 0.7rem; font-weight: 600; color: var(--text3); }
    .flow-popover .fp-grid select, .flow-popover .fp-grid input {
      width: 100%; padding: 3px 6px; font-size: 0.72rem;
      border: 1px solid rgba(59,130,246,0.15); border-radius: 5px;
      background: #fff; color: var(--text);
    }
    .flow-popover .fp-computed {
      margin-top: 6px; padding-top: 5px; border-top: 1px dashed rgba(59,130,246,0.1);
      font-size: 0.68rem; color: var(--text3); font-family: monospace;
    }

    /* ── Flow Editor Cards ── */
    .flow-editor-list { display: flex; flex-direction: column; gap: 8px; }
    .flow-card {
      background: rgba(255,255,255,0.7); border: 1px solid rgba(59,130,246,0.12);
      border-radius: 10px; padding: 10px 12px; cursor: pointer;
      transition: all 0.15s; position: relative;
    }
    .flow-card:hover { border-color: rgba(59,130,246,0.3); }
    .flow-card.selected { border-color: var(--blue); box-shadow: 0 0 0 2px rgba(59,130,246,0.15); }
    .flow-card-header {
      display: flex; align-items: center; gap: 6px; margin-bottom: 6px;
      padding-bottom: 6px; border-bottom: 1px solid rgba(59,130,246,0.08);
    }
    .flow-card-tag {
      width: 10px; height: 10px; border-radius: 3px; flex-shrink: 0;
    }
    .flow-card-id { font-weight: 700; font-size: 0.78rem; color: var(--text); flex: 1; }
    .flow-card-del {
      width: 20px; height: 20px; border-radius: 50%; border: none;
      background: rgba(220,38,38,0.08); color: var(--red); cursor: pointer;
      font-size: 0.75rem; display: flex; align-items: center; justify-content: center;
      transition: all 0.15s;
    }
    .flow-card-del:hover { background: rgba(220,38,38,0.2); }
    .flow-card-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 4px 10px;
    }
    .flow-card-grid label {
      font-size: 0.68rem; font-weight: 600; color: var(--text3);
      display: flex; align-items: center;
    }
    .flow-card-grid select, .flow-card-grid input {
      width: 100%; padding: 3px 6px; font-size: 0.72rem;
      border: 1px solid rgba(59,130,246,0.15); border-radius: 5px;
      background: #fff; color: var(--text);
    }
    .flow-card-grid input[type="number"] { -moz-appearance: textfield; }
    .flow-card-grid input::-webkit-outer-spin-button,
    .flow-card-grid input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    .flow-computed {
      margin-top: 6px; padding-top: 5px; border-top: 1px dashed rgba(59,130,246,0.1);
      font-size: 0.68rem; color: var(--text3); font-family: monospace;
    }
    .flow-add-btn {
      width: 100%; padding: 8px; border-radius: 8px; border: 1px dashed rgba(59,130,246,0.25);
      background: transparent; color: var(--blue); font-size: 0.78rem; font-weight: 600;
      cursor: pointer; transition: all 0.15s;
    }
    .flow-add-btn:hover { background: rgba(59,130,246,0.06); border-color: var(--blue); }

    /* ── Model Editor ── */
    .model-section {
      margin-bottom: 10px; border: 1px solid rgba(59,130,246,0.1);
      border-radius: 10px; overflow: hidden;
    }
    .model-section-header {
      display: flex; align-items: center; gap: 6px; padding: 8px 12px;
      background: rgba(248,250,252,0.8); cursor: pointer; user-select: none;
      font-size: 0.78rem; font-weight: 700; color: var(--text);
    }
    .model-section-header .chevron {
      font-size: 0.65rem; color: var(--text3); transition: transform 0.15s;
    }
    .model-section.collapsed .model-section-body { display: none; }
    .model-section.collapsed .chevron { transform: rotate(-90deg); }
    .model-section-body { padding: 8px 12px; }
    .editor-item {
      display: flex; align-items: center; gap: 6px; margin-bottom: 5px;
      font-size: 0.72rem;
    }
    .editor-item select, .editor-item input {
      padding: 3px 6px; font-size: 0.72rem;
      border: 1px solid rgba(59,130,246,0.15); border-radius: 5px;
      background: #fff; color: var(--text);
    }
    .editor-item input { width: 70px; }
    .editor-item select { width: 90px; }
    .editor-item .ed-dot {
      width: 8px; height: 8px; border-radius: 2px; flex-shrink: 0;
    }
    .editor-item .ed-del {
      width: 18px; height: 18px; border-radius: 50%; border: none;
      background: rgba(220,38,38,0.06); color: var(--red); cursor: pointer;
      font-size: 0.68rem; display: flex; align-items: center; justify-content: center;
      flex-shrink: 0;
    }
    .editor-item .ed-del:hover { background: rgba(220,38,38,0.15); }
    .editor-add-btn {
      padding: 5px 12px; border-radius: 6px; border: 1px dashed rgba(59,130,246,0.2);
      background: transparent; color: var(--blue); font-size: 0.7rem; font-weight: 600;
      cursor: pointer; margin-top: 4px;
    }
    .editor-add-btn:hover { background: rgba(59,130,246,0.06); }

    /* ── Radio Pills & Toggle ── */
    .radio-group { display: flex; gap: 2px; }
    .radio-pill {
      padding: 4px 12px; border-radius: 8px; font-size: 0.72rem; font-weight: 600;
      cursor: pointer; border: 1px solid rgba(59,130,246,0.15);
      background: #fff; color: var(--text2); transition: all 0.15s;
    }
    .radio-pill.active { background: var(--blue); color: #fff; border-color: var(--blue); }
    .toggle-row {
      display: flex; align-items: center; gap: 8px; margin-bottom: 8px;
      font-size: 0.75rem; font-weight: 600; color: var(--text2);
    }
    .toggle-switch {
      position: relative; width: 36px; height: 20px; cursor: pointer;
    }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .toggle-track {
      position: absolute; inset: 0; border-radius: 10px;
      background: rgba(0,0,0,0.1); transition: background 0.2s;
    }
    .toggle-switch input:checked + .toggle-track { background: var(--blue); }
    .toggle-track::after {
      content: ''; position: absolute; width: 16px; height: 16px;
      left: 2px; top: 2px; border-radius: 50%;
      background: #fff; transition: transform 0.2s; box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    .toggle-switch input:checked + .toggle-track::after { transform: translateX(16px); }
    .solver-actions { display: flex; gap: 6px; margin-top: 8px; }
    .slider-row {
      display: flex; align-items: center; gap: 8px; margin-bottom: 6px;
      font-size: 0.72rem; color: var(--text2);
    }
    .slider-row label { min-width: 80px; font-weight: 600; }
    .slider-row input[type="range"] { flex: 1; }
    .slider-row .slider-val { min-width: 50px; text-align: right; font-weight: 700; color: var(--blue); }

    /* ── Flow Path Highlight on Topology ── */
    .topo-link-line.flow-highlighted { stroke-width: 6 !important; opacity: 1 !important; }
    .topo-link-line.dimmed { opacity: 0.12 !important; }
    .topo-node-g.dimmed { opacity: 0.25; }
    .topo-link-hit.dimmed { pointer-events: none; }

    /* ── History Chips ── */
    .history-chips { display: flex; gap: 3px; overflow-x: auto; max-width: 320px; }
    .history-chips::-webkit-scrollbar { display: none; }
    .history-chip {
      padding: 3px 8px; border-radius: 6px; font-size: 0.62rem; font-weight: 600;
      white-space: nowrap; cursor: pointer;
      background: rgba(59,130,246,0.06); color: var(--text3);
      border: 1px solid rgba(59,130,246,0.1); transition: all 0.15s;
    }
    .history-chip:hover { border-color: var(--blue); color: var(--blue); }
    .history-chip.latest { color: var(--blue); border-color: rgba(59,130,246,0.25); }

    @media (max-width: 900px) {
      .history-chips { max-width: 160px; }
    }
  </style>
</head>
<body>
  <div class="bg-dots"></div>

  <!-- Full-viewport D3 Topology SVG -->
  <svg id="topoSvg"></svg>

  <!-- Top Bar -->
  <div class="top-bar glass">
    <img src="keti.png" alt="KETI" style="height:28px;width:auto;" onerror="this.style.display='none'">
    <span class="logo">TSN Playground</span>
    <div class="preset-pills" id="presetPills">
      <span class="preset-pill active" data-preset="standard">Standard</span>
      <span class="preset-pill" data-preset="reconf">Reconf</span>
      <span class="preset-pill" data-preset="optimal">Optimal</span>
    </div>
    <button class="top-btn primary" id="solveBtn"><span class="solve-dot" id="solveDot"></span>Solve</button>
    <span class="engine-badge loading" id="engineBadge"><span class="spinner"></span>GLPK</span>
    <div class="history-chips" id="historyChips"></div>
    <span class="top-spacer"></span>
    <button class="top-btn" id="cmdBtn" title="Command Palette"><span class="kbd-hint">Ctrl+K</span></button>
    <a href="index.html" class="top-btn" style="text-decoration:none;">Home</a>
  </div>

  <!-- Three.js PiP Window -->
  <div class="pip normal glass" id="pip">
    <div class="pip-titlebar" id="pipTitlebar">
      <span>3D View</span>
      <span style="flex:1;"></span>
      <button class="pip-btn" id="pipExpand" title="Expand">&#x26F6;</button>
      <button class="pip-btn" id="pipMinimize" title="Minimize">&minus;</button>
    </div>
    <div class="pip-canvas-wrap" id="pipCanvas"></div>
    <div class="pip-resize-handle" id="pipResize"></div>
  </div>

  <!-- Floating Flow Sidebar on Topology -->
  <div class="flow-sidebar glass" id="flowSidebar"></div>

  <!-- Metrics Ribbon -->
  <div class="metrics-ribbon" id="metricsRibbon"></div>

  <!-- Bottom Analysis Drawer -->
  <div class="drawer collapsed" id="drawer">
    <div class="drawer-handle" id="drawerHandle">
      <div class="drawer-handle-bar"></div>
    </div>
    <div class="drawer-tabs" id="drawerTabs">
      <span class="drawer-tab" data-tab="flows">Flows</span>
      <span class="drawer-tab" data-tab="model">Model</span>
      <span class="drawer-tab active" data-tab="gcl">GCL Gantt</span>
      <span class="drawer-tab" data-tab="delay">Delay</span>
      <span class="drawer-tab" data-tab="util">Utilization</span>
      <span class="drawer-tab" data-tab="switchgcl">Switch GCL</span>
      <span class="drawer-tab" data-tab="table">Table</span>
      <span class="drawer-tab" data-tab="json">JSON</span>
    </div>
    <div class="drawer-content">
      <div class="drawer-panel" id="panel-flows"></div>
      <div class="drawer-panel" id="panel-model"></div>
      <div class="drawer-panel active" id="panel-gcl">
        <div class="legend" id="gclLegend"></div>
        <div class="svg-container" id="gclContainer"></div>
      </div>
      <div class="drawer-panel" id="panel-delay">
        <div class="svg-container" id="delayContainer" style="min-height:350px;"></div>
      </div>
      <div class="drawer-panel" id="panel-util">
        <div class="svg-container" id="utilContainer" style="min-height:200px;"></div>
      </div>
      <div class="drawer-panel" id="panel-switchgcl">
        <div class="gcl-switch-grid" id="switchGclArea"></div>
      </div>
      <div class="drawer-panel" id="panel-table">
        <div style="overflow-x:auto;">
          <table class="pkt-table">
            <thead><tr>
              <th>Packet</th><th>Flow</th><th>Route</th><th>Release</th><th>End</th><th>E2E</th><th>Deadline</th><th>Slack</th><th>Status</th>
            </tr></thead>
            <tbody id="pktTableBody"></tbody>
          </table>
        </div>
      </div>
      <div class="drawer-panel" id="panel-json">
        <pre id="jsonOut">-</pre>
      </div>
    </div>
  </div>

  <!-- Command Palette Overlay -->
  <div class="cmd-overlay" id="cmdOverlay">
    <div class="cmd-palette glass" id="cmdPalette">
      <input class="cmd-search" id="cmdSearch" placeholder="Type a command..." autocomplete="off" spellcheck="false">
      <div class="cmd-list" id="cmdList"></div>
      <div class="cmd-inline-form" id="cmdInlineForm" style="display:none;"></div>
    </div>
  </div>

  <!-- Toast Container -->
  <div class="toast-container" id="toastContainer"></div>

  <!-- Tooltip -->
  <div class="tooltip" id="tooltip"></div>

  <!-- Popover Container (positioned absolutely in SVG space) -->
  <div id="popoverContainer" style="position:fixed;inset:0;pointer-events:none;z-index:60;"></div>

  <script src="vendor/d3.min.js"></script>
  <script type="module">
  import {
    initTooltip, solveGreedy, solveILP, renderGCL, renderDelayChart,
    renderUtilization, renderTable, renderSwitchGCL, showTip, hideTip
  } from './js/ilp-core.js';
  import {
    ROII_REAL_STANDARD, getRealPositions,
    ROII_REAL_NODE_COLORS, ROII_REAL_SWITCHES,
    realFlowColor, realGetDeviceType,
    ROII_REAL_3D_POSITIONS, ROII_REAL_3D_TILTS,
    ROII_REAL_3D_LABELS,
    ROII_REAL_RECONF,
    getReconfPositions, ROII_RECONF_NODE_COLORS,
    ROII_REAL_3D_POSITIONS_RECONF, ROII_REAL_3D_LABELS_RECONF,
    ROII_OPTIMAL, getOptimalPositions,
    ROII_OPTIMAL_NODE_COLORS, ROII_OPTIMAL_3D_POSITIONS,
    ROII_OPTIMAL_3D_LABELS
  } from './js/roii-real-data.js?v=5';

  /* ═══════════════════════════════════════════════
     STATE
     ═══════════════════════════════════════════════ */
  const STATE = {
    model: null, glpk: null, solverMode: 'greedy', autoSolve: true,
    ilpTimeout: 15, currentResult: null, history: [],
    // 3D
    scene3d: null, camera3d: null, renderer3d: null, controls3d: null,
    dynamicGroup: null, nodeMeshes3d: {}, linkMeshes3d: {}, clock3d: null, glbModel: null,
    // Selection
    selectedNode: null, selectedLink: null, selectedFlow: null,
    // UI
    drawerState: 'collapsed', drawerTab: 'gcl',
    pipState: 'normal', // 'normal' | 'expanded' | 'minimized'
    cmdPaletteOpen: false,
    zoomTransform: d3.zoomIdentity,
    // D3 references
    topoSvg: null, topoZoom: null, zoomLayer: null,
    nodeGroups: null, linkLines: null, nodePositions: {},
    currentPreset: 'standard'
  };

  /* ── Presets Registry ── */
  const PRESETS = {
    standard: {
      model: ROII_REAL_STANDARD, getPositions: getRealPositions,
      nodeColors: ROII_REAL_NODE_COLORS,
      pos3d: ROII_REAL_3D_POSITIONS, labels3d: ROII_REAL_3D_LABELS,
      tilts3d: ROII_REAL_3D_TILTS
    },
    reconf: {
      model: ROII_REAL_RECONF, getPositions: getReconfPositions,
      nodeColors: ROII_RECONF_NODE_COLORS,
      pos3d: ROII_REAL_3D_POSITIONS_RECONF, labels3d: ROII_REAL_3D_LABELS_RECONF,
      tilts3d: ROII_REAL_3D_TILTS
    },
    optimal: {
      model: ROII_OPTIMAL, getPositions: getOptimalPositions,
      nodeColors: ROII_OPTIMAL_NODE_COLORS,
      pos3d: ROII_OPTIMAL_3D_POSITIONS, labels3d: ROII_OPTIMAL_3D_LABELS,
      tilts3d: ROII_REAL_3D_TILTS
    }
  };

  const fcopts = { flowColorFn: realFlowColor, beColor: '#e2e8f0', beBorder: 'rgba(59,130,246,0.15)' };

  /* ═══════════════════════════════════════════════
     SELECTION BUS — D3 ↔ Three.js Bridge
     ═══════════════════════════════════════════════ */
  const SelectionBus = {
    _listeners: {},
    on(evt, fn) { (this._listeners[evt] = this._listeners[evt] || []).push(fn); },
    off(evt, fn) { const l = this._listeners[evt]; if(l) this._listeners[evt] = l.filter(f => f !== fn); },
    emit(evt, data) { (this._listeners[evt] || []).forEach(fn => fn(data)); }
  };

  // Cross-highlight handlers
  SelectionBus.on('node:hover', ({ nodeId, source }) => {
    if (source !== '3d') highlight3DNode(nodeId, true);
    if (source !== 'd3') highlightD3Node(nodeId, true);
  });
  SelectionBus.on('node:unhover', ({ nodeId, source }) => {
    if (source !== '3d') highlight3DNode(nodeId, false);
    if (source !== 'd3') highlightD3Node(nodeId, false);
  });

  function highlightD3Node(nodeId, on) {
    if (!STATE.zoomLayer) return;
    STATE.zoomLayer.selectAll('.topo-node-g').each(function(d) {
      if (d.id === nodeId) {
        d3.select(this).select('.topo-node-circle')
          .transition().duration(150)
          .attr('r', on ? 28 : 22);
      }
    });
  }

  function highlight3DNode(nodeId, on) {
    const mesh = STATE.nodeMeshes3d[nodeId];
    if (!mesh) return;
    if (on) {
      mesh.material.emissiveIntensity = 0.8;
      mesh.scale.set(1.3, 1.3, 1.3);
    } else {
      mesh.material.emissiveIntensity = 0.2;
      mesh.scale.set(1, 1, 1);
    }
  }

  /* ═══════════════════════════════════════════════
     TOAST NOTIFICATIONS
     ═══════════════════════════════════════════════ */
  function showToast(msg, type = 'info', duration = 3000) {
    const c = document.getElementById('toastContainer');
    const el = document.createElement('div');
    el.className = `toast ${type}`;
    el.textContent = msg;
    c.appendChild(el);
    setTimeout(() => { el.classList.add('fadeout'); setTimeout(() => el.remove(), 300); }, duration);
  }

  /* ═══════════════════════════════════════════════
     HELPERS
     ═══════════════════════════════════════════════ */
  function deepClone(obj) { return JSON.parse(JSON.stringify(obj)); }

  function getNodeColor(nodeId) {
    const colors = { ...ROII_REAL_NODE_COLORS, ...ROII_RECONF_NODE_COLORS, ...ROII_OPTIMAL_NODE_COLORS };
    return colors[nodeId]?.stroke || '#3B82F6';
  }

  function buildNodeColors(m) {
    const allColors = { ...ROII_REAL_NODE_COLORS, ...ROII_RECONF_NODE_COLORS, ...ROII_OPTIMAL_NODE_COLORS };
    const colors = {};
    m.nodes.forEach(n => {
      if (allColors[n.id]) {
        colors[n.id] = allColors[n.id];
      } else {
        const c = n.type === 'switch' ? '#3B82F6' : '#059669';
        colors[n.id] = { fill: c + '22', stroke: c, label: n.id, shortLabel: n.id.slice(0, 4) };
      }
    });
    return colors;
  }

  /* ═══════════════════════════════════════════════
     CUSTOM D3 TOPOLOGY — Full-Viewport
     ═══════════════════════════════════════════════ */
  function renderCustomTopology(model, result) {
    const svg = d3.select('#topoSvg');
    svg.selectAll('*').remove();

    const W = window.innerWidth;
    const H = window.innerHeight;
    svg.attr('width', W).attr('height', H);

    // Defs
    const defs = svg.append('defs');
    const glow = defs.append('filter').attr('id', 'glow');
    glow.append('feGaussianBlur').attr('stdDeviation', '3').attr('result', 'blur');
    glow.append('feMerge').selectAll('feMergeNode')
      .data(['blur', 'SourceGraphic']).enter()
      .append('feMergeNode').attr('in', d => d);

    defs.append('marker').attr('id', 'arr')
      .attr('viewBox', '0 0 10 7').attr('refX', 35).attr('refY', 3.5)
      .attr('markerWidth', 8).attr('markerHeight', 6).attr('orient', 'auto')
      .append('polygon').attr('points', '0 0, 10 3.5, 0 7').attr('fill', '#94a3b8');

    // Zoom layer
    const zoomLayer = svg.append('g').attr('class', 'zoom-layer');
    STATE.zoomLayer = zoomLayer;

    const zoom = d3.zoom()
      .scaleExtent([0.3, 5])
      .on('zoom', (event) => {
        STATE.zoomTransform = event.transform;
        zoomLayer.attr('transform', event.transform);
      });
    svg.call(zoom);
    STATE.topoZoom = zoom;

    // Click on background deselects flow (only on truly empty areas)
    svg.on('click.deselect', function(event) {
      const t = event.target;
      const isEmpty = t === svg.node() || t.classList.contains('zoom-layer')
        || t.tagName === 'rect' && t.getAttribute('fill') === 'transparent';
      if (isEmpty && STATE.selectedFlow) deselectFlow();
    });

    // Get positions from preset or auto-layout
    const nodeColors = buildNodeColors(model);
    const positions = getPositions(model, W, H);
    STATE.nodePositions = positions;

    // Build unique link pairs
    const linkPairs = new Map();
    model.links.forEach(l => {
      const key = [l.from, l.to].sort().join('-');
      if (!linkPairs.has(key)) linkPairs.set(key, []);
      linkPairs.get(key).push(l);
    });

    const uniqueLinks = [];
    linkPairs.forEach((links, key) => {
      uniqueLinks.push({
        source: links[0].from, target: links[0].to,
        bidir: links.length > 1, ids: links.map(l => l.id), key
      });
    });

    // Compute utilization per link pair
    const linkUtils = {};
    if (result) {
      model.links.forEach(l => {
        const entries = result.gcl.links[l.id]?.entries || [];
        let flowTime = 0, guardTime = 0;
        entries.forEach(e => {
          if (e.note.includes('guard')) guardTime += e.duration_us;
          else if (!e.note.includes('best-effort')) flowTime += e.duration_us;
        });
        const util = (flowTime + guardTime) / model.cycle_time_us * 100;
        const pairKey = [l.from, l.to].sort().join('-');
        linkUtils[pairKey] = Math.max(linkUtils[pairKey] || 0, util);
      });
    }

    // Draw links
    const linkG = zoomLayer.append('g').attr('class', 'links-layer');
    const linkSel = linkG.selectAll('g.link-g')
      .data(uniqueLinks).enter().append('g').attr('class', 'link-g');

    // Visible link line
    linkSel.append('line')
      .attr('class', 'topo-link-line')
      .attr('x1', d => positions[d.source]?.x || 0)
      .attr('y1', d => positions[d.source]?.y || 0)
      .attr('x2', d => positions[d.target]?.x || 0)
      .attr('y2', d => positions[d.target]?.y || 0)
      .attr('marker-end', 'url(#arr)')
      .each(function(d) {
        const util = linkUtils[d.key] || 0;
        if (result && util > 0) {
          const t = Math.min(util / 60, 1);
          const color = d3.interpolateRgb('#059669', '#dc2626')(t);
          const width = 2 + t * 8;
          d3.select(this)
            .attr('stroke', color)
            .attr('stroke-width', width);
          if (util > 50) {
            d3.select(this)
              .attr('stroke-dasharray', '8,4')
              .classed('link-animated-dash', true);
          }
        }
      });

    // Invisible fat hit area for clicks
    linkSel.append('line')
      .attr('class', 'topo-link-hit')
      .attr('x1', d => positions[d.source]?.x || 0)
      .attr('y1', d => positions[d.source]?.y || 0)
      .attr('x2', d => positions[d.target]?.x || 0)
      .attr('y2', d => positions[d.target]?.y || 0)
      .on('click', (event, d) => showLinkPopover(d, event));

    STATE.linkLines = linkSel;

    // Draw flow path polylines (before particles, after links)
    drawFlowPaths(model, result, zoomLayer, positions);

    // Draw flow particles after solve
    if (result) {
      const particleG = zoomLayer.append('g').attr('class', 'particles-layer');
      spawnFlowParticles(model, result, particleG, positions);
    }

    // Draw nodes
    const nodeG = zoomLayer.append('g').attr('class', 'nodes-layer');
    const nodeSel = nodeG.selectAll('g.topo-node-g')
      .data(model.nodes.map(n => ({
        ...n,
        x: positions[n.id]?.x || W/2,
        y: positions[n.id]?.y || H/2,
        color: nodeColors[n.id]?.fill || '#dbeafe',
        stroke: nodeColors[n.id]?.stroke || '#3B82F6',
        label: nodeColors[n.id]?.label || n.id,
        shortLabel: nodeColors[n.id]?.shortLabel || (n.type === 'switch' ? 'SW' : 'ES')
      })))
      .enter().append('g')
      .attr('class', 'topo-node-g')
      .attr('transform', d => `translate(${d.x},${d.y})`);

    // Outer ring
    nodeSel.append('circle')
      .attr('r', 30).attr('fill', 'none')
      .attr('stroke', d => d.stroke).attr('stroke-width', 1).attr('opacity', 0.12);

    // Main circle
    nodeSel.append('circle')
      .attr('class', 'topo-node-circle')
      .attr('r', 22).attr('fill', d => d.color)
      .attr('stroke', d => d.stroke).attr('stroke-width', 2);

    // Labels
    nodeSel.append('text').attr('class', 'topo-node-label')
      .attr('dy', -1).text(d => d.label);
    nodeSel.append('text').attr('class', 'topo-node-type')
      .attr('dy', 12).text(d => d.shortLabel);

    // Show util badge on switch nodes after solve
    if (result) {
      nodeSel.filter(d => d.type === 'switch').each(function(d) {
        // Compute max util on egress links
        let maxUtil = 0;
        model.links.filter(l => l.from === d.id).forEach(l => {
          const entries = result.gcl.links[l.id]?.entries || [];
          let active = 0;
          entries.forEach(e => { if (!e.note.includes('best-effort')) active += e.duration_us; });
          maxUtil = Math.max(maxUtil, active / model.cycle_time_us * 100);
        });
        if (maxUtil > 0) {
          d3.select(this).append('text')
            .attr('dy', 38).attr('text-anchor', 'middle')
            .attr('font-size', '8px').attr('font-weight', '700')
            .attr('fill', maxUtil > 50 ? '#dc2626' : maxUtil > 30 ? '#d97706' : '#059669')
            .text(maxUtil.toFixed(1) + '%');
        }
      });
    }

    // Node interactions — unified drag + click
    let dragStartPos = null;
    nodeSel
      .on('mouseenter', (event, d) => {
        SelectionBus.emit('node:hover', { nodeId: d.id, source: 'd3' });
      })
      .on('mouseleave', (event, d) => {
        SelectionBus.emit('node:unhover', { nodeId: d.id, source: 'd3' });
      })
      .call(d3.drag()
        .on('start', function(event, d) {
          dragStartPos = { x: event.x, y: event.y };
          d3.select(this).raise();
        })
        .on('drag', function(event, d) {
          d.x = event.x; d.y = event.y;
          d3.select(this).attr('transform', `translate(${d.x},${d.y})`);
          positions[d.id] = { x: d.x, y: d.y };
          // Update links
          linkSel.select('.topo-link-line')
            .attr('x1', dd => positions[dd.source]?.x || 0)
            .attr('y1', dd => positions[dd.source]?.y || 0)
            .attr('x2', dd => positions[dd.target]?.x || 0)
            .attr('y2', dd => positions[dd.target]?.y || 0);
          linkSel.select('.topo-link-hit')
            .attr('x1', dd => positions[dd.source]?.x || 0)
            .attr('y1', dd => positions[dd.source]?.y || 0)
            .attr('x2', dd => positions[dd.target]?.x || 0)
            .attr('y2', dd => positions[dd.target]?.y || 0);
          // Update flow path polylines during drag
          updateFlowPathsDrag(positions, zoomLayer);
        })
        .on('end', function(event, d) {
          const dist = dragStartPos
            ? Math.hypot(event.x - dragStartPos.x, event.y - dragStartPos.y) : 0;
          dragStartPos = null;
          if (dist < 5) {
            // Click — show node popover
            const rect = svg.node().getBoundingClientRect();
            const sx = event.sourceEvent.clientX;
            const sy = event.sourceEvent.clientY;
            showNodePopover(d.id, { x: sx, y: sy });
          } else {
            // Real drag — re-solve
            scheduleAutoSolve();
          }
        })
      );

    STATE.nodeGroups = nodeSel;

    // Setup touch gestures
    setupGestures(svg, zoomLayer, model, positions, nodeColors);

    // Solve wave animation
    if (result) {
      const cx = W / 2, cy = H / 2;
      const wave = svg.append('circle')
        .attr('class', 'solve-wave')
        .attr('cx', cx).attr('cy', cy).attr('r', 10);
      wave.transition().duration(600).ease(d3.easeQuadOut)
        .attr('r', Math.max(W, H) * 0.4)
        .attr('opacity', 0)
        .remove();
    }
  }

  function getPositions(m, W, H) {
    const key = STATE.currentPreset;
    const preset = PRESETS[key];
    if (preset) {
      const presetNodes = new Set(preset.model.nodes.map(n => n.id));
      const modelNodes = new Set(m.nodes.map(n => n.id));
      if ([...modelNodes].every(id => presetNodes.has(id)) && modelNodes.size === presetNodes.size) {
        return preset.getPositions(W, H);
      }
    }
    return autoLayout(m, W, H);
  }

  function autoLayout(m, W, H) {
    const pos = {};
    const switches = m.nodes.filter(n => n.type === 'switch');
    const endpoints = m.nodes.filter(n => n.type !== 'switch');
    const totalSw = switches.length || 1;
    const totalEp = endpoints.length || 1;
    endpoints.forEach((n, i) => { pos[n.id] = { x: W * ((i + 0.5) / totalEp), y: H * 0.15 }; });
    switches.forEach((n, i) => { pos[n.id] = { x: W * ((i + 0.5) / totalSw), y: H * 0.5 }; });
    m.nodes.forEach(n => { if (n.id.includes('ACU')) pos[n.id] = { x: W * 0.5, y: H * 0.85 }; });
    return pos;
  }

  /* ── Flow Particles ── */
  function spawnFlowParticles(model, result, particleG, positions) {
    const seenFlows = new Set();
    result.packetRows.forEach(p => {
      if (seenFlows.has(p.flow_id)) return;
      seenFlows.add(p.flow_id);
      const pathNodes = [];
      p.hops.forEach(h => {
        const link = model.links.find(l => l.id === h.link_id);
        if (link) {
          if (pathNodes.length === 0) pathNodes.push(link.from);
          pathNodes.push(link.to);
        }
      });
      if (pathNodes.length < 2) return;
      const color = realFlowColor(p.flow_id);
      const points = pathNodes.map(id => positions[id]).filter(Boolean);
      if (points.length < 2) return;

      function animateOne() {
        const particle = particleG.append('circle')
          .attr('class', 'flow-particle')
          .attr('r', 4).attr('fill', color).attr('opacity', 0.85)
          .attr('filter', 'url(#glow)')
          .attr('cx', points[0].x).attr('cy', points[0].y);
        let chain = particle;
        for (let i = 1; i < points.length; i++) {
          chain = chain.transition().duration(500).ease(d3.easeLinear)
            .attr('cx', points[i].x).attr('cy', points[i].y);
        }
        chain.transition().duration(200).attr('opacity', 0)
          .remove()
          .transition().delay(800 + Math.random() * 1500)
          .on('end', animateOne);
      }
      setTimeout(animateOne, Math.random() * 2000);
    });
  }

  /* ═══════════════════════════════════════════════
     TOUCH GESTURE SYSTEM
     ═══════════════════════════════════════════════ */
  let longPressTimer = null;
  let lastTapTime = 0;
  let lastTapTarget = null;
  let rubberBandLine = null;
  let rubberBandSource = null;

  function setupGestures(svg, zoomLayer, model, positions, nodeColors) {
    const svgNode = svg.node();
    let gestureStartPt = null;

    // Long-press on empty space → add node (600ms, cancelled by movement > 8px)
    svg.on('pointerdown.gesture', function(event) {
      if (event.target !== svgNode && !event.target.classList.contains('zoom-layer')) return;
      clearTimeout(longPressTimer);
      gestureStartPt = { x: event.clientX, y: event.clientY };
      const pt = getTransformedPoint(event, svg);
      longPressTimer = setTimeout(() => {
        addNodeAt(pt.x, pt.y);
        gestureStartPt = null;
      }, 600);
    });

    svg.on('pointermove.gesture', (event) => {
      if (gestureStartPt && Math.hypot(event.clientX - gestureStartPt.x, event.clientY - gestureStartPt.y) > 8) {
        clearTimeout(longPressTimer);
        gestureStartPt = null;
      }
    });

    svg.on('pointerup.gesture pointercancel.gesture', () => {
      clearTimeout(longPressTimer);
      gestureStartPt = null;
    });

    // Long-press on node → start rubber-band link creation (500ms)
    let rbStartPt = null;
    STATE.nodeGroups.on('pointerdown.rubberband', function(event, d) {
      event.stopPropagation();
      const nodeId = d.id;
      rbStartPt = { x: event.clientX, y: event.clientY };
      clearTimeout(longPressTimer);
      longPressTimer = setTimeout(() => {
        rubberBandSource = nodeId;
        const pos = positions[nodeId];
        rubberBandLine = zoomLayer.append('line')
          .attr('class', 'rubber-band-line')
          .attr('x1', pos.x).attr('y1', pos.y)
          .attr('x2', pos.x).attr('y2', pos.y);
        if (navigator.vibrate) navigator.vibrate(30);
        rbStartPt = null;
      }, 500);
    });

    svg.on('pointermove.rubberband', function(event) {
      // Cancel long-press if moved too much before timer fires
      if (rbStartPt && Math.hypot(event.clientX - rbStartPt.x, event.clientY - rbStartPt.y) > 8) {
        clearTimeout(longPressTimer);
        rbStartPt = null;
      }
      if (!rubberBandLine) return;
      const pt = getTransformedPoint(event, svg);
      rubberBandLine.attr('x2', pt.x).attr('y2', pt.y);
    });

    svg.on('pointerup.rubberband', function(event) {
      clearTimeout(longPressTimer);
      rbStartPt = null;
      if (!rubberBandLine || !rubberBandSource) return;
      const pt = getTransformedPoint(event, svg);
      let closestNode = null, closestDist = 50;
      model.nodes.forEach(n => {
        const p = positions[n.id];
        if (!p) return;
        const dist = Math.hypot(p.x - pt.x, p.y - pt.y);
        if (dist < closestDist && n.id !== rubberBandSource) {
          closestDist = dist; closestNode = n.id;
        }
      });
      if (closestNode) {
        addLinkBetween(rubberBandSource, closestNode);
      }
      rubberBandLine.remove();
      rubberBandLine = null;
      rubberBandSource = null;
    });
  }

  function getTransformedPoint(event, svg) {
    const rect = svg.node().getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    // Invert zoom transform
    const t = STATE.zoomTransform;
    return { x: (x - t.x) / t.k, y: (y - t.y) / t.k };
  }

  function addNodeAt(x, y) {
    const m = STATE.model;
    let newId = 'NODE_' + (m.nodes.length + 1);
    while (m.nodes.some(n => n.id === newId)) newId += '_';
    m.nodes.push({ id: newId, type: 'endstation' });
    STATE.nodePositions[newId] = { x, y };
    renderCustomTopology(m, STATE.currentResult);
    showToast(`Added node ${newId}`, 'info');
  }

  function addLinkBetween(fromId, toId) {
    const m = STATE.model;
    const newId = 'l_' + fromId.toLowerCase() + '_' + toId.toLowerCase() + '_' + Date.now().toString(36).slice(-4);
    m.links.push({ id: newId, from: fromId, to: toId, rate_mbps: 1000, prop_delay_us: 0.5 });
    scheduleAutoSolve();
    showToast(`Added link ${fromId} -> ${toId}`, 'info');
  }

  /* ═══════════════════════════════════════════════
     POPOVERS
     ═══════════════════════════════════════════════ */
  function closePopovers() {
    document.getElementById('popoverContainer').innerHTML = '';
  }

  function showNodePopover(nodeId, screenPos) {
    closePopovers();
    const m = STATE.model;
    const nodeIdx = m.nodes.findIndex(n => n.id === nodeId);
    if (nodeIdx < 0) return;
    const node = m.nodes[nodeIdx];
    const linkCount = m.links.filter(l => l.from === nodeId || l.to === nodeId).length;

    const div = document.createElement('div');
    div.className = 'popover';
    div.style.pointerEvents = 'auto';
    div.style.left = Math.min(screenPos.x, window.innerWidth - 250) + 'px';
    div.style.top = Math.min(screenPos.y, window.innerHeight - 260) + 'px';
    div.innerHTML = `
      <div class="popover-title">Node: ${nodeId}</div>
      <div class="popover-row">
        <label>ID</label>
        <input type="text" id="popNodeId" value="${node.id}">
      </div>
      <div class="popover-row">
        <label>Type</label>
        <select id="popNodeType">
          <option value="switch" ${node.type==='switch'?'selected':''}>switch</option>
          <option value="endstation" ${node.type==='endstation'?'selected':''}>endstation</option>
        </select>
      </div>
      <div style="font-size:0.7rem;color:var(--text3);margin-top:4px;">${linkCount} connected links</div>
      <div class="popover-actions">
        <button class="popover-btn primary" id="popNodeSave">Save</button>
        <button class="popover-btn danger" id="popNodeDelete">Delete</button>
        <button class="popover-btn" id="popNodeClose">Close</button>
      </div>
    `;
    document.getElementById('popoverContainer').appendChild(div);

    div.querySelector('#popNodeSave').onclick = () => {
      const newId = div.querySelector('#popNodeId').value.trim();
      const newType = div.querySelector('#popNodeType').value;
      if (newId && newId !== node.id) {
        const oldId = node.id;
        node.id = newId;
        m.links.forEach(l => { if (l.from === oldId) l.from = newId; if (l.to === oldId) l.to = newId; });
        m.flows.forEach(f => { if (f.src === oldId) f.src = newId; if (f.dst === oldId) f.dst = newId; });
      }
      node.type = newType;
      closePopovers();
      scheduleAutoSolve();
    };
    div.querySelector('#popNodeDelete').onclick = () => {
      m.nodes.splice(nodeIdx, 1);
      m.links = m.links.filter(l => l.from !== nodeId && l.to !== nodeId);
      m.flows = m.flows.filter(f => f.src !== nodeId && f.dst !== nodeId);
      closePopovers();
      scheduleAutoSolve();
      showToast(`Deleted node ${nodeId}`, 'info');
    };
    div.querySelector('#popNodeClose').onclick = closePopovers;

    // Click-away dismiss
    setTimeout(() => {
      document.addEventListener('pointerdown', function dismiss(e) {
        if (!div.contains(e.target)) { closePopovers(); document.removeEventListener('pointerdown', dismiss); }
      });
    }, 50);
  }

  function showLinkPopover(linkData, event) {
    closePopovers();
    const m = STATE.model;
    const result = STATE.currentResult;
    const linkIds = linkData.ids;

    let utilPercent = 0, entries = [];
    if (result) {
      linkIds.forEach(lid => {
        const le = result.gcl.links[lid]?.entries || [];
        let flowTime = 0, guardTime = 0;
        le.forEach(e => {
          if (e.note.includes('guard')) guardTime += e.duration_us;
          else if (!e.note.includes('best-effort')) flowTime += e.duration_us;
        });
        const u = (flowTime + guardTime) / m.cycle_time_us * 100;
        if (u > utilPercent) { utilPercent = u; entries = le; }
      });
    }

    const div = document.createElement('div');
    div.className = 'popover';
    div.style.pointerEvents = 'auto';
    div.style.left = Math.min(event.clientX, window.innerWidth - 320) + 'px';
    div.style.top = Math.min(event.clientY - 30, window.innerHeight - 300) + 'px';

    // Build mini gantt
    let ganttHtml = '';
    if (entries.length) {
      ganttHtml = '<div class="link-popover-gantt">';
      entries.forEach(e => {
        const isBE = e.note.includes('best-effort');
        const isGuard = e.note.includes('guard');
        const sx = (e.start_us / m.cycle_time_us) * 100;
        const ew = Math.max((e.duration_us / m.cycle_time_us) * 100, 0.5);
        const fill = isGuard ? '#f9a825' : isBE ? 'rgba(0,0,0,0.04)' : realFlowColor(e.note);
        ganttHtml += `<div style="position:absolute;left:${sx}%;width:${ew}%;height:100%;background:${fill};opacity:${isBE?0.2:0.85};"></div>`;
      });
      ganttHtml += '</div>';
    }

    const flowEntries = entries.filter(e => !e.note.includes('best-effort') && !e.note.includes('guard'));

    // Find the first link object for editing
    const firstLink = m.links.find(l => linkIds.includes(l.id));
    const rateVal = firstLink ? firstLink.rate_mbps : 1000;
    const delayVal = firstLink ? firstLink.prop_delay_us : 0.5;

    div.innerHTML = `
      <div class="popover-title">${linkData.source} &rarr; ${linkData.target}</div>
      <div class="link-popover-util">${utilPercent.toFixed(1)}% utilization</div>
      ${ganttHtml}
      <div class="link-popover-entries">${flowEntries.length} flow entries, ${linkIds.length > 1 ? 'bidirectional' : 'unidirectional'}</div>
      <div class="popover-row" style="margin-top:8px;">
        <label>Rate (Mbps)</label>
        <input type="number" id="popLinkRate" value="${rateVal}" min="1" step="1">
      </div>
      <div class="popover-row">
        <label>Delay (us)</label>
        <input type="number" id="popLinkDelay" value="${delayVal}" min="0" step="0.1">
      </div>
      <div class="popover-actions">
        <button class="popover-btn primary" id="popLinkSave">Save</button>
        <button class="popover-btn danger" id="popLinkDelete">Delete</button>
        <button class="popover-btn" id="popLinkClose">Close</button>
      </div>
    `;
    document.getElementById('popoverContainer').appendChild(div);

    div.querySelector('#popLinkSave').onclick = () => {
      const newRate = parseFloat(div.querySelector('#popLinkRate').value) || rateVal;
      const newDelay = parseFloat(div.querySelector('#popLinkDelay').value) || 0;
      linkIds.forEach(lid => {
        const link = m.links.find(l => l.id === lid);
        if (link) { link.rate_mbps = newRate; link.prop_delay_us = newDelay; }
      });
      closePopovers();
      scheduleAutoSolve();
      showToast('Link updated', 'success');
    };

    div.querySelector('#popLinkDelete').onclick = () => {
      m.links = m.links.filter(l => !linkIds.includes(l.id));
      closePopovers();
      scheduleAutoSolve();
      showToast('Link deleted', 'info');
    };

    div.querySelector('#popLinkClose').onclick = closePopovers;

    setTimeout(() => {
      document.addEventListener('pointerdown', function dismiss(e) {
        if (!div.contains(e.target)) { closePopovers(); document.removeEventListener('pointerdown', dismiss); }
      });
    }, 50);
  }

  /* ═══════════════════════════════════════════════
     THREE.JS PIP WINDOW
     ═══════════════════════════════════════════════ */
  const TMPL = {
    lidar_g32:    { w: 1, h: 1, d: 1, color: 0x10B981 },
    lidar_pandar: { w: 1, h: 1, d: 1, color: 0x0D9488 },
    radar:        { w: 1, h: 1, d: 1, color: 0x952aff },
    replicator:   { w: 2, h: 1.5, d: 2, color: 0xd97706 },
    switch_f:     { w: 4, h: 2, d: 4, color: 0x3B82F6 },
    switch_r:     { w: 4, h: 2, d: 4, color: 0x06B6D4 },
    ecu:          { w: 4, h: 2, d: 4, color: 0xdc2626 }
  };

  function getDeviceType(nodeId) {
    try { return realGetDeviceType(nodeId); } catch(e) {}
    if (nodeId.includes('SW') || nodeId.includes('switch')) return 'switch_f';
    if (nodeId.includes('ACU') || nodeId.includes('ECU')) return 'ecu';
    return 'lidar_g32';
  }

  function createDevice(nodeId, position, label, tilt) {
    const type = getDeviceType(nodeId);
    const t = TMPL[type] || TMPL.lidar_g32;
    const group = new THREE.Group();
    const { w, h, d } = t;
    let geometry;
    if (type === 'lidar_pandar') geometry = new THREE.CylinderGeometry(w * 0.6, w * 0.6, h * 0.8, 16);
    else if (type === 'replicator') geometry = new THREE.OctahedronGeometry(w * 0.7);
    else geometry = new THREE.BoxGeometry(w, h, d);
    const mat = new THREE.MeshPhongMaterial({ color: t.color, emissive: t.color, emissiveIntensity: 0.5, specular: 0x888888, shininess: 30 });
    const mesh = new THREE.Mesh(geometry, mat);
    mesh.castShadow = true; mesh.receiveShadow = true;
    group.add(mesh);
    group.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 5 })));
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 512; canvas.height = 128;
    ctx.fillStyle = 'rgba(26, 26, 46, 0.9)'; ctx.fillRect(0, 0, 512, 128);
    ctx.fillStyle = '#FFFFFF'; ctx.font = 'bold 48px Arial'; ctx.textAlign = 'center';
    ctx.fillText(label, 256, 75);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
    const ls = Math.max(w, d) * 1.2;
    sprite.scale.set(ls, ls * 0.25, 1); sprite.position.y = h + 1;
    group.add(sprite);
    group.position.copy(position);
    if (tilt) {
      if (tilt.x !== undefined) group.rotation.x = tilt.x;
      if (tilt.y !== undefined) group.rotation.y = tilt.y;
      if (tilt.z !== undefined) group.rotation.z = tilt.z;
    }
    return { mesh, group };
  }

  function init3D() {
    const container = document.getElementById('pipCanvas');
    if (!container || typeof THREE === 'undefined') return;
    STATE.scene3d = new THREE.Scene();
    STATE.scene3d.background = new THREE.Color(0xf0f0f0);
    STATE.scene3d.fog = new THREE.Fog(0xf0f0f0, 80, 250);
    STATE.camera3d = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
    STATE.camera3d.position.set(50, 35, 70);
    STATE.renderer3d = new THREE.WebGLRenderer({ antialias: true });
    STATE.renderer3d.shadowMap.enabled = true;
    STATE.renderer3d.shadowMap.type = THREE.PCFSoftShadowMap;

    function updateSize() {
      const w = container.clientWidth, h = container.clientHeight;
      if (w === 0 || h === 0) return;
      STATE.camera3d.aspect = w / h;
      STATE.camera3d.updateProjectionMatrix();
      STATE.renderer3d.setSize(w, h);
    }
    updateSize();
    container.appendChild(STATE.renderer3d.domElement);
    new ResizeObserver(updateSize).observe(container);

    STATE.controls3d = new THREE.OrbitControls(STATE.camera3d, STATE.renderer3d.domElement);
    STATE.controls3d.enableDamping = true; STATE.controls3d.dampingFactor = 0.05;
    STATE.controls3d.autoRotate = true; STATE.controls3d.autoRotateSpeed = 1.2;
    STATE.controls3d.minDistance = 20; STATE.controls3d.maxDistance = 120;
    STATE.controls3d.target.set(0, 0, 0);

    STATE.scene3d.add(new THREE.AmbientLight(0xffffff, 1.2));
    const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
    mainLight.position.set(30, 50, 30); mainLight.castShadow = true;
    mainLight.shadow.mapSize.set(2048, 2048);
    mainLight.shadow.camera.near = 0.5; mainLight.shadow.camera.far = 200;
    mainLight.shadow.camera.left = -60; mainLight.shadow.camera.right = 60;
    mainLight.shadow.camera.top = 60; mainLight.shadow.camera.bottom = -60;
    STATE.scene3d.add(mainLight);
    STATE.scene3d.add(new THREE.DirectionalLight(0xffffff, 1.0).translateY(50));
    const pl1 = new THREE.PointLight(0x3B82F6, 2, 100); pl1.position.set(20, 15, 20); STATE.scene3d.add(pl1);
    const pl2 = new THREE.PointLight(0x06B6D4, 1.5, 80); pl2.position.set(-20, 15, -20); STATE.scene3d.add(pl2);

    const grid = new THREE.GridHelper(100, 50, 0x3B82F6, 0xCCCCCC);
    grid.material.opacity = 0.4; grid.material.transparent = true; grid.position.y = -0.5;
    STATE.scene3d.add(grid);
    const plane = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.ShadowMaterial({ opacity: 0.3 }));
    plane.rotation.x = -Math.PI / 2; plane.position.y = -0.5; plane.receiveShadow = true;
    STATE.scene3d.add(plane);

    const loader = new THREE.GLTFLoader();
    loader.load('./roii.glb', (gltf) => {
      STATE.glbModel = gltf.scene;
      const box = new THREE.Box3().setFromObject(STATE.glbModel);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const scale = 40 / Math.max(size.x, size.y, size.z);
      STATE.glbModel.scale.set(scale, scale, scale);
      STATE.glbModel.position.set(-center.x, -center.y + size.y * scale * 0.5 + 0.5, -center.z);
      STATE.glbModel.traverse(child => {
        if (!child.isMesh) return;
        const mats = Array.isArray(child.material) ? child.material : [child.material];
        mats.forEach(mat => {
          mat.transparent = true; mat.opacity = 0.3; mat.side = THREE.DoubleSide; mat.depthWrite = true;
          if (mat.color) mat.color.multiplyScalar(1.5);
          mat.emissive = mat.color ? mat.color.clone().multiplyScalar(0.3) : new THREE.Color(0xffffff);
          mat.emissiveIntensity = 0.4;
        });
        child.castShadow = true; child.receiveShadow = true;
      });
      STATE.scene3d.add(STATE.glbModel);
    }, undefined, (err) => console.warn('GLB load failed:', err));

    STATE.dynamicGroup = new THREE.Group();
    STATE.scene3d.add(STATE.dynamicGroup);
    rebuild3D(PRESETS[STATE.currentPreset]);

    STATE.clock3d = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      if (STATE.pipState === 'minimized') return;
      STATE.controls3d.update();
      const pulse = Math.sin(STATE.clock3d.elapsedTime * 2.5) * 0.06;
      for (const m of Object.values(STATE.nodeMeshes3d)) {
        if (m && m.material) m.material.emissiveIntensity = 0.2 + pulse;
      }
      STATE.renderer3d.render(STATE.scene3d, STATE.camera3d);
    }
    animate();
  }

  function rebuild3D(mode) {
    if (!STATE.dynamicGroup) return;
    while (STATE.dynamicGroup.children.length > 0) {
      const child = STATE.dynamicGroup.children[0];
      STATE.dynamicGroup.remove(child);
      child.traverse(c => {
        if (c.geometry) c.geometry.dispose();
        if (c.material) { if (Array.isArray(c.material)) c.material.forEach(m => m.dispose()); else c.material.dispose(); }
      });
    }
    STATE.nodeMeshes3d = {}; STATE.linkMeshes3d = {};
    const pos3d = mode.pos3d || {};
    const labels3d = mode.labels3d || {};
    const tilts3d = mode.tilts3d || {};
    const model = mode.model;
    const nodePos3D = {};
    for (const [id, pos] of Object.entries(pos3d)) {
      const v = new THREE.Vector3(pos.x, pos.y, pos.z);
      const dev = createDevice(id, v, labels3d[id] || id, tilts3d[id] || null);
      STATE.dynamicGroup.add(dev.group);
      nodePos3D[id] = v; STATE.nodeMeshes3d[id] = dev.mesh;
    }
    const drawnLinks = new Set();
    for (const link of model.links) {
      const key = [link.from, link.to].sort().join('|');
      if (drawnLinks.has(key)) continue;
      drawnLinks.add(key);
      const p1 = nodePos3D[link.from], p2 = nodePos3D[link.to];
      if (!p1 || !p2) continue;
      STATE.dynamicGroup.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([p1, p2]),
        new THREE.LineBasicMaterial({ color: 0x3B82F6, transparent: true, opacity: 0.3 })
      ));
      const curve = new THREE.CatmullRomCurve3([p1.clone(), p2.clone()]);
      const tubeMesh = new THREE.Mesh(
        new THREE.TubeGeometry(curve, 20, 0.08, 8, false),
        new THREE.MeshStandardMaterial({ color: 0x3B82F6, emissive: 0x3B82F6, emissiveIntensity: 0.9, transparent: true, opacity: 0.95 })
      );
      STATE.dynamicGroup.add(tubeMesh);
      STATE.dynamicGroup.add(new THREE.Mesh(
        new THREE.TubeGeometry(curve, 20, 0.2, 8, false),
        new THREE.MeshBasicMaterial({ color: 0x3B82F6, transparent: true, opacity: 0.35 })
      ));
    }
  }

  /* ── PiP Drag, Resize, Expand/Minimize ── */
  function initPiP() {
    const pip = document.getElementById('pip');
    const titlebar = document.getElementById('pipTitlebar');
    const resizeHandle = document.getElementById('pipResize');

    // Drag
    let isDragging = false, dragOffX = 0, dragOffY = 0;
    titlebar.addEventListener('pointerdown', (e) => {
      isDragging = true;
      dragOffX = e.clientX - pip.offsetLeft;
      dragOffY = e.clientY - pip.offsetTop;
      e.preventDefault();
    });
    document.addEventListener('pointermove', (e) => {
      if (!isDragging) return;
      pip.style.left = (e.clientX - dragOffX) + 'px';
      pip.style.top = (e.clientY - dragOffY) + 'px';
      pip.style.right = 'auto'; pip.style.bottom = 'auto';
    });
    document.addEventListener('pointerup', () => { isDragging = false; });

    // Resize
    let isResizing = false, startW = 0, startH = 0, startX = 0, startY = 0;
    resizeHandle.addEventListener('pointerdown', (e) => {
      if (STATE.pipState !== 'normal') return;
      isResizing = true;
      startW = pip.offsetWidth; startH = pip.offsetHeight;
      startX = e.clientX; startY = e.clientY;
      e.preventDefault(); e.stopPropagation();
    });
    document.addEventListener('pointermove', (e) => {
      if (!isResizing) return;
      pip.style.width = Math.max(200, startW + (e.clientX - startX)) + 'px';
      pip.style.height = Math.max(150, startH + (e.clientY - startY)) + 'px';
    });
    document.addEventListener('pointerup', () => { isResizing = false; });

    // Expand
    document.getElementById('pipExpand').addEventListener('click', () => {
      if (STATE.pipState === 'expanded') {
        pip.className = 'pip normal glass'; STATE.pipState = 'normal';
      } else {
        pip.className = 'pip expanded glass'; STATE.pipState = 'expanded';
      }
      pip.style.left = ''; pip.style.top = ''; pip.style.right = ''; pip.style.bottom = '';
    });

    // Minimize
    document.getElementById('pipMinimize').addEventListener('click', () => {
      if (STATE.pipState === 'minimized') {
        pip.className = 'pip normal glass'; STATE.pipState = 'normal';
        pip.querySelector('.pip-canvas-wrap').innerHTML = '';
        pip.querySelector('.pip-canvas-wrap').appendChild(STATE.renderer3d.domElement);
      } else {
        pip.className = 'pip minimized glass'; STATE.pipState = 'minimized';
        pip.querySelector('.pip-canvas-wrap').innerHTML = '<span>3D</span>';
      }
      pip.style.left = ''; pip.style.top = ''; pip.style.right = ''; pip.style.bottom = '';
    });

    // Click minimized to restore
    pip.addEventListener('click', (e) => {
      if (STATE.pipState === 'minimized' && e.target !== document.getElementById('pipMinimize')) {
        pip.className = 'pip normal glass'; STATE.pipState = 'normal';
        pip.querySelector('.pip-canvas-wrap').innerHTML = '';
        pip.querySelector('.pip-canvas-wrap').appendChild(STATE.renderer3d.domElement);
        pip.style.left = ''; pip.style.top = ''; pip.style.right = ''; pip.style.bottom = '';
      }
    });
  }

  /* ═══════════════════════════════════════════════
     COMMAND PALETTE
     ═══════════════════════════════════════════════ */
  const COMMANDS = [
    { group: 'Presets', icon: '&#x25CF;', label: 'Load Standard', hint: '13N/9F', action: () => loadPreset('standard') },
    { group: 'Presets', icon: '&#x25CF;', label: 'Load Reconfigured', hint: '14N/11F', action: () => loadPreset('reconf') },
    { group: 'Presets', icon: '&#x25CF;', label: 'Load Optimal', hint: '13N/9F', action: () => loadPreset('optimal') },
    { group: 'Parameters', icon: '&#x2699;', label: 'Set Cycle Time', hint: 'us', action: () => showParamForm('cycle_time_us', 'Cycle Time (us)', 1000, 50000, 100) },
    { group: 'Parameters', icon: '&#x2699;', label: 'Set Guard Band', hint: 'us', action: () => showParamForm('guard_band_us', 'Guard Band (us)', 0, 20, 1) },
    { group: 'Parameters', icon: '&#x2699;', label: 'Set Processing Delay', hint: 'us', action: () => showParamForm('processing_delay_us', 'Proc Delay (us)', 0, 20, 1) },
    { group: 'Edit', icon: '+', label: 'Add Node', hint: '', action: () => { addNodeAt(window.innerWidth/2, window.innerHeight/2); closeCommandPalette(); } },
    { group: 'Edit', icon: '+', label: 'Add Flow', hint: '', action: () => { addFlow(); closeCommandPalette(); } },
    { group: 'Solver', icon: '&#x25B6;', label: 'Solve Greedy', hint: '', action: () => { STATE.solverMode = 'greedy'; solve(); closeCommandPalette(); } },
    { group: 'Solver', icon: '&#x25B6;', label: 'Solve ILP', hint: '', action: () => { STATE.solverMode = 'ilp'; solve(); closeCommandPalette(); } },
    { group: 'Solver', icon: '&#x21BB;', label: 'Toggle Auto-Solve', hint: '', action: () => { STATE.autoSolve = !STATE.autoSolve; showToast(STATE.autoSolve ? 'Auto-solve ON' : 'Auto-solve OFF', 'info'); closeCommandPalette(); } },
    { group: 'File', icon: '&#x2913;', label: 'Export JSON', hint: '', action: () => { exportJSON(); closeCommandPalette(); } },
    { group: 'File', icon: '&#x2912;', label: 'Import JSON', hint: '', action: () => { document.getElementById('importFileHidden').click(); closeCommandPalette(); } },
    { group: 'View', icon: '&#x2261;', label: 'Open Drawer', hint: '', action: () => { setDrawerState('half'); closeCommandPalette(); } },
    { group: 'View', icon: '&#x2195;', label: 'Zoom to Fit', hint: '', action: () => { zoomToFit(); closeCommandPalette(); } },
  ];

  function openCommandPalette() {
    STATE.cmdPaletteOpen = true;
    document.getElementById('cmdOverlay').classList.add('open');
    document.getElementById('cmdSearch').value = '';
    document.getElementById('cmdSearch').focus();
    document.getElementById('cmdInlineForm').style.display = 'none';
    renderCommandList('');
  }

  function closeCommandPalette() {
    STATE.cmdPaletteOpen = false;
    document.getElementById('cmdOverlay').classList.remove('open');
  }

  function renderCommandList(query) {
    const list = document.getElementById('cmdList');
    const q = query.toLowerCase();
    const filtered = COMMANDS.filter(c => c.label.toLowerCase().includes(q) || c.group.toLowerCase().includes(q));

    let html = '';
    let lastGroup = '';
    filtered.forEach((c, i) => {
      if (c.group !== lastGroup) { html += `<div class="cmd-group-title">${c.group}</div>`; lastGroup = c.group; }
      html += `<div class="cmd-item${i === 0 ? ' active' : ''}" data-idx="${i}">${c.icon ? `<span class="cmd-icon">${c.icon}</span>` : ''}<span class="cmd-label">${c.label}</span><span class="cmd-hint">${c.hint}</span></div>`;
    });
    list.innerHTML = html;

    list.querySelectorAll('.cmd-item').forEach((el, i) => {
      el.addEventListener('click', () => { filtered[i].action(); });
      el.addEventListener('mouseenter', () => {
        list.querySelectorAll('.cmd-item').forEach(e => e.classList.remove('active'));
        el.classList.add('active');
      });
    });
  }

  function showParamForm(field, label, min, max, step) {
    const form = document.getElementById('cmdInlineForm');
    form.style.display = 'block';
    const current = STATE.model ? STATE.model[field] : min;
    form.innerHTML = `
      <label>${label}</label>
      <div class="cmd-form-row">
        <input type="range" id="cmdParamRange" min="${min}" max="${max}" step="${step}" value="${current}">
        <span class="cmd-form-val" id="cmdParamVal">${current}</span>
      </div>
    `;
    const range = form.querySelector('#cmdParamRange');
    const val = form.querySelector('#cmdParamVal');
    range.addEventListener('input', () => {
      val.textContent = range.value;
      if (STATE.model) { STATE.model[field] = parseInt(range.value); scheduleAutoSolve(); }
    });
    range.focus();
  }

  // Key bindings
  document.getElementById('cmdSearch').addEventListener('input', function() { renderCommandList(this.value); });
  document.getElementById('cmdSearch').addEventListener('keydown', function(e) {
    const items = document.querySelectorAll('#cmdList .cmd-item');
    const activeIdx = [...items].findIndex(i => i.classList.contains('active'));
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      items[activeIdx]?.classList.remove('active');
      items[Math.min(activeIdx + 1, items.length - 1)]?.classList.add('active');
      items[Math.min(activeIdx + 1, items.length - 1)]?.scrollIntoView({ block: 'nearest' });
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      items[activeIdx]?.classList.remove('active');
      items[Math.max(activeIdx - 1, 0)]?.classList.add('active');
      items[Math.max(activeIdx - 1, 0)]?.scrollIntoView({ block: 'nearest' });
    } else if (e.key === 'Enter') {
      e.preventDefault();
      items[activeIdx]?.click();
    }
  });

  document.getElementById('cmdOverlay').addEventListener('click', function(e) {
    if (e.target === this) closeCommandPalette();
  });

  document.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'k') { e.preventDefault(); STATE.cmdPaletteOpen ? closeCommandPalette() : openCommandPalette(); }
    if (e.key === '/' && !e.ctrlKey && !e.metaKey && document.activeElement === document.body) { e.preventDefault(); openCommandPalette(); }
    if (e.key === 'Escape') { closeCommandPalette(); closePopovers(); }
  });

  document.getElementById('cmdBtn').addEventListener('click', openCommandPalette);

  /* ═══════════════════════════════════════════════
     BOTTOM DRAWER
     ═══════════════════════════════════════════════ */
  function setDrawerState(state) {
    const drawer = document.getElementById('drawer');
    drawer.classList.remove('collapsed', 'half', 'full');
    drawer.classList.add(state);
    STATE.drawerState = state;

    const ribbon = document.getElementById('metricsRibbon');
    ribbon.classList.remove('drawer-half', 'drawer-full');
    if (state === 'half') ribbon.classList.add('drawer-half');
    if (state === 'full') ribbon.classList.add('drawer-full');

    // Lazy render active tab
    if (state !== 'collapsed') renderActiveDrawerTab();
  }

  function setDrawerTab(tab) {
    STATE.drawerTab = tab;
    document.querySelectorAll('.drawer-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
    document.querySelectorAll('.drawer-panel').forEach(p => p.classList.toggle('active', p.id === 'panel-' + tab));
    if (STATE.drawerState !== 'collapsed') renderActiveDrawerTab();
  }

  function renderActiveDrawerTab() {
    const m = STATE.model;
    const tab = STATE.drawerTab;

    // Editor tabs work even without a solve result
    if (tab === 'flows') { buildFlowEditor(); return; }
    if (tab === 'model') { buildModelEditor(); return; }

    if (!STATE.currentResult || !m) return;
    const result = STATE.currentResult;
    const switches = m.nodes.filter(n => n.type === 'switch').map(n => ({
      id: n.id, label: n.id, chip: 'Switch', color: getNodeColor(n.id)
    }));

    if (tab === 'gcl') renderGCL(m, result, { ...fcopts, containerId: 'gclContainer', legendId: 'gclLegend' });
    else if (tab === 'delay') renderDelayChart(m, result, { ...fcopts, containerId: 'delayContainer' });
    else if (tab === 'util') renderUtilization(m, result, { containerId: 'utilContainer', beColor: '#e2e8f0' });
    else if (tab === 'switchgcl') renderSwitchGCL(m, result, { containerId: 'switchGclArea', switches, flowColorFn: realFlowColor });
    else if (tab === 'table') renderTable(result, { ...fcopts, containerId: 'pktTableBody' });
    else if (tab === 'json') document.getElementById('jsonOut').textContent = JSON.stringify(result.gcl, null, 2);
  }

  // Drawer tab clicks
  document.querySelectorAll('.drawer-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      setDrawerTab(tab.dataset.tab);
      if (STATE.drawerState === 'collapsed') setDrawerState('half');
    });
  });

  // Drawer handle drag
  let drawerDragStart = null;
  const drawerHandle = document.getElementById('drawerHandle');
  drawerHandle.addEventListener('pointerdown', (e) => {
    drawerDragStart = { y: e.clientY, state: STATE.drawerState };
    e.preventDefault();
  });
  document.addEventListener('pointermove', (e) => {
    if (!drawerDragStart) return;
    const dy = drawerDragStart.y - e.clientY;
    if (Math.abs(dy) > 40) {
      if (dy > 0) {
        // Dragging up
        if (STATE.drawerState === 'collapsed') setDrawerState('half');
        else if (STATE.drawerState === 'half') setDrawerState('full');
      } else {
        // Dragging down
        if (STATE.drawerState === 'full') setDrawerState('half');
        else if (STATE.drawerState === 'half') setDrawerState('collapsed');
      }
      drawerDragStart = null;
    }
  });
  document.addEventListener('pointerup', () => { drawerDragStart = null; });

  // Drawer handle double-click toggles
  drawerHandle.addEventListener('dblclick', () => {
    if (STATE.drawerState === 'collapsed') setDrawerState('half');
    else setDrawerState('collapsed');
  });

  /* ═══════════════════════════════════════════════
     METRICS RIBBON
     ═══════════════════════════════════════════════ */
  function renderMetricsRibbon(model, result) {
    const ribbon = document.getElementById('metricsRibbon');
    if (!result || !model) { ribbon.innerHTML = ''; return; }
    const tsnPkts = result.packetRows.filter(p => p.status !== 'BE');
    const overlapConflicts = Number(result.stats?.overlap_conflicts || 0);
    const fallbackPackets = Number(result.stats?.fallback_packets || 0);
    const allOk = tsnPkts.every(p => p.status === 'OK') && overlapConflicts === 0 && fallbackPackets === 0;
    const avgDelay = tsnPkts.length ? (tsnPkts.reduce((s, p) => s + p.e2e_delay_us, 0) / tsnPkts.length).toFixed(0) : '-';

    const pills = [
      { text: `${model.nodes.length}N`, cls: '' },
      { text: `${model.links.length}L`, cls: '' },
      { text: `${model.flows.length}F`, cls: '' },
      { text: result.method.split('(')[0].trim(), cls: '' },
      { text: `${result.objective}us`, cls: 'warn' },
      { text: `${result.worst_util_percent}%`, cls: result.worst_util_percent > 50 ? 'warn' : '' },
      { text: allOk ? 'OK' : 'MISS', cls: allOk ? 'ok' : 'miss' }
    ];
    ribbon.innerHTML = pills.map(p => `<span class="metric-pill ${p.cls}">${p.text}</span>`).join('');
  }

  /* ═══════════════════════════════════════════════
     SOLVER
     ═══════════════════════════════════════════════ */
  let solveTimer = null;

  function scheduleAutoSolve() {
    if (!STATE.autoSolve) return;
    clearTimeout(solveTimer);
    solveTimer = setTimeout(() => solve(), 500);
  }

  async function solve() {
    if (!STATE.model) return;
    const mode = STATE.solverMode;
    const dot = document.getElementById('solveDot');
    dot.classList.add('solving');

    try {
      if (mode === 'greedy' || mode === 'both') {
        const t0 = performance.now();
        const greedyResult = solveGreedy(STATE.model);
        const wallMs = Math.round(performance.now() - t0);
        STATE.currentResult = greedyResult;
        renderAll();
        pushHistory('greedy', greedyResult, wallMs);
        renderHistory();
        showToast(`Greedy: ${wallMs}ms, ${greedyResult.packetRows.length} pkts`, 'success');
      }
      if ((mode === 'ilp' || mode === 'both') && STATE.glpk) {
        const t1 = performance.now();
        const ilpResult = await solveILP(STATE.model, STATE.glpk, { tmlim: STATE.ilpTimeout });
        const wallMs = Math.round(performance.now() - t1);
        STATE.currentResult = ilpResult;
        renderAll();
        pushHistory('ilp', ilpResult, wallMs);
        renderHistory();
        showToast(`ILP: ${wallMs}ms, ${ilpResult.stats.variables} vars`, 'success');
      } else if (mode === 'ilp' && !STATE.glpk) {
        showToast('GLPK not loaded, using Greedy', 'error');
        STATE.currentResult = solveGreedy(STATE.model);
        renderAll();
      }
    } catch (e) {
      showToast('Error: ' + e.message, 'error', 5000);
      console.error(e);
    }
    dot.classList.remove('solving');
  }

  /* ═══════════════════════════════════════════════
     FLOW & MODEL EDITORS
     ═══════════════════════════════════════════════ */
  function txTimeUs(bytes, rateMbps) {
    return (bytes * 8) / rateMbps;
  }

  function pktsPerCycle(flow, model) {
    return Math.ceil(model.cycle_time_us / flow.period_us);
  }

  function buildFlowEditor() {
    const panel = document.getElementById('panel-flows');
    const m = STATE.model;
    if (!m) { panel.innerHTML = '<div style="color:var(--text3);font-size:0.8rem;">No model loaded</div>'; return; }

    const nodeIds = m.nodes.map(n => n.id);
    let html = '<div class="flow-editor-list">';
    m.flows.forEach((f, idx) => {
      const color = realFlowColor(f.id);
      const linkRate = m.links.length ? m.links[0].rate_mbps : 1000;
      const tx = txTimeUs(f.payload_bytes, linkRate).toFixed(1);
      const pkts = pktsPerCycle(f, m);
      const sel = STATE.selectedFlow === f.id ? ' selected' : '';
      html += `<div class="flow-card${sel}" data-flow-idx="${idx}" data-flow-id="${f.id}">
        <div class="flow-card-header">
          <div class="flow-card-tag" style="background:${color};"></div>
          <span class="flow-card-id">${f.id}</span>
          <button class="flow-card-del" data-del-idx="${idx}" title="Delete flow">&times;</button>
        </div>
        <div class="flow-card-grid">
          <label>Src</label>
          <select data-field="src" data-idx="${idx}">
            ${nodeIds.map(n => `<option value="${n}"${n===f.src?' selected':''}>${n}</option>`).join('')}
          </select>
          <label>Dst</label>
          <select data-field="dst" data-idx="${idx}">
            ${nodeIds.map(n => `<option value="${n}"${n===f.dst?' selected':''}>${n}</option>`).join('')}
          </select>
          <label>Priority</label>
          <select data-field="priority" data-idx="${idx}">
            ${[0,1,2,3,4,5,6,7].map(p => `<option value="${p}"${p===f.priority?' selected':''}>P${p}</option>`).join('')}
          </select>
          <label>k_paths</label>
          <select data-field="k_paths" data-idx="${idx}">
            ${[1,2,3,4].map(k => `<option value="${k}"${k===f.k_paths?' selected':''}>${k}</option>`).join('')}
          </select>
          <label>Payload</label>
          <input type="number" data-field="payload_bytes" data-idx="${idx}" value="${f.payload_bytes}" min="64" max="1048576" step="64">
          <label>Period (us)</label>
          <input type="number" data-field="period_us" data-idx="${idx}" value="${f.period_us}" min="100" max="1000000" step="100">
          <label>Deadline (us)</label>
          <input type="number" data-field="deadline_us" data-idx="${idx}" value="${f.deadline_us}" min="100" max="1000000" step="100">
        </div>
        <div class="flow-computed">tx=${tx}us &middot; ${pkts} pkt/cycle</div>
      </div>`;
    });
    html += `<button class="flow-add-btn" id="flowAddBtn">+ Add Flow</button></div>`;
    panel.innerHTML = html;

    // Event: card click → select flow
    panel.querySelectorAll('.flow-card').forEach(card => {
      card.addEventListener('click', (e) => {
        if (e.target.closest('.flow-card-del') || e.target.closest('select') || e.target.closest('input')) return;
        const fid = card.dataset.flowId;
        if (STATE.selectedFlow === fid) deselectFlow();
        else selectFlow(fid);
      });
    });

    // Event: delete flow
    panel.querySelectorAll('.flow-card-del').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const idx = parseInt(btn.dataset.delIdx);
        const fid = m.flows[idx].id;
        m.flows.splice(idx, 1);
        if (STATE.selectedFlow === fid) STATE.selectedFlow = null;
        scheduleAutoSolve();
        buildFlowEditor();
        showToast(`Deleted flow ${fid}`, 'info');
      });
    });

    // Event: field changes
    panel.querySelectorAll('.flow-card-grid select, .flow-card-grid input').forEach(el => {
      const handler = () => {
        const idx = parseInt(el.dataset.idx);
        const field = el.dataset.field;
        const flow = m.flows[idx];
        if (!flow) return;
        if (field === 'priority' || field === 'k_paths') flow[field] = parseInt(el.value);
        else if (field === 'payload_bytes' || field === 'period_us' || field === 'deadline_us') flow[field] = parseInt(el.value) || flow[field];
        else flow[field] = el.value;
        // Update computed
        const card = el.closest('.flow-card');
        const linkRate = m.links.length ? m.links[0].rate_mbps : 1000;
        const comp = card.querySelector('.flow-computed');
        if (comp) comp.textContent = `tx=${txTimeUs(flow.payload_bytes, linkRate).toFixed(1)}us \u00b7 ${pktsPerCycle(flow, m)} pkt/cycle`;
        scheduleAutoSolve();
      };
      el.addEventListener('change', handler);
      if (el.tagName === 'INPUT') el.addEventListener('input', handler);
    });

    // Event: add flow
    document.getElementById('flowAddBtn')?.addEventListener('click', () => {
      addFlow();
      buildFlowEditor();
    });
  }

  function buildModelEditor() {
    const panel = document.getElementById('panel-model');
    const m = STATE.model;
    if (!m) { panel.innerHTML = '<div style="color:var(--text3);font-size:0.8rem;">No model loaded</div>'; return; }

    const nodeIds = m.nodes.map(n => n.id);
    let html = '';

    // ① Nodes
    html += `<div class="model-section" id="msNodes">
      <div class="model-section-header"><span class="chevron">&#9660;</span> Nodes (${m.nodes.length})</div>
      <div class="model-section-body">`;
    m.nodes.forEach((n, i) => {
      const c = getNodeColor(n.id);
      html += `<div class="editor-item">
        <div class="ed-dot" style="background:${c};"></div>
        <input type="text" value="${n.id}" data-node-idx="${i}" data-field="id" style="width:100px;">
        <select data-node-idx="${i}" data-field="type">
          <option value="switch"${n.type==='switch'?' selected':''}>switch</option>
          <option value="endstation"${n.type==='endstation'?' selected':''}>endstation</option>
        </select>
        <button class="ed-del" data-node-del="${i}">&times;</button>
      </div>`;
    });
    html += `<button class="editor-add-btn" id="modelAddNode">+ Add Node</button></div></div>`;

    // ② Links
    html += `<div class="model-section" id="msLinks">
      <div class="model-section-header"><span class="chevron">&#9660;</span> Links (${m.links.length})</div>
      <div class="model-section-body">`;
    m.links.forEach((l, i) => {
      html += `<div class="editor-item">
        <select data-link-idx="${i}" data-field="from" style="width:80px;">
          ${nodeIds.map(n => `<option value="${n}"${n===l.from?' selected':''}>${n}</option>`).join('')}
        </select>
        <span style="color:var(--text3);">&rarr;</span>
        <select data-link-idx="${i}" data-field="to" style="width:80px;">
          ${nodeIds.map(n => `<option value="${n}"${n===l.to?' selected':''}>${n}</option>`).join('')}
        </select>
        <input type="number" data-link-idx="${i}" data-field="rate_mbps" value="${l.rate_mbps}" style="width:55px;" title="Mbps">
        <input type="number" data-link-idx="${i}" data-field="prop_delay_us" value="${l.prop_delay_us}" step="0.1" style="width:45px;" title="Delay(us)">
        <button class="ed-del" data-link-del="${i}">&times;</button>
      </div>`;
    });
    html += `<button class="editor-add-btn" id="modelAddLink">+ Add Link</button></div></div>`;

    // ③ Global Parameters
    html += `<div class="model-section" id="msParams">
      <div class="model-section-header"><span class="chevron">&#9660;</span> Global Parameters</div>
      <div class="model-section-body">
        <div class="slider-row"><label>Cycle Time</label><input type="range" id="msCycleTime" min="1000" max="50000" step="100" value="${m.cycle_time_us}"><span class="slider-val" id="msCycleVal">${m.cycle_time_us}us</span></div>
        <div class="slider-row"><label>Guard Band</label><input type="range" id="msGuardBand" min="0" max="20" step="1" value="${m.guard_band_us}"><span class="slider-val" id="msGuardVal">${m.guard_band_us}us</span></div>
        <div class="slider-row"><label>Proc Delay</label><input type="range" id="msProcDelay" min="0" max="20" step="1" value="${m.processing_delay_us}"><span class="slider-val" id="msProcVal">${m.processing_delay_us}us</span></div>
      </div></div>`;

    // ④ Solver Settings
    html += `<div class="model-section" id="msSolver">
      <div class="model-section-header"><span class="chevron">&#9660;</span> Solver Settings</div>
      <div class="model-section-body">
        <div style="margin-bottom:8px;font-size:0.72rem;font-weight:600;color:var(--text2);">Mode</div>
        <div class="radio-group" id="solverModeGroup">
          <span class="radio-pill${STATE.solverMode==='greedy'?' active':''}" data-mode="greedy">Greedy</span>
          <span class="radio-pill${STATE.solverMode==='ilp'?' active':''}" data-mode="ilp">ILP</span>
          <span class="radio-pill${STATE.solverMode==='both'?' active':''}" data-mode="both">Both</span>
        </div>
        <div class="slider-row" style="margin-top:8px;"><label>ILP Timeout</label><input type="range" id="msIlpTimeout" min="5" max="120" step="5" value="${STATE.ilpTimeout}"><span class="slider-val" id="msTimeoutVal">${STATE.ilpTimeout}s</span></div>
        <div class="toggle-row">
          <label class="toggle-switch"><input type="checkbox" id="msAutoSolve" ${STATE.autoSolve?'checked':''}><span class="toggle-track"></span></label>
          Auto-solve
        </div>
        <div class="solver-actions">
          <button class="popover-btn primary" id="msSolveNow">Solve Now</button>
          <button class="popover-btn" id="msReset">Reset</button>
        </div>
      </div></div>`;

    panel.innerHTML = html;

    // Section collapse toggles
    panel.querySelectorAll('.model-section-header').forEach(hdr => {
      hdr.addEventListener('click', () => {
        hdr.parentElement.classList.toggle('collapsed');
      });
    });

    // Node edits
    panel.querySelectorAll('[data-node-idx][data-field]').forEach(el => {
      el.addEventListener('change', () => {
        const idx = parseInt(el.dataset.nodeIdx);
        const field = el.dataset.field;
        const node = m.nodes[idx];
        if (!node) return;
        if (field === 'id') {
          const newId = el.value.trim();
          if (!newId) return;
          const oldId = node.id;
          node.id = newId;
          m.links.forEach(l => { if (l.from === oldId) l.from = newId; if (l.to === oldId) l.to = newId; });
          m.flows.forEach(f => { if (f.src === oldId) f.src = newId; if (f.dst === oldId) f.dst = newId; });
        } else {
          node[field] = el.value;
        }
        scheduleAutoSolve();
      });
    });

    // Node delete
    panel.querySelectorAll('[data-node-del]').forEach(btn => {
      btn.addEventListener('click', () => {
        const idx = parseInt(btn.dataset.nodeDel);
        const nid = m.nodes[idx].id;
        m.nodes.splice(idx, 1);
        m.links = m.links.filter(l => l.from !== nid && l.to !== nid);
        m.flows = m.flows.filter(f => f.src !== nid && f.dst !== nid);
        scheduleAutoSolve();
        buildModelEditor();
        showToast(`Deleted node ${nid}`, 'info');
      });
    });

    // Add node
    panel.querySelector('#modelAddNode')?.addEventListener('click', () => {
      addNodeAt(window.innerWidth / 2, window.innerHeight / 2);
      buildModelEditor();
    });

    // Link edits
    panel.querySelectorAll('[data-link-idx][data-field]').forEach(el => {
      el.addEventListener('change', () => {
        const idx = parseInt(el.dataset.linkIdx);
        const field = el.dataset.field;
        const link = m.links[idx];
        if (!link) return;
        if (field === 'rate_mbps') link.rate_mbps = parseFloat(el.value) || link.rate_mbps;
        else if (field === 'prop_delay_us') link.prop_delay_us = parseFloat(el.value) || 0;
        else link[field] = el.value;
        scheduleAutoSolve();
      });
    });

    // Link delete
    panel.querySelectorAll('[data-link-del]').forEach(btn => {
      btn.addEventListener('click', () => {
        const idx = parseInt(btn.dataset.linkDel);
        m.links.splice(idx, 1);
        scheduleAutoSolve();
        buildModelEditor();
        showToast('Deleted link', 'info');
      });
    });

    // Add link
    panel.querySelector('#modelAddLink')?.addEventListener('click', () => {
      if (m.nodes.length < 2) { showToast('Need at least 2 nodes', 'error'); return; }
      addLinkBetween(m.nodes[0].id, m.nodes[1].id);
      buildModelEditor();
    });

    // Global parameter sliders
    const bindSlider = (id, valId, field, suffix, parser) => {
      const slider = panel.querySelector('#' + id);
      const valEl = panel.querySelector('#' + valId);
      if (!slider || !valEl) return;
      slider.addEventListener('input', () => {
        const v = parser(slider.value);
        m[field] = v;
        valEl.textContent = v + suffix;
        scheduleAutoSolve();
      });
    };
    bindSlider('msCycleTime', 'msCycleVal', 'cycle_time_us', 'us', parseInt);
    bindSlider('msGuardBand', 'msGuardVal', 'guard_band_us', 'us', parseInt);
    bindSlider('msProcDelay', 'msProcVal', 'processing_delay_us', 'us', parseInt);

    // Solver mode
    panel.querySelectorAll('#solverModeGroup .radio-pill').forEach(pill => {
      pill.addEventListener('click', () => {
        STATE.solverMode = pill.dataset.mode;
        panel.querySelectorAll('#solverModeGroup .radio-pill').forEach(p => p.classList.toggle('active', p.dataset.mode === STATE.solverMode));
      });
    });

    // ILP timeout
    const toSlider = panel.querySelector('#msIlpTimeout');
    const toVal = panel.querySelector('#msTimeoutVal');
    if (toSlider && toVal) {
      toSlider.addEventListener('input', () => {
        STATE.ilpTimeout = parseInt(toSlider.value);
        toVal.textContent = STATE.ilpTimeout + 's';
      });
    }

    // Auto-solve toggle
    panel.querySelector('#msAutoSolve')?.addEventListener('change', function() {
      STATE.autoSolve = this.checked;
      showToast(STATE.autoSolve ? 'Auto-solve ON' : 'Auto-solve OFF', 'info');
    });

    // Solve Now / Reset
    panel.querySelector('#msSolveNow')?.addEventListener('click', () => solve());
    panel.querySelector('#msReset')?.addEventListener('click', () => {
      loadPreset(STATE.currentPreset);
      buildModelEditor();
    });
  }

  /* ═══════════════════════════════════════════════
     FLOW SELECTION & PATH HIGHLIGHT
     ═══════════════════════════════════════════════ */
  function selectFlow(flowId) {
    STATE.selectedFlow = flowId;
    applyFlowHighlight();
    // Update flow cards in drawer
    document.querySelectorAll('.flow-card').forEach(c => {
      c.classList.toggle('selected', c.dataset.flowId === flowId);
    });
    // Update sidebar
    document.querySelectorAll('.fs-flow').forEach(el => {
      el.classList.toggle('active', el.dataset.fid === flowId);
    });
    // Update flow path polylines
    if (STATE.zoomLayer) {
      STATE.zoomLayer.selectAll('.flow-path-line')
        .classed('active', function() { return this.getAttribute('data-flow-id') === flowId; })
        .classed('dimmed', function() { return this.getAttribute('data-flow-id') !== flowId; });
    }
    SelectionBus.emit('flow:highlight', { flowId });
  }

  function deselectFlow() {
    STATE.selectedFlow = null;
    clearFlowHighlight();
    closePopovers();
    document.querySelectorAll('.flow-card').forEach(c => c.classList.remove('selected'));
    document.querySelectorAll('.fs-flow').forEach(el => el.classList.remove('active'));
    // Reset flow path polylines
    if (STATE.zoomLayer) {
      STATE.zoomLayer.selectAll('.flow-path-line')
        .classed('active', false).classed('dimmed', false);
    }
    SelectionBus.emit('flow:highlight', { flowId: null });
  }

  function applyFlowHighlight() {
    if (!STATE.zoomLayer || !STATE.currentResult || !STATE.selectedFlow) return;
    const flowId = STATE.selectedFlow;
    const result = STATE.currentResult;
    const m = STATE.model;

    // Find the path links for the selected flow
    const pathLinkKeys = new Set();
    const pathNodeIds = new Set();
    result.packetRows.filter(p => p.flow_id === flowId).forEach(p => {
      if (!p.hops) return;
      p.hops.forEach(h => {
        const link = m.links.find(l => l.id === h.link_id);
        if (link) {
          pathLinkKeys.add([link.from, link.to].sort().join('-'));
          pathNodeIds.add(link.from);
          pathNodeIds.add(link.to);
        }
      });
    });

    const flowColor = realFlowColor(flowId);

    // Dim/highlight links
    STATE.zoomLayer.selectAll('.link-g').each(function(d) {
      const isOnPath = pathLinkKeys.has(d.key);
      d3.select(this).select('.topo-link-line')
        .classed('flow-highlighted', isOnPath)
        .classed('dimmed', !isOnPath);
      if (isOnPath) {
        d3.select(this).select('.topo-link-line')
          .attr('stroke', flowColor)
          .attr('stroke-width', 6);
      }
      d3.select(this).select('.topo-link-hit')
        .classed('dimmed', !isOnPath);
    });

    // Dim/highlight nodes
    STATE.zoomLayer.selectAll('.topo-node-g').each(function(d) {
      const isOnPath = pathNodeIds.has(d.id);
      d3.select(this).classed('dimmed', !isOnPath);
    });
  }

  function clearFlowHighlight() {
    if (!STATE.zoomLayer) return;
    STATE.zoomLayer.selectAll('.link-g').each(function() {
      d3.select(this).select('.topo-link-line')
        .classed('flow-highlighted', false)
        .classed('dimmed', false);
      d3.select(this).select('.topo-link-hit')
        .classed('dimmed', false);
    });
    STATE.zoomLayer.selectAll('.topo-node-g').classed('dimmed', false);
  }

  /* ── Update flow path polylines during node drag ── */
  function updateFlowPathsDrag(positions, zoomLayer) {
    if (!STATE._flowPaths) return;
    zoomLayer.selectAll('.flow-path-line').each(function(d, i) {
      const fp = STATE._flowPaths[i];
      if (!fp) return;
      const pts = fp.pathNodes.map(id => positions[id]).filter(Boolean);
      if (pts.length < 2) return;
      const offset = (i - STATE._flowPaths.length / 2) * 3;
      const lineData = pts.map((pt, j) => {
        if (j === 0 || j === pts.length - 1) return `${pt.x},${pt.y}`;
        const prev = pts[j - 1];
        const next = pts[Math.min(j + 1, pts.length - 1)];
        const dx = next.x - prev.x, dy = next.y - prev.y;
        const len = Math.hypot(dx, dy) || 1;
        const nx = -dy / len * offset, ny = dx / len * offset;
        return `${pt.x + nx},${pt.y + ny}`;
      });
      d3.select(this).attr('points', lineData.join(' '));
    });
  }

  /* ═══════════════════════════════════════════════
     FLOATING FLOW SIDEBAR (on topology)
     ═══════════════════════════════════════════════ */
  function renderFlowSidebar() {
    const sb = document.getElementById('flowSidebar');
    const m = STATE.model;
    if (!sb || !m) return;

    let html = '<div class="fs-title">Flows</div>';
    m.flows.forEach((f, i) => {
      const color = realFlowColor(f.id);
      const active = STATE.selectedFlow === f.id ? ' active' : '';
      const short = f.id.length > 18 ? f.id.slice(0, 16) + '..' : f.id;
      html += `<div class="fs-flow${active}" data-fid="${f.id}">
        <div class="fs-dot" style="background:${color};"></div>
        <span class="fs-name" title="${f.id}">${short}</span>
        <span class="fs-info">${f.src.slice(-3)}&rarr;${f.dst.slice(-3)}</span>
      </div>`;
    });
    html += '<button class="fs-add" id="fsAddFlow">+ Flow</button>';
    sb.innerHTML = html;

    // Click on flow → select + show popover on topology
    sb.querySelectorAll('.fs-flow').forEach(el => {
      el.addEventListener('click', () => {
        const fid = el.dataset.fid;
        if (STATE.selectedFlow === fid) {
          deselectFlow();
        } else {
          selectFlow(fid);
          // Position the popover near the flow's source node
          const flow = m.flows.find(f => f.id === fid);
          if (flow) {
            const pos = STATE.nodePositions[flow.src];
            if (pos) {
              const t = STATE.zoomTransform;
              const sx = pos.x * t.k + t.x + 40;
              const sy = pos.y * t.k + t.y - 20;
              showFlowPopover(fid, { x: sx, y: sy });
            }
          }
        }
      });
    });

    sb.querySelector('#fsAddFlow')?.addEventListener('click', () => {
      addFlow();
      renderFlowSidebar();
    });
  }

  /* ═══════════════════════════════════════════════
     FLOW PATH POLYLINES ON TOPOLOGY
     ═══════════════════════════════════════════════ */
  function drawFlowPaths(model, result, zoomLayer, positions) {
    if (!result) return;
    // Remove old flow paths and append new layer (sits between links and nodes)
    zoomLayer.selectAll('.flow-paths-layer').remove();
    const pathG = zoomLayer.append('g').attr('class', 'flow-paths-layer');

    const seenFlows = new Set();
    const flowPaths = [];
    result.packetRows.forEach(p => {
      if (seenFlows.has(p.flow_id)) return;
      seenFlows.add(p.flow_id);
      const pathNodes = [];
      p.hops.forEach(h => {
        const link = model.links.find(l => l.id === h.link_id);
        if (link) {
          if (pathNodes.length === 0) pathNodes.push(link.from);
          pathNodes.push(link.to);
        }
      });
      if (pathNodes.length < 2) return;
      const points = pathNodes.map(id => positions[id]).filter(Boolean);
      if (points.length < 2) return;
      flowPaths.push({ flowId: p.flow_id, points, pathNodes });
    });

    // Draw each flow path as a polyline with slight offset to avoid overlap
    flowPaths.forEach((fp, idx) => {
      const color = realFlowColor(fp.flowId);
      const offset = (idx - flowPaths.length / 2) * 3; // slight perpendicular offset

      const lineData = fp.points.map((pt, i) => {
        if (i === 0 || i === fp.points.length - 1) return `${pt.x},${pt.y}`;
        // Add perpendicular offset for middle segments
        const prev = fp.points[i - 1];
        const next = fp.points[Math.min(i + 1, fp.points.length - 1)];
        const dx = next.x - prev.x, dy = next.y - prev.y;
        const len = Math.hypot(dx, dy) || 1;
        const nx = -dy / len * offset, ny = dx / len * offset;
        return `${pt.x + nx},${pt.y + ny}`;
      });

      const isActive = STATE.selectedFlow === fp.flowId;
      const isDimmed = STATE.selectedFlow && STATE.selectedFlow !== fp.flowId;

      pathG.append('polyline')
        .attr('class', 'flow-path-line' + (isActive ? ' active' : '') + (isDimmed ? ' dimmed' : ''))
        .attr('points', lineData.join(' '))
        .attr('stroke', color)
        .attr('data-flow-id', fp.flowId)
        .on('click', (event) => {
          event.stopPropagation();
          selectFlow(fp.flowId);
          showFlowPopover(fp.flowId, { x: event.clientX, y: event.clientY });
        });
    });

    STATE._flowPaths = flowPaths; // store for drag updates
  }

  /* ═══════════════════════════════════════════════
     FLOW EDIT POPOVER (on canvas)
     ═══════════════════════════════════════════════ */
  function showFlowPopover(flowId, screenPos) {
    closePopovers();
    const m = STATE.model;
    const flow = m.flows.find(f => f.id === flowId);
    if (!flow) return;

    const nodeIds = m.nodes.map(n => n.id);
    const color = realFlowColor(flowId);
    const linkRate = m.links.length ? m.links[0].rate_mbps : 1000;
    const tx = txTimeUs(flow.payload_bytes, linkRate).toFixed(1);
    const pkts = pktsPerCycle(flow, m);

    const div = document.createElement('div');
    div.className = 'flow-popover';
    div.style.left = Math.min(screenPos.x, window.innerWidth - 280) + 'px';
    div.style.top = Math.min(screenPos.y, window.innerHeight - 380) + 'px';

    div.innerHTML = `
      <div class="fp-header">
        <div class="fp-tag" style="background:${color};"></div>
        <span class="fp-id">${flowId}</span>
        <button class="flow-card-del" id="fpDel" title="Delete flow">&times;</button>
      </div>
      <div class="fp-grid">
        <label>Source</label>
        <select data-fp="src">${nodeIds.map(n => `<option value="${n}"${n===flow.src?' selected':''}>${n}</option>`).join('')}</select>
        <label>Destination</label>
        <select data-fp="dst">${nodeIds.map(n => `<option value="${n}"${n===flow.dst?' selected':''}>${n}</option>`).join('')}</select>
        <label>Priority</label>
        <select data-fp="priority">${[0,1,2,3,4,5,6,7].map(p => `<option value="${p}"${p===flow.priority?' selected':''}>P${p}</option>`).join('')}</select>
        <label>k_paths</label>
        <select data-fp="k_paths">${[1,2,3,4].map(k => `<option value="${k}"${k===flow.k_paths?' selected':''}>${k}</option>`).join('')}</select>
        <label>Payload (B)</label>
        <input type="number" data-fp="payload_bytes" value="${flow.payload_bytes}" min="64" max="1048576" step="64">
        <label>Period (us)</label>
        <input type="number" data-fp="period_us" value="${flow.period_us}" min="100" max="1000000" step="100">
        <label>Deadline (us)</label>
        <input type="number" data-fp="deadline_us" value="${flow.deadline_us}" min="100" max="1000000" step="100">
      </div>
      <div class="fp-computed" id="fpComputed">tx=${tx}us &middot; ${pkts} pkt/cycle</div>
      <div class="popover-actions">
        <button class="popover-btn primary" id="fpClose">Done</button>
      </div>
    `;
    document.getElementById('popoverContainer').appendChild(div);

    // Wire up change events → live update
    div.querySelectorAll('[data-fp]').forEach(el => {
      const handler = () => {
        const field = el.dataset.fp;
        if (field === 'priority' || field === 'k_paths') flow[field] = parseInt(el.value);
        else if (field === 'payload_bytes' || field === 'period_us' || field === 'deadline_us') flow[field] = parseInt(el.value) || flow[field];
        else flow[field] = el.value;
        // Update computed
        const rate = m.links.length ? m.links[0].rate_mbps : 1000;
        const comp = div.querySelector('#fpComputed');
        if (comp) comp.textContent = `tx=${txTimeUs(flow.payload_bytes, rate).toFixed(1)}us \u00b7 ${pktsPerCycle(flow, m)} pkt/cycle`;
        scheduleAutoSolve();
        renderFlowSidebar();
      };
      el.addEventListener('change', handler);
      if (el.tagName === 'INPUT') el.addEventListener('input', handler);
    });

    div.querySelector('#fpDel').onclick = () => {
      const idx = m.flows.findIndex(f => f.id === flowId);
      if (idx >= 0) m.flows.splice(idx, 1);
      if (STATE.selectedFlow === flowId) STATE.selectedFlow = null;
      closePopovers();
      scheduleAutoSolve();
      renderFlowSidebar();
      showToast(`Deleted flow ${flowId}`, 'info');
    };

    div.querySelector('#fpClose').onclick = closePopovers;

    // Click-away dismiss
    setTimeout(() => {
      document.addEventListener('pointerdown', function dismiss(e) {
        if (!div.contains(e.target)) { closePopovers(); document.removeEventListener('pointerdown', dismiss); }
      });
    }, 50);
  }

  /* ═══════════════════════════════════════════════
     SOLUTION HISTORY DISPLAY
     ═══════════════════════════════════════════════ */
  function renderHistory() {
    const container = document.getElementById('historyChips');
    if (!container) return;
    container.innerHTML = STATE.history.map((h, i) => {
      const isLatest = i === STATE.history.length - 1;
      return `<span class="history-chip${isLatest ? ' latest' : ''}" data-hist-idx="${i}">${h.timestamp} ${h.method.toUpperCase()} ${h.objective}us</span>`;
    }).join('');

    container.querySelectorAll('.history-chip').forEach(chip => {
      chip.addEventListener('click', () => {
        const idx = parseInt(chip.dataset.histIdx);
        const h = STATE.history[idx];
        if (!h) return;
        STATE.model = deepClone(h.model);
        STATE.currentResult = deepClone(h.result);
        renderAll();
        if (STATE.drawerTab === 'flows') buildFlowEditor();
        if (STATE.drawerTab === 'model') buildModelEditor();
        showToast(`Restored: ${h.method} @ ${h.timestamp}`, 'info');
      });
    });
  }

  /* ═══════════════════════════════════════════════
     RENDER ALL
     ═══════════════════════════════════════════════ */
  function renderAll() {
    if (!STATE.model) return;
    renderCustomTopology(STATE.model, STATE.currentResult);
    renderMetricsRibbon(STATE.model, STATE.currentResult);
    renderFlowSidebar();
    if (STATE.drawerState !== 'collapsed') renderActiveDrawerTab();
    // Re-apply flow highlight after topology re-render
    if (STATE.selectedFlow) setTimeout(() => applyFlowHighlight(), 50);
  }

  /* ═══════════════════════════════════════════════
     MODEL OPERATIONS
     ═══════════════════════════════════════════════ */
  function loadPreset(key) {
    const p = PRESETS[key];
    STATE.model = deepClone(p.model);
    STATE.currentPreset = key;
    STATE.selectedFlow = null;
    rebuild3D(p);
    // Update preset pills
    document.querySelectorAll('.preset-pill').forEach(pill => pill.classList.toggle('active', pill.dataset.preset === key));
    // Rebuild editor tabs if active
    if (STATE.drawerTab === 'flows') buildFlowEditor();
    if (STATE.drawerTab === 'model') buildModelEditor();
    renderFlowSidebar();
    scheduleAutoSolve();
    showToast(`Loaded: ${key}`, 'info');
  }

  function addFlow() {
    const m = STATE.model;
    if (m.nodes.length < 2) { showToast('Need at least 2 nodes', 'error'); return; }
    const src = m.nodes[0].id;
    const dst = m.nodes[m.nodes.length - 1].id;
    const newId = 'f_custom_' + (m.flows.length + 1);
    m.flows.push({ id: newId, priority: 6, payload_bytes: 4096, period_us: 10000, deadline_us: 5000, traffic_type: 'custom', src, dst, k_paths: 2 });
    scheduleAutoSolve();
    showToast(`Added flow ${newId}`, 'info');
  }

  function zoomToFit() {
    if (!STATE.topoZoom || !STATE.model) return;
    const svg = d3.select('#topoSvg');
    const W = window.innerWidth, H = window.innerHeight;
    const pos = STATE.nodePositions;
    const xs = Object.values(pos).map(p => p.x);
    const ys = Object.values(pos).map(p => p.y);
    if (!xs.length) return;
    const minX = Math.min(...xs) - 60, maxX = Math.max(...xs) + 60;
    const minY = Math.min(...ys) - 60, maxY = Math.max(...ys) + 60;
    const bw = maxX - minX, bh = maxY - minY;
    const scale = Math.min(W / bw, H / bh) * 0.85;
    const tx = W / 2 - (minX + bw / 2) * scale;
    const ty = H / 2 - (minY + bh / 2) * scale;
    svg.transition().duration(500).call(STATE.topoZoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
  }

  /* ═══════════════════════════════════════════════
     SOLUTION HISTORY
     ═══════════════════════════════════════════════ */
  function pushHistory(method, result, wallMs) {
    STATE.history.push({
      timestamp: new Date().toLocaleTimeString(),
      method, objective: result.objective || 0,
      model: deepClone(STATE.model), result: deepClone(result), wallMs
    });
    if (STATE.history.length > 5) STATE.history.shift();
  }

  /* ═══════════════════════════════════════════════
     EXPORT / IMPORT
     ═══════════════════════════════════════════════ */
  function exportJSON() {
    if (!STATE.model) return;
    const blob = new Blob([JSON.stringify(STATE.model, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'tsn-model-' + Date.now() + '.json';
    a.click();
    URL.revokeObjectURL(a.href);
    showToast('Model exported', 'success');
  }

  // Hidden file input for import
  const importInput = document.createElement('input');
  importInput.type = 'file'; importInput.accept = '.json'; importInput.id = 'importFileHidden';
  importInput.style.display = 'none';
  document.body.appendChild(importInput);
  importInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (evt) => {
      try {
        const imported = JSON.parse(evt.target.result);
        if (!imported.nodes || !imported.links || !imported.flows) {
          showToast('Invalid model', 'error'); return;
        }
        STATE.model = imported;
        scheduleAutoSolve();
        showToast('Model imported', 'success');
      } catch (err) { showToast('Import error: ' + err.message, 'error'); }
    };
    reader.readAsText(file);
    e.target.value = '';
  });

  /* ═══════════════════════════════════════════════
     EVENT BINDINGS
     ═══════════════════════════════════════════════ */

  // Preset pills
  document.querySelectorAll('.preset-pill').forEach(pill => {
    pill.addEventListener('click', () => loadPreset(pill.dataset.preset));
  });

  // Solve button
  document.getElementById('solveBtn').addEventListener('click', () => solve());

  // Resize
  let resizeTimer;
  window.addEventListener('resize', () => { clearTimeout(resizeTimer); resizeTimer = setTimeout(renderAll, 200); });

  /* ═══════════════════════════════════════════════
     INITIALIZATION
     ═══════════════════════════════════════════════ */
  initTooltip();
  loadPreset('standard');
  try { init3D(); } catch(e) { console.warn('3D init error:', e); }
  initPiP();

  // GLPK load
  (async () => {
    const badge = document.getElementById('engineBadge');
    try {
      const GLPK = (await import('./vendor/glpk.js')).default;
      STATE.glpk = await GLPK();
      const ver = typeof STATE.glpk.version === 'function' ? STATE.glpk.version() : (STATE.glpk.version || '?');
      badge.className = 'engine-badge ready';
      badge.innerHTML = `&#9679; GLPK ${ver}`;
      showToast('GLPK loaded', 'success');
    } catch (e) {
      console.warn('GLPK load failed:', e);
      badge.className = 'engine-badge ready';
      badge.innerHTML = '&#9679; Greedy Only';
    }
  })();
  </script>
</body>
</html>
