<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TSN/GCL Custom Playground</title>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <style>
    /* ═══════════════════════════════════════════════
       Light Theme Override
       ═══════════════════════════════════════════════ */
    :root {
      --bg: #f8f9fa; --bg2: #f0f2f5;
      --card: #ffffff; --card-hi: #f8fafc;
      --border: rgba(59,130,246,0.2); --border-hi: rgba(59,130,246,0.4);
      --text: #1e293b; --text2: #475569; --text3: #64748b;
      --cyan: #0891b2; --blue: #3B82F6; --purple: #7c3aed;
      --orange: #d97706; --red: #dc2626; --green: #059669; --pink: #db2777;
      --flow-ctrl: #3B82F6; --flow-sensor: #059669; --flow-video: #db2777;
      --guard: #d97706; --be: #e2e8f0;
      --sidebar-w: 380px;
    }
    body {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 50%, #dee2e6 100%);
      overflow-x: hidden;
    }
    .bg-grid {
      background-image:
        radial-gradient(ellipse 80% 50% at 50% -20%, rgba(59,130,246,0.06), transparent),
        radial-gradient(ellipse 60% 40% at 80% 100%, rgba(6,182,212,0.04), transparent),
        linear-gradient(rgba(59,130,246,0.06) 1px, transparent 1px),
        linear-gradient(90deg, rgba(59,130,246,0.06) 1px, transparent 1px);
      background-size: 100% 100%, 100% 100%, 40px 40px, 40px 40px;
    }
    .card {
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      backdrop-filter: blur(20px);
      box-shadow: 0 2px 12px rgba(0,0,0,0.04);
    }
    .card:hover { border-color: rgba(59,130,246,0.3); }
    .card-title { color: var(--text2); }
    .card-title::before { background: var(--blue); }
    .metric-card {
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    }
    .metric-card::after { background: linear-gradient(90deg, var(--blue), transparent); }
    .metric-val { color: var(--blue); }
    .svg-container { background: rgba(248,250,252,0.8); }
    .tooltip {
      background: rgba(255,255,255,0.97);
      border: 1px solid rgba(59,130,246,0.25);
      color: var(--text); box-shadow: 0 8px 30px rgba(0,0,0,0.12);
    }
    .tooltip .tt-title { color: var(--blue); }
    .tooltip .tt-k { color: var(--text3); }
    .btn-primary { background: linear-gradient(135deg, #3B82F6 0%, #06B6D4 100%); color: #fff; }
    .btn-secondary { background: rgba(248,250,252,0.8); color: var(--text); border: 1px solid rgba(59,130,246,0.2); }
    .btn-secondary:hover { border-color: var(--blue); background: #fff; }
    .engine-badge.loading { background: rgba(217,119,6,0.1); color: var(--orange); border: 1px solid rgba(217,119,6,0.2); }
    .engine-badge.ready { background: rgba(5,150,105,0.1); color: var(--green); border: 1px solid rgba(5,150,105,0.2); }
    .spinner { border-color: rgba(59,130,246,0.2); border-top-color: var(--blue); }
    .pkt-table th { border-bottom: 1px solid rgba(59,130,246,0.15); color: var(--text3); }
    .pkt-table td { border-bottom: 1px solid rgba(59,130,246,0.08); }
    .pkt-table tr:hover td { background: rgba(59,130,246,0.04); }
    .topo-link { stroke: rgba(59,130,246,0.25); }
    pre { background: rgba(248,250,252,0.9); border-color: rgba(59,130,246,0.15); color: var(--text2); }
    textarea { background: rgba(248,250,252,0.9); color: var(--text); border-color: rgba(59,130,246,0.2); }

    /* ═══════════════════════════════════════════════
       SIDEBAR + MAIN LAYOUT
       ═══════════════════════════════════════════════ */
    .app-layout {
      display: flex;
      min-height: 100vh;
      position: relative;
      z-index: 1;
    }

    /* Sidebar */
    .sidebar {
      width: var(--sidebar-w);
      min-width: var(--sidebar-w);
      max-height: 100vh;
      overflow-y: auto;
      position: sticky;
      top: 0;
      padding: 16px 14px;
      border-right: 1px solid rgba(59,130,246,0.15);
      background: rgba(255,255,255,0.7);
      backdrop-filter: blur(24px);
      transition: transform 0.3s ease;
      z-index: 20;
    }
    .sidebar::-webkit-scrollbar { width: 5px; }
    .sidebar::-webkit-scrollbar-thumb { background: rgba(59,130,246,0.2); border-radius: 4px; }
    .sidebar-header {
      display: flex; align-items: center; gap: 10px;
      margin-bottom: 14px; padding-bottom: 10px;
      border-bottom: 1px solid rgba(59,130,246,0.15);
    }
    .sidebar-header img { height: 28px; }
    .sidebar-header h2 {
      font-size: 1.05rem; font-weight: 800;
      background: linear-gradient(135deg, #3B82F6 0%, #06B6D4 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    }
    .sidebar-close {
      display: none; margin-left: auto; background: none; border: none;
      font-size: 1.4rem; color: var(--text3); cursor: pointer;
    }

    /* Accordion Panel */
    .acc-panel { margin-bottom: 6px; }
    .acc-header {
      display: flex; align-items: center; gap: 8px;
      padding: 9px 12px; border-radius: 10px; cursor: pointer;
      background: rgba(59,130,246,0.04);
      border: 1px solid transparent;
      transition: all 0.15s; user-select: none;
    }
    .acc-header:hover { border-color: rgba(59,130,246,0.2); background: rgba(59,130,246,0.08); }
    .acc-header.active { border-color: rgba(59,130,246,0.25); background: rgba(59,130,246,0.08); }
    .acc-arrow {
      font-size: 0.65rem; color: var(--text3);
      transition: transform 0.2s;
      flex-shrink: 0;
    }
    .acc-header.active .acc-arrow { transform: rotate(90deg); }
    .acc-title { font-size: 0.82rem; font-weight: 700; color: var(--text); }
    .acc-badge {
      margin-left: auto;
      font-size: 0.65rem; font-weight: 700;
      padding: 1px 7px; border-radius: 10px;
      background: rgba(59,130,246,0.1); color: var(--blue);
    }
    .acc-body {
      max-height: 0; overflow: hidden;
      transition: max-height 0.3s ease;
      padding: 0 4px;
    }
    .acc-body.open { max-height: 2000px; padding: 8px 4px; }

    /* Sidebar Form Elements */
    .sb-row {
      display: flex; align-items: center; gap: 8px;
      margin-bottom: 8px;
    }
    .sb-label {
      font-size: 0.75rem; font-weight: 600; color: var(--text2);
      min-width: 90px; flex-shrink: 0;
    }
    .sb-range { flex: 1; accent-color: var(--blue); }
    .sb-val {
      font-size: 0.75rem; font-weight: 700; color: var(--blue);
      min-width: 60px; text-align: right; font-variant-numeric: tabular-nums;
    }
    .sb-input {
      width: 80px; padding: 4px 8px; border-radius: 6px;
      border: 1px solid rgba(59,130,246,0.2);
      background: #fff; font-size: 0.78rem; color: var(--text);
    }
    .sb-input:focus { outline: none; border-color: var(--blue); }
    .sb-select {
      flex: 1; padding: 5px 8px; border-radius: 6px;
      border: 1px solid rgba(59,130,246,0.2);
      background: #fff; font-size: 0.78rem; color: var(--text);
      cursor: pointer;
    }
    .sb-select:focus { outline: none; border-color: var(--blue); }
    .sb-btn {
      padding: 5px 12px; border-radius: 6px; font-size: 0.75rem;
      font-weight: 700; cursor: pointer; border: 1px solid rgba(59,130,246,0.2);
      background: #fff; color: var(--blue); transition: all 0.15s;
    }
    .sb-btn:hover { background: rgba(59,130,246,0.08); border-color: var(--blue); }
    .sb-btn.primary { background: var(--blue); color: #fff; border-color: var(--blue); }
    .sb-btn.primary:hover { filter: brightness(1.1); }
    .sb-btn.danger { color: var(--red); border-color: rgba(220,38,38,0.2); }
    .sb-btn.danger:hover { background: rgba(220,38,38,0.08); }

    /* Node/Link/Flow Editor Items */
    .editor-item {
      display: flex; align-items: center; gap: 6px;
      padding: 6px 8px; margin-bottom: 4px;
      border-radius: 8px; background: rgba(255,255,255,0.6);
      border: 1px solid rgba(59,130,246,0.1);
      font-size: 0.75rem;
    }
    .editor-item:hover { border-color: rgba(59,130,246,0.25); }
    .editor-dot {
      width: 8px; height: 8px; border-radius: 50%;
      flex-shrink: 0;
    }
    .editor-id {
      font-weight: 700; color: var(--text);
      min-width: 60px; flex-shrink: 0;
    }
    .editor-item select {
      padding: 2px 4px; font-size: 0.72rem; border-radius: 4px;
      border: 1px solid rgba(59,130,246,0.15); background: #fff;
    }
    .editor-item input[type="number"] {
      width: 60px; padding: 2px 4px; font-size: 0.72rem;
      border-radius: 4px; border: 1px solid rgba(59,130,246,0.15);
    }
    .editor-remove {
      margin-left: auto; background: none; border: none;
      color: var(--red); cursor: pointer; font-size: 0.85rem;
      opacity: 0.5; transition: opacity 0.15s; flex-shrink: 0;
    }
    .editor-remove:hover { opacity: 1; }
    .editor-list {
      max-height: 280px; overflow-y: auto;
      margin-bottom: 8px;
    }
    .editor-list::-webkit-scrollbar { width: 4px; }
    .editor-list::-webkit-scrollbar-thumb { background: rgba(59,130,246,0.15); border-radius: 3px; }

    /* Flow mini-card */
    .flow-mini {
      padding: 8px 10px; margin-bottom: 6px;
      border-radius: 8px; background: rgba(255,255,255,0.7);
      border: 1px solid rgba(59,130,246,0.1);
    }
    .flow-mini:hover { border-color: rgba(59,130,246,0.25); }
    .flow-mini-header {
      display: flex; align-items: center; gap: 6px; margin-bottom: 6px;
    }
    .flow-mini-tag {
      font-size: 0.68rem; font-weight: 700; padding: 1px 8px;
      border-radius: 8px; color: #fff;
    }
    .flow-mini-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 4px 10px;
      font-size: 0.72rem;
    }
    .flow-mini-grid label { color: var(--text3); font-weight: 600; }
    .flow-mini-grid input, .flow-mini-grid select {
      width: 100%; padding: 2px 4px; font-size: 0.72rem;
      border-radius: 4px; border: 1px solid rgba(59,130,246,0.15);
    }
    .flow-computed {
      font-size: 0.68rem; color: var(--text3); margin-top: 4px;
      font-style: italic;
    }

    /* Solver Radio Group */
    .radio-group { display: flex; gap: 4px; }
    .radio-pill {
      padding: 4px 12px; border-radius: 6px; font-size: 0.75rem;
      font-weight: 700; cursor: pointer;
      border: 1px solid rgba(59,130,246,0.2);
      background: #fff; color: var(--text2);
      transition: all 0.15s;
    }
    .radio-pill.active { background: var(--blue); color: #fff; border-color: var(--blue); }
    .radio-pill:hover:not(.active) { border-color: var(--blue); color: var(--blue); }

    /* Auto-solve toggle */
    .toggle-switch {
      position: relative; width: 36px; height: 20px;
      display: inline-block; flex-shrink: 0;
    }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .toggle-slider {
      position: absolute; cursor: pointer; inset: 0;
      background: #ccc; border-radius: 20px; transition: 0.2s;
    }
    .toggle-slider::before {
      content: ''; position: absolute; height: 14px; width: 14px;
      left: 3px; bottom: 3px; background: #fff;
      border-radius: 50%; transition: 0.2s;
    }
    .toggle-switch input:checked + .toggle-slider { background: var(--blue); }
    .toggle-switch input:checked + .toggle-slider::before { transform: translateX(16px); }

    /* Main Content */
    .main-content {
      flex: 1;
      min-width: 0;
      padding: 20px 24px 60px;
      max-width: 1200px;
    }
    .main-header {
      display: flex; align-items: center; justify-content: space-between;
      margin-bottom: 16px; flex-wrap: wrap; gap: 10px;
    }
    .main-header h1 {
      font-size: 1.8rem; font-weight: 800;
      background: linear-gradient(135deg, #3B82F6 0%, #06B6D4 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    }
    .hamburger {
      display: none; background: none; border: 1px solid rgba(59,130,246,0.2);
      border-radius: 8px; padding: 6px 10px; cursor: pointer;
      font-size: 1.2rem; color: var(--text2);
    }

    /* 3D Card */
    .shuttle-3d-card {
      position: relative; border-radius: var(--radius); overflow: hidden;
      margin-bottom: 16px; background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      box-shadow: 0 2px 12px rgba(0,0,0,0.04); backdrop-filter: blur(20px);
    }
    #canvas3d {
      width: 100%; height: 420px; display: block; cursor: grab;
      background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
    }
    #canvas3d:active { cursor: grabbing; }
    .shuttle-3d-label {
      position: absolute; bottom: 12px; left: 16px;
      font-size: 0.72rem; color: var(--text3);
      background: rgba(255,255,255,0.85); padding: 4px 10px;
      border-radius: 8px; backdrop-filter: blur(10px);
      border: 1px solid rgba(59,130,246,0.1);
    }

    /* Per-Switch GCL Cards */
    .gcl-switch-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;
    }
    @media (max-width: 900px) { .gcl-switch-grid { grid-template-columns: 1fr; } }
    .gcl-switch-card {
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      border-radius: var(--radius); padding: 16px 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    }
    .gcl-switch-card .sw-header {
      display: flex; align-items: center; gap: 10px;
      margin-bottom: 12px; padding-bottom: 8px;
      border-bottom: 1px solid rgba(59,130,246,0.15);
    }
    .sw-dot { width: 12px; height: 12px; border-radius: 3px; flex-shrink: 0; }
    .sw-name { font-weight: 700; font-size: 0.95rem; color: var(--text); }
    .sw-chip {
      font-size: 0.7rem; padding: 2px 8px; border-radius: 6px;
      background: rgba(59,130,246,0.1); color: var(--blue); font-weight: 600;
    }
    .sw-stats { margin-left: auto; font-size: 0.75rem; color: var(--text3); }
    .gcl-entry-table { width: 100%; border-collapse: collapse; font-size: 0.78rem; }
    .gcl-entry-table th {
      text-align: left; padding: 4px 8px; color: var(--text3);
      border-bottom: 1px solid rgba(59,130,246,0.15); font-weight: 600;
    }
    .gcl-entry-table td { padding: 4px 8px; border-bottom: 1px solid rgba(0,0,0,0.06); }
    .gcl-entry-table tr:hover td { background: rgba(0,0,0,0.03); }
    .gate-mask { font-family: 'Courier New', monospace; font-size: 0.75rem; letter-spacing: 1px; font-weight: 700; }
    .gate-open { color: var(--green); }
    .gate-guard { color: var(--orange); }
    .gate-closed { color: var(--text3); opacity: 0.5; }
    .entry-bar { height: 6px; border-radius: 3px; margin-top: 2px; }
    .link-label-dir { font-size: 0.8rem; font-weight: 600; color: var(--text2); margin-bottom: 4px; }

    /* Solution History */
    .history-bar {
      display: flex; gap: 6px; margin-bottom: 14px; flex-wrap: wrap;
      align-items: center;
    }
    .history-chip {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 5px 12px; border-radius: 8px; font-size: 0.72rem;
      font-weight: 600; cursor: pointer;
      background: rgba(255,255,255,0.8);
      border: 1px solid rgba(59,130,246,0.15);
      transition: all 0.15s; color: var(--text2);
    }
    .history-chip:hover { border-color: var(--blue); color: var(--blue); }
    .history-chip.active { background: rgba(59,130,246,0.1); border-color: var(--blue); color: var(--blue); }
    .history-chip .h-method {
      font-size: 0.65rem; padding: 1px 6px; border-radius: 4px;
      background: rgba(59,130,246,0.1); color: var(--blue);
    }
    .history-chip .h-method.ilp { background: rgba(124,58,237,0.1); color: var(--purple); }
    .history-label { font-size: 0.72rem; color: var(--text3); font-weight: 600; }

    /* Toast Notifications */
    .toast-container {
      position: fixed; bottom: 20px; right: 20px; z-index: 1000;
      display: flex; flex-direction: column-reverse; gap: 8px;
      pointer-events: none;
    }
    .toast {
      padding: 10px 18px; border-radius: 10px; font-size: 0.8rem;
      font-weight: 600; backdrop-filter: blur(20px);
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      animation: toastIn 0.3s ease;
      pointer-events: auto;
    }
    .toast.success { background: rgba(5,150,105,0.12); color: var(--green); border: 1px solid rgba(5,150,105,0.25); }
    .toast.error { background: rgba(220,38,38,0.12); color: var(--red); border: 1px solid rgba(220,38,38,0.25); }
    .toast.info { background: rgba(59,130,246,0.12); color: var(--blue); border: 1px solid rgba(59,130,246,0.25); }
    .toast.fadeout { animation: toastOut 0.3s ease forwards; }
    @keyframes toastIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes toastOut { from { opacity: 1; } to { opacity: 0; transform: translateY(10px); } }

    /* Solve button in sidebar */
    .solve-bar {
      display: flex; gap: 6px; margin-top: 8px;
    }

    /* Mobile Responsive */
    .sidebar-overlay {
      display: none; position: fixed; inset: 0;
      background: rgba(0,0,0,0.3); z-index: 15;
    }
    @media (max-width: 900px) {
      .sidebar {
        position: fixed; top: 0; left: 0; bottom: 0;
        transform: translateX(-100%);
        box-shadow: 4px 0 20px rgba(0,0,0,0.1);
      }
      .sidebar.open { transform: translateX(0); }
      .sidebar-overlay.open { display: block; }
      .sidebar-close { display: block; }
      .hamburger { display: flex; }
      .main-content { padding: 16px 14px 60px; }
    }

    /* Scenario auto desc */
    .auto-desc { background: rgba(255,255,255,0.95); border: 1px solid rgba(59,130,246,0.15); box-shadow: 0 2px 8px rgba(0,0,0,0.04); }
    .auto-desc h3 { color: var(--blue); }
    .auto-domain-legend .domain-tag { border: 1px solid rgba(59,130,246,0.15); background: rgba(255,255,255,0.8); color: var(--text2); }
  </style>
</head>
<body>
  <div class="bg-grid"></div>

  <!-- Mobile overlay -->
  <div class="sidebar-overlay" id="sidebarOverlay"></div>

  <div class="app-layout">
    <!-- ═══════════════ SIDEBAR ═══════════════ -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <img src="keti.png" alt="KETI" onerror="this.style.display='none'">
        <h2>Custom Playground</h2>
        <button class="sidebar-close" id="sidebarClose">&times;</button>
      </div>

      <!-- Panel 1: Preset -->
      <div class="acc-panel">
        <div class="acc-header active" data-panel="preset">
          <span class="acc-arrow">&#9654;</span>
          <span class="acc-title">Preset</span>
        </div>
        <div class="acc-body open" id="panelPreset">
          <select class="sb-select" id="presetSelect" style="width:100%;margin-bottom:6px;">
            <option value="standard">Standard (13N / 9F)</option>
            <option value="reconf">Reconfigured (14N / 11F)</option>
            <option value="optimal">Optimal Tri-Star (13N / 9F)</option>
          </select>
        </div>
      </div>

      <!-- Panel 2: Global Parameters -->
      <div class="acc-panel">
        <div class="acc-header" data-panel="globals">
          <span class="acc-arrow">&#9654;</span>
          <span class="acc-title">Global Parameters</span>
        </div>
        <div class="acc-body" id="panelGlobals">
          <div class="sb-row">
            <span class="sb-label">Cycle Time</span>
            <input type="range" class="sb-range" id="cycleRange" min="1000" max="50000" step="100">
            <span class="sb-val" id="cycleVal"></span>
            <span class="sb-label" style="min-width:auto;">&micro;s</span>
          </div>
          <div class="sb-row">
            <span class="sb-label">Guard Band</span>
            <input type="range" class="sb-range" id="guardRange" min="0" max="20" step="1">
            <span class="sb-val" id="guardVal"></span>
            <span class="sb-label" style="min-width:auto;">&micro;s</span>
          </div>
          <div class="sb-row">
            <span class="sb-label">Proc. Delay</span>
            <input type="range" class="sb-range" id="procRange" min="0" max="20" step="1">
            <span class="sb-val" id="procVal"></span>
            <span class="sb-label" style="min-width:auto;">&micro;s</span>
          </div>
        </div>
      </div>

      <!-- Panel 3: Node Editor -->
      <div class="acc-panel">
        <div class="acc-header" data-panel="nodes">
          <span class="acc-arrow">&#9654;</span>
          <span class="acc-title">Nodes</span>
          <span class="acc-badge" id="nodeBadge">0</span>
        </div>
        <div class="acc-body" id="panelNodes">
          <div class="editor-list" id="nodeList"></div>
          <button class="sb-btn" id="addNodeBtn">+ Add Node</button>
        </div>
      </div>

      <!-- Panel 4: Link Editor -->
      <div class="acc-panel">
        <div class="acc-header" data-panel="links">
          <span class="acc-arrow">&#9654;</span>
          <span class="acc-title">Links</span>
          <span class="acc-badge" id="linkBadge">0</span>
        </div>
        <div class="acc-body" id="panelLinks">
          <div class="editor-list" id="linkList"></div>
          <button class="sb-btn" id="addLinkBtn">+ Add Link</button>
        </div>
      </div>

      <!-- Panel 5: Flow Editor -->
      <div class="acc-panel">
        <div class="acc-header" data-panel="flows">
          <span class="acc-arrow">&#9654;</span>
          <span class="acc-title">Flows</span>
          <span class="acc-badge" id="flowBadge">0</span>
        </div>
        <div class="acc-body" id="panelFlows">
          <div class="editor-list" id="flowList" style="max-height:400px;"></div>
          <button class="sb-btn" id="addFlowBtn">+ Add Flow</button>
        </div>
      </div>

      <!-- Panel 6: Solver Settings -->
      <div class="acc-panel">
        <div class="acc-header" data-panel="solver">
          <span class="acc-arrow">&#9654;</span>
          <span class="acc-title">Solver</span>
          <span class="engine-badge loading" id="engineBadge" style="margin-left:auto;"><span class="spinner"></span>GLPK</span>
        </div>
        <div class="acc-body" id="panelSolver">
          <div class="sb-row">
            <span class="sb-label">Mode</span>
            <div class="radio-group" id="solverModeGroup">
              <span class="radio-pill active" data-mode="greedy">Greedy</span>
              <span class="radio-pill" data-mode="ilp">ILP</span>
              <span class="radio-pill" data-mode="both">Both</span>
            </div>
          </div>
          <div class="sb-row">
            <span class="sb-label">ILP Timeout</span>
            <input type="range" class="sb-range" id="ilpTimeoutRange" min="5" max="120" step="5" value="15">
            <span class="sb-val" id="ilpTimeoutVal">15s</span>
          </div>
          <div class="sb-row">
            <span class="sb-label">Auto-solve</span>
            <label class="toggle-switch">
              <input type="checkbox" id="autoSolveToggle" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
          <div class="solve-bar">
            <button class="sb-btn primary" id="solveBtn" style="flex:1;">Solve Now</button>
            <button class="sb-btn" id="resetBtn">Reset</button>
          </div>
        </div>
      </div>

      <!-- Panel 7: Export/Import -->
      <div class="acc-panel">
        <div class="acc-header" data-panel="io">
          <span class="acc-arrow">&#9654;</span>
          <span class="acc-title">Export / Import</span>
        </div>
        <div class="acc-body" id="panelIO">
          <div style="display:flex;gap:6px;flex-wrap:wrap;">
            <button class="sb-btn" id="exportBtn">Download JSON</button>
            <button class="sb-btn" id="copyBtn">Copy</button>
            <label class="sb-btn" style="cursor:pointer;">
              Upload JSON
              <input type="file" accept=".json" id="importFile" style="display:none;">
            </label>
          </div>
        </div>
      </div>
    </aside>

    <!-- ═══════════════ MAIN CONTENT ═══════════════ -->
    <main class="main-content">
      <div class="main-header">
        <button class="hamburger" id="hamburgerBtn">&#9776;</button>
        <h1>TSN / GCL Custom Playground</h1>
        <a href="index.html" class="btn btn-secondary" style="font-size:0.78rem;">Home</a>
      </div>

      <!-- 3D Shuttle -->
      <div class="shuttle-3d-card">
        <div class="card-title" style="padding:16px 20px 0;">3D Shuttle Network Topology</div>
        <div id="canvas3d"></div>
        <div class="shuttle-3d-label">Drag to rotate &middot; Scroll to zoom &middot; Right-click to pan</div>
      </div>

      <!-- Solution History -->
      <div class="history-bar" id="historyBar">
        <span class="history-label">History:</span>
      </div>

      <!-- Metrics -->
      <div class="metrics" id="metricsArea"></div>

      <!-- Network Topology -->
      <div class="card">
        <div class="card-title">Network Topology</div>
        <div class="legend" id="topoLegend"></div>
        <div class="svg-container" id="topoContainer" style="height:480px;"></div>
      </div>

      <!-- Per-Switch GCL Detail -->
      <div class="card">
        <div class="card-title">Per-Switch GCL &mdash; Gate Control by Egress Port</div>
      </div>
      <div id="switchGclArea" class="gcl-switch-grid"></div>

      <!-- GCL Gantt -->
      <div class="card">
        <div class="card-title">Per-Link GCL Timeline (Gantt)</div>
        <div class="legend" id="gclLegend"></div>
        <div class="svg-container" id="gclContainer"></div>
      </div>

      <!-- Delay + Utilization -->
      <div class="two-col">
        <div class="card">
          <div class="card-title">Packet E2E Delay</div>
          <div class="svg-container" id="delayContainer" style="height:380px;"></div>
        </div>
        <div class="card">
          <div class="card-title">Link Utilization</div>
          <div class="svg-container" id="utilContainer" style="min-height:200px;"></div>
        </div>
      </div>

      <!-- Table -->
      <div class="card">
        <div class="card-title">Packet Schedule Table</div>
        <div style="overflow-x:auto;">
          <table class="pkt-table">
            <thead><tr>
              <th>Packet</th><th>Flow</th><th>Route</th><th>Release</th><th>End</th><th>E2E</th><th>Deadline</th><th>Slack</th><th>Status</th>
            </tr></thead>
            <tbody id="pktTableBody"></tbody>
          </table>
        </div>
      </div>

      <!-- Collapsible JSON Editor -->
      <div class="card">
        <div class="card-title collapsible" id="jsonEditorToggle">
          <span class="arrow">&#9654;</span> Model JSON
        </div>
        <div class="collapse-body">
          <textarea id="input" style="min-height:300px;"></textarea>
        </div>
      </div>

      <!-- Raw GCL -->
      <div class="card">
        <div class="card-title collapsible" id="gclJsonToggle">
          <span class="arrow">&#9654;</span> Raw GCL Output (JSON)
        </div>
        <div class="collapse-body">
          <pre id="jsonOut">-</pre>
        </div>
      </div>
    </main>
  </div>

  <!-- Toast Container -->
  <div class="toast-container" id="toastContainer"></div>

  <!-- Tooltip -->
  <div class="tooltip" id="tooltip"></div>

  <script src="vendor/d3.min.js"></script>
  <script type="module">
  import {
    initTooltip, solveGreedy, solveILP, renderMetrics, renderTopology,
    renderGCL, renderDelayChart, renderUtilization, renderTable, renderSwitchGCL
  } from './js/ilp-core.js';
  import {
    ROII_REAL_STANDARD, getRealPositions,
    ROII_REAL_NODE_COLORS, ROII_REAL_SWITCHES,
    realFlowColor, realGetDeviceType,
    ROII_REAL_3D_POSITIONS, ROII_REAL_3D_TILTS,
    ROII_REAL_3D_LABELS,
    ROII_REAL_RECONF,
    getReconfPositions, ROII_RECONF_NODE_COLORS,
    ROII_REAL_3D_POSITIONS_RECONF, ROII_REAL_3D_LABELS_RECONF,
    ROII_OPTIMAL, getOptimalPositions,
    ROII_OPTIMAL_NODE_COLORS, ROII_OPTIMAL_3D_POSITIONS,
    ROII_OPTIMAL_3D_LABELS
  } from './js/roii-real-data.js?v=5';

  /* ═══════════════════════════════════════════════
     STATE
     ═══════════════════════════════════════════════ */
  const STATE = {
    model: null,
    glpk: null,
    solverMode: 'greedy',
    autoSolve: true,
    ilpTimeout: 15,
    currentResult: null,
    history: [],
    // 3D
    scene3d: null, camera3d: null, renderer3d: null, controls3d: null,
    dynamicGroup: null, nodeMeshes3d: {}, linkMeshes3d: {},
    clock3d: null, glbModel: null
  };

  /* ── Presets Registry ── */
  const PRESETS = {
    standard: {
      model: ROII_REAL_STANDARD, getPositions: getRealPositions,
      nodeColors: ROII_REAL_NODE_COLORS,
      pos3d: ROII_REAL_3D_POSITIONS, labels3d: ROII_REAL_3D_LABELS,
      tilts3d: ROII_REAL_3D_TILTS
    },
    reconf: {
      model: ROII_REAL_RECONF, getPositions: getReconfPositions,
      nodeColors: ROII_RECONF_NODE_COLORS,
      pos3d: ROII_REAL_3D_POSITIONS_RECONF, labels3d: ROII_REAL_3D_LABELS_RECONF,
      tilts3d: ROII_REAL_3D_TILTS
    },
    optimal: {
      model: ROII_OPTIMAL, getPositions: getOptimalPositions,
      nodeColors: ROII_OPTIMAL_NODE_COLORS,
      pos3d: ROII_OPTIMAL_3D_POSITIONS, labels3d: ROII_OPTIMAL_3D_LABELS,
      tilts3d: ROII_REAL_3D_TILTS
    }
  };

  const fcopts = { flowColorFn: realFlowColor, beColor: '#e2e8f0', beBorder: 'rgba(59,130,246,0.15)' };

  /* ═══════════════════════════════════════════════
     TOAST NOTIFICATIONS
     ═══════════════════════════════════════════════ */
  function showToast(msg, type = 'info', duration = 3000) {
    const container = document.getElementById('toastContainer');
    const el = document.createElement('div');
    el.className = `toast ${type}`;
    el.textContent = msg;
    container.appendChild(el);
    setTimeout(() => {
      el.classList.add('fadeout');
      setTimeout(() => el.remove(), 300);
    }, duration);
  }

  /* ═══════════════════════════════════════════════
     SIDEBAR UI
     ═══════════════════════════════════════════════ */

  /* Accordion toggle */
  document.querySelectorAll('.acc-header').forEach(hdr => {
    hdr.addEventListener('click', () => {
      const wasActive = hdr.classList.contains('active');
      // Close all
      document.querySelectorAll('.acc-header').forEach(h => h.classList.remove('active'));
      document.querySelectorAll('.acc-body').forEach(b => b.classList.remove('open'));
      // Toggle clicked
      if (!wasActive) {
        hdr.classList.add('active');
        hdr.nextElementSibling.classList.add('open');
      }
    });
  });

  /* Sidebar mobile toggle */
  const sidebar = document.getElementById('sidebar');
  const overlay = document.getElementById('sidebarOverlay');
  document.getElementById('hamburgerBtn').addEventListener('click', () => {
    sidebar.classList.add('open');
    overlay.classList.add('open');
  });
  function closeSidebar() {
    sidebar.classList.remove('open');
    overlay.classList.remove('open');
  }
  document.getElementById('sidebarClose').addEventListener('click', closeSidebar);
  overlay.addEventListener('click', closeSidebar);

  /* Collapsibles */
  document.getElementById("jsonEditorToggle").addEventListener("click", function() {
    this.classList.toggle("open");
    this.parentElement.querySelector(".collapse-body").classList.toggle("show");
  });
  document.getElementById("gclJsonToggle").addEventListener("click", function() {
    this.classList.toggle("open");
    this.parentElement.querySelector(".collapse-body").classList.toggle("show");
  });

  /* ═══════════════════════════════════════════════
     MODEL MANAGEMENT
     ═══════════════════════════════════════════════ */

  function deepClone(obj) { return JSON.parse(JSON.stringify(obj)); }

  function loadPreset(key) {
    const p = PRESETS[key];
    STATE.model = deepClone(p.model);
    syncUIFromModel();
    rebuild3D(p);
    scheduleAutoSolve();
    showToast(`Loaded preset: ${key}`, 'info');
  }

  function syncUIFromModel() {
    const m = STATE.model;
    document.getElementById('cycleRange').value = m.cycle_time_us;
    document.getElementById('cycleVal').textContent = m.cycle_time_us.toLocaleString();
    document.getElementById('guardRange').value = m.guard_band_us;
    document.getElementById('guardVal').textContent = m.guard_band_us;
    document.getElementById('procRange').value = m.processing_delay_us;
    document.getElementById('procVal').textContent = m.processing_delay_us;
    buildNodeEditor();
    buildLinkEditor();
    buildFlowEditor();
    document.getElementById('input').value = JSON.stringify(m, null, 2);
  }

  /* ── Global Parameters ── */
  function setupRangeSync(rangeId, valId, field, suffix = '') {
    const range = document.getElementById(rangeId);
    const val = document.getElementById(valId);
    range.addEventListener('input', () => {
      const v = parseInt(range.value);
      val.textContent = (field === 'cycle_time_us' ? v.toLocaleString() : v) + suffix;
      if (STATE.model) {
        STATE.model[field] = v;
        scheduleAutoSolve();
      }
    });
  }
  setupRangeSync('cycleRange', 'cycleVal', 'cycle_time_us');
  setupRangeSync('guardRange', 'guardVal', 'guard_band_us');
  setupRangeSync('procRange', 'procVal', 'processing_delay_us');

  document.getElementById('ilpTimeoutRange').addEventListener('input', function() {
    STATE.ilpTimeout = parseInt(this.value);
    document.getElementById('ilpTimeoutVal').textContent = this.value + 's';
  });

  /* ── Node Editor ── */
  function buildNodeEditor() {
    const list = document.getElementById('nodeList');
    const m = STATE.model;
    document.getElementById('nodeBadge').textContent = m.nodes.length;
    list.innerHTML = '';
    m.nodes.forEach((n, i) => {
      const color = getNodeColor(n.id);
      const el = document.createElement('div');
      el.className = 'editor-item';
      el.innerHTML = `
        <span class="editor-dot" style="background:${color}"></span>
        <input class="sb-input" style="width:80px;font-size:0.72rem;" value="${n.id}" data-idx="${i}" data-field="node-id">
        <select data-idx="${i}" data-field="node-type" style="font-size:0.72rem;padding:2px 4px;border-radius:4px;border:1px solid rgba(59,130,246,0.15);">
          <option value="switch" ${n.type==='switch'?'selected':''}>switch</option>
          <option value="endstation" ${n.type==='endstation'?'selected':''}>endstation</option>
        </select>
        <button class="editor-remove" data-idx="${i}">&times;</button>
      `;
      list.appendChild(el);
    });
    // Event delegation
    list.querySelectorAll('[data-field="node-id"]').forEach(inp => {
      inp.addEventListener('change', (e) => {
        const idx = parseInt(e.target.dataset.idx);
        const oldId = m.nodes[idx].id;
        const newId = e.target.value.trim();
        if (!newId) { e.target.value = oldId; return; }
        m.nodes[idx].id = newId;
        // Update links/flows referencing old id
        m.links.forEach(l => { if (l.from === oldId) l.from = newId; if (l.to === oldId) l.to = newId; });
        m.flows.forEach(f => { if (f.src === oldId) f.src = newId; if (f.dst === oldId) f.dst = newId; });
        buildLinkEditor(); buildFlowEditor();
        scheduleAutoSolve();
      });
    });
    list.querySelectorAll('[data-field="node-type"]').forEach(sel => {
      sel.addEventListener('change', (e) => {
        m.nodes[parseInt(e.target.dataset.idx)].type = e.target.value;
        scheduleAutoSolve();
      });
    });
    list.querySelectorAll('.editor-remove').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const idx = parseInt(e.target.dataset.idx);
        removeNode(idx);
      });
    });
  }

  function removeNode(idx) {
    const m = STATE.model;
    const nodeId = m.nodes[idx].id;
    m.nodes.splice(idx, 1);
    // Cascade: remove links referencing this node
    m.links = m.links.filter(l => l.from !== nodeId && l.to !== nodeId);
    // Cascade: remove flows referencing this node
    m.flows = m.flows.filter(f => f.src !== nodeId && f.dst !== nodeId);
    buildNodeEditor(); buildLinkEditor(); buildFlowEditor();
    scheduleAutoSolve();
    showToast(`Removed node ${nodeId} (cascading)`, 'info');
  }

  document.getElementById('addNodeBtn').addEventListener('click', () => {
    const m = STATE.model;
    let newId = 'NODE_' + (m.nodes.length + 1);
    while (m.nodes.some(n => n.id === newId)) newId += '_';
    m.nodes.push({ id: newId, type: 'endstation' });
    buildNodeEditor();
    showToast(`Added node ${newId}`, 'info');
  });

  /* ── Link Editor ── */
  function buildLinkEditor() {
    const list = document.getElementById('linkList');
    const m = STATE.model;
    document.getElementById('linkBadge').textContent = m.links.length;
    list.innerHTML = '';
    const nodeOpts = m.nodes.map(n => `<option value="${n.id}">${n.id}</option>`).join('');
    m.links.forEach((l, i) => {
      const el = document.createElement('div');
      el.className = 'editor-item';
      el.style.flexWrap = 'wrap';
      el.innerHTML = `
        <select data-idx="${i}" data-field="link-from" style="font-size:0.7rem;padding:2px;border-radius:4px;border:1px solid rgba(59,130,246,0.15);max-width:80px;">${nodeOpts}</select>
        <span style="font-size:0.7rem;color:var(--text3);">&rarr;</span>
        <select data-idx="${i}" data-field="link-to" style="font-size:0.7rem;padding:2px;border-radius:4px;border:1px solid rgba(59,130,246,0.15);max-width:80px;">${nodeOpts}</select>
        <input type="number" data-idx="${i}" data-field="link-rate" value="${l.rate_mbps}" title="Mbps" style="width:55px;">
        <input type="number" data-idx="${i}" data-field="link-prop" value="${l.prop_delay_us}" step="0.1" title="Prop delay (us)" style="width:50px;">
        <button class="editor-remove" data-idx="${i}">&times;</button>
      `;
      list.appendChild(el);
      el.querySelector('[data-field="link-from"]').value = l.from;
      el.querySelector('[data-field="link-to"]').value = l.to;
    });
    list.querySelectorAll('[data-field="link-from"]').forEach(sel => {
      sel.addEventListener('change', (e) => {
        m.links[parseInt(e.target.dataset.idx)].from = e.target.value;
        scheduleAutoSolve();
      });
    });
    list.querySelectorAll('[data-field="link-to"]').forEach(sel => {
      sel.addEventListener('change', (e) => {
        m.links[parseInt(e.target.dataset.idx)].to = e.target.value;
        scheduleAutoSolve();
      });
    });
    list.querySelectorAll('[data-field="link-rate"]').forEach(inp => {
      inp.addEventListener('change', (e) => {
        m.links[parseInt(e.target.dataset.idx)].rate_mbps = parseFloat(e.target.value) || 1000;
        scheduleAutoSolve();
      });
    });
    list.querySelectorAll('[data-field="link-prop"]').forEach(inp => {
      inp.addEventListener('change', (e) => {
        m.links[parseInt(e.target.dataset.idx)].prop_delay_us = parseFloat(e.target.value) || 0.5;
        scheduleAutoSolve();
      });
    });
    list.querySelectorAll('.editor-remove').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const idx = parseInt(e.target.dataset.idx);
        m.links.splice(idx, 1);
        buildLinkEditor();
        scheduleAutoSolve();
      });
    });
  }

  document.getElementById('addLinkBtn').addEventListener('click', () => {
    const m = STATE.model;
    if (m.nodes.length < 2) { showToast('Need at least 2 nodes', 'error'); return; }
    const from = m.nodes[0].id, to = m.nodes[1].id;
    const newId = 'l_' + from.toLowerCase() + '_' + to.toLowerCase() + '_' + Date.now().toString(36).slice(-4);
    m.links.push({ id: newId, from, to, rate_mbps: 1000, prop_delay_us: 0.5 });
    buildLinkEditor();
    showToast('Added link', 'info');
  });

  /* ── Flow Editor ── */
  function buildFlowEditor() {
    const list = document.getElementById('flowList');
    const m = STATE.model;
    document.getElementById('flowBadge').textContent = m.flows.length;
    list.innerHTML = '';
    const nodeOpts = m.nodes.map(n => `<option value="${n.id}">${n.id}</option>`).join('');
    m.flows.forEach((f, i) => {
      const color = realFlowColor(f.id);
      const txTime = ((f.payload_bytes + 38) * 8) / (m.links[0]?.rate_mbps || 1000);
      const pktsPerCycle = Math.round(m.cycle_time_us / (f.period_us || m.cycle_time_us));
      const el = document.createElement('div');
      el.className = 'flow-mini';
      el.innerHTML = `
        <div class="flow-mini-header">
          <span class="flow-mini-tag" style="background:${color};">${f.id}</span>
          <button class="editor-remove" data-idx="${i}">&times;</button>
        </div>
        <div class="flow-mini-grid">
          <label>Src</label>
          <select data-idx="${i}" data-field="flow-src">${nodeOpts}</select>
          <label>Dst</label>
          <select data-idx="${i}" data-field="flow-dst">${nodeOpts}</select>
          <label>Priority</label>
          <select data-idx="${i}" data-field="flow-pri">
            ${[0,1,2,3,4,5,6,7].map(p => `<option value="${p}" ${f.priority===p?'selected':''}>P${p}</option>`).join('')}
          </select>
          <label>Payload (B)</label>
          <input type="number" data-idx="${i}" data-field="flow-payload" value="${f.payload_bytes}" min="1">
          <label>Period (&micro;s)</label>
          <input type="number" data-idx="${i}" data-field="flow-period" value="${f.period_us}" min="1">
          <label>Deadline (&micro;s)</label>
          <input type="number" data-idx="${i}" data-field="flow-deadline" value="${f.deadline_us}" min="1">
          <label>k_paths</label>
          <select data-idx="${i}" data-field="flow-kpaths">
            ${[1,2,3,4].map(k => `<option value="${k}" ${(f.k_paths||2)===k?'selected':''}>k=${k}</option>`).join('')}
          </select>
        </div>
        <div class="flow-computed">tx=${txTime.toFixed(1)}&micro;s &middot; ${pktsPerCycle} pkt/cycle</div>
      `;
      list.appendChild(el);
      el.querySelector('[data-field="flow-src"]').value = f.src;
      el.querySelector('[data-field="flow-dst"]').value = f.dst;
    });

    // Event listeners
    list.querySelectorAll('[data-field="flow-src"]').forEach(sel => {
      sel.addEventListener('change', e => { m.flows[parseInt(e.target.dataset.idx)].src = e.target.value; scheduleAutoSolve(); });
    });
    list.querySelectorAll('[data-field="flow-dst"]').forEach(sel => {
      sel.addEventListener('change', e => { m.flows[parseInt(e.target.dataset.idx)].dst = e.target.value; scheduleAutoSolve(); });
    });
    list.querySelectorAll('[data-field="flow-pri"]').forEach(sel => {
      sel.addEventListener('change', e => { m.flows[parseInt(e.target.dataset.idx)].priority = parseInt(e.target.value); scheduleAutoSolve(); });
    });
    list.querySelectorAll('[data-field="flow-payload"]').forEach(inp => {
      inp.addEventListener('change', e => {
        m.flows[parseInt(e.target.dataset.idx)].payload_bytes = parseInt(e.target.value) || 64;
        buildFlowEditor(); scheduleAutoSolve();
      });
    });
    list.querySelectorAll('[data-field="flow-period"]').forEach(inp => {
      inp.addEventListener('change', e => {
        m.flows[parseInt(e.target.dataset.idx)].period_us = parseInt(e.target.value) || 10000;
        buildFlowEditor(); scheduleAutoSolve();
      });
    });
    list.querySelectorAll('[data-field="flow-deadline"]').forEach(inp => {
      inp.addEventListener('change', e => {
        m.flows[parseInt(e.target.dataset.idx)].deadline_us = parseInt(e.target.value) || 5000;
        scheduleAutoSolve();
      });
    });
    list.querySelectorAll('[data-field="flow-kpaths"]').forEach(sel => {
      sel.addEventListener('change', e => {
        m.flows[parseInt(e.target.dataset.idx)].k_paths = parseInt(e.target.value);
        scheduleAutoSolve();
      });
    });
    list.querySelectorAll('.editor-remove').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const idx = parseInt(e.target.dataset.idx);
        m.flows.splice(idx, 1);
        buildFlowEditor();
        scheduleAutoSolve();
      });
    });
  }

  document.getElementById('addFlowBtn').addEventListener('click', () => {
    const m = STATE.model;
    if (m.nodes.length < 2) { showToast('Need at least 2 nodes', 'error'); return; }
    const src = m.nodes[0].id;
    const dst = m.nodes[m.nodes.length - 1].id;
    const newId = 'f_custom_' + (m.flows.length + 1);
    m.flows.push({
      id: newId, priority: 6, payload_bytes: 4096, period_us: 10000,
      deadline_us: 5000, traffic_type: 'custom', src, dst, k_paths: 2
    });
    buildFlowEditor();
    showToast(`Added flow ${newId}`, 'info');
  });

  /* ── Node Color Helper ── */
  function getNodeColor(nodeId) {
    const colors = { ...ROII_REAL_NODE_COLORS, ...ROII_RECONF_NODE_COLORS, ...ROII_OPTIMAL_NODE_COLORS };
    return colors[nodeId]?.stroke || '#3B82F6';
  }

  /* ═══════════════════════════════════════════════
     SOLVER
     ═══════════════════════════════════════════════ */
  let solveTimer = null;

  function scheduleAutoSolve() {
    if (!STATE.autoSolve) return;
    clearTimeout(solveTimer);
    solveTimer = setTimeout(() => solve(), 500);
  }

  async function solve() {
    if (!STATE.model) return;
    // Sync JSON editor
    document.getElementById('input').value = JSON.stringify(STATE.model, null, 2);

    const mode = STATE.solverMode;
    const t0 = performance.now();

    try {
      // Validate
      const warnings = validateModel(STATE.model);
      warnings.forEach(w => showToast(w, 'error', 5000));

      if (mode === 'greedy' || mode === 'both') {
        const greedyResult = solveGreedy(STATE.model);
        const wallMs = Math.round(performance.now() - t0);
        STATE.currentResult = greedyResult;
        renderAll();
        pushHistory('greedy', greedyResult, wallMs);
        showToast(`Greedy solved in ${wallMs}ms (${greedyResult.packetRows.length} pkts)`, 'success');
      }

      if ((mode === 'ilp' || mode === 'both') && STATE.glpk) {
        const t1 = performance.now();
        const ilpResult = await solveILP(STATE.model, STATE.glpk, { tmlim: STATE.ilpTimeout });
        const wallMs = Math.round(performance.now() - t1);
        STATE.currentResult = ilpResult;
        renderAll();
        pushHistory('ilp', ilpResult, wallMs);
        showToast(`ILP solved in ${wallMs}ms (${ilpResult.stats.variables} vars)`, 'success');
      } else if (mode === 'ilp' && !STATE.glpk) {
        showToast('GLPK not loaded, falling back to Greedy', 'error');
        const greedyResult = solveGreedy(STATE.model);
        STATE.currentResult = greedyResult;
        renderAll();
        pushHistory('greedy', greedyResult, 0);
      }
    } catch (e) {
      showToast('Solve error: ' + e.message, 'error', 5000);
      console.error(e);
    }
  }

  function validateModel(m) {
    const warnings = [];
    for (const f of m.flows) {
      if (m.cycle_time_us % f.period_us !== 0) {
        warnings.push(`Warning: cycle_time ${m.cycle_time_us} not divisible by ${f.id} period ${f.period_us}`);
      }
    }
    // Count total packets
    let totalPkts = 0;
    for (const f of m.flows) {
      totalPkts += Math.round(m.cycle_time_us / f.period_us);
    }
    if (totalPkts > 70) {
      warnings.push(`Warning: ${totalPkts} total packets may be slow for ILP`);
    }
    return warnings;
  }

  /* ── Solver Mode ── */
  document.querySelectorAll('#solverModeGroup .radio-pill').forEach(pill => {
    pill.addEventListener('click', () => {
      document.querySelectorAll('#solverModeGroup .radio-pill').forEach(p => p.classList.remove('active'));
      pill.classList.add('active');
      STATE.solverMode = pill.dataset.mode;
    });
  });

  document.getElementById('autoSolveToggle').addEventListener('change', function() {
    STATE.autoSolve = this.checked;
  });

  document.getElementById('solveBtn').addEventListener('click', () => solve());
  document.getElementById('resetBtn').addEventListener('click', () => {
    const key = document.getElementById('presetSelect').value;
    loadPreset(key);
  });

  /* ═══════════════════════════════════════════════
     RENDER ALL
     ═══════════════════════════════════════════════ */
  function renderAll() {
    if (!STATE.currentResult || !STATE.model) return;
    const m = STATE.model;
    const result = STATE.currentResult;

    // Choose best available position function or generate simple layout
    const container = document.getElementById("topoContainer");
    const W = container.clientWidth;
    const H = 480;
    const positions = generatePositions(m, W, H);

    // Build node colors from model
    const nodeColors = buildNodeColors(m);

    // Detect switches for GCL
    const switches = m.nodes.filter(n => n.type === 'switch').map(n => ({
      id: n.id, label: n.id, chip: 'Switch', color: getNodeColor(n.id)
    }));

    renderMetrics(m, result);
    renderTopology(m, result, { nodePositions: positions, nodeColors, height: H });
    renderSwitchGCL(m, result, { switches, flowColorFn: realFlowColor });
    renderGCL(m, result, fcopts);
    renderDelayChart(m, result, fcopts);
    renderUtilization(m, result, { beColor: '#e2e8f0' });
    renderTable(result, fcopts);
    document.getElementById("jsonOut").textContent = JSON.stringify(result.gcl, null, 2);
  }

  function generatePositions(m, W, H) {
    // Try preset positions first
    const key = document.getElementById('presetSelect').value;
    const preset = PRESETS[key];
    if (preset) {
      const presetNodes = new Set(preset.model.nodes.map(n => n.id));
      const modelNodes = new Set(m.nodes.map(n => n.id));
      const allMatch = [...modelNodes].every(id => presetNodes.has(id));
      if (allMatch && modelNodes.size === presetNodes.size) {
        return preset.getPositions(W, H);
      }
    }
    // Fallback: auto-layout
    return autoLayout(m, W, H);
  }

  function autoLayout(m, W, H) {
    const pos = {};
    const switches = m.nodes.filter(n => n.type === 'switch');
    const endpoints = m.nodes.filter(n => n.type !== 'switch');
    const totalSw = switches.length || 1;
    const totalEp = endpoints.length || 1;

    // Endstations on top row
    endpoints.forEach((n, i) => {
      pos[n.id] = { x: W * ((i + 0.5) / totalEp), y: H * 0.12 };
    });
    // Switches in middle
    switches.forEach((n, i) => {
      pos[n.id] = { x: W * ((i + 0.5) / totalSw), y: H * 0.5 };
    });
    // If there's an ACU_IT or node named with 'ACU', put at bottom
    m.nodes.forEach(n => {
      if (n.id.includes('ACU')) {
        pos[n.id] = { x: W * 0.5, y: H * 0.88 };
      }
    });
    return pos;
  }

  function buildNodeColors(m) {
    const allColors = { ...ROII_REAL_NODE_COLORS, ...ROII_RECONF_NODE_COLORS, ...ROII_OPTIMAL_NODE_COLORS };
    const colors = {};
    m.nodes.forEach(n => {
      if (allColors[n.id]) {
        colors[n.id] = allColors[n.id];
      } else {
        // Auto-assign color
        const c = n.type === 'switch' ? '#3B82F6' : '#059669';
        colors[n.id] = { fill: c + '22', stroke: c, label: n.id, shortLabel: n.id.slice(0, 4) };
      }
    });
    return colors;
  }

  /* Responsive */
  let resizeTimer;
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(renderAll, 300);
  });

  /* ═══════════════════════════════════════════════
     SOLUTION HISTORY
     ═══════════════════════════════════════════════ */
  function pushHistory(method, result, wallMs) {
    const entry = {
      timestamp: new Date().toLocaleTimeString(),
      method,
      objective: result.objective || 0,
      model: deepClone(STATE.model),
      result: deepClone(result),
      wallMs
    };
    STATE.history.push(entry);
    if (STATE.history.length > 5) STATE.history.shift();
    renderHistory();
  }

  function renderHistory() {
    const bar = document.getElementById('historyBar');
    bar.innerHTML = '<span class="history-label">History:</span>';
    STATE.history.forEach((entry, i) => {
      const chip = document.createElement('span');
      chip.className = 'history-chip' + (i === STATE.history.length - 1 ? ' active' : '');
      chip.innerHTML = `
        <span>${entry.timestamp}</span>
        <span class="h-method ${entry.method === 'ilp' ? 'ilp' : ''}">${entry.method.toUpperCase()}</span>
        <span>${entry.objective}&micro;s</span>
      `;
      chip.addEventListener('click', () => loadHistoryEntry(i));
      bar.appendChild(chip);
    });
  }

  function loadHistoryEntry(idx) {
    const entry = STATE.history[idx];
    STATE.model = deepClone(entry.model);
    STATE.currentResult = deepClone(entry.result);
    syncUIFromModel();
    renderAll();
    renderHistory();
    // Update active chip
    document.querySelectorAll('.history-chip').forEach((c, i) => {
      c.classList.toggle('active', i === idx);
    });
    showToast(`Restored: ${entry.method.toUpperCase()} @ ${entry.timestamp}`, 'info');
  }

  /* ═══════════════════════════════════════════════
     EXPORT / IMPORT
     ═══════════════════════════════════════════════ */
  document.getElementById('exportBtn').addEventListener('click', () => {
    if (!STATE.model) return;
    const blob = new Blob([JSON.stringify(STATE.model, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'tsn-model-' + Date.now() + '.json';
    a.click();
    URL.revokeObjectURL(url);
    showToast('Model exported', 'success');
  });

  document.getElementById('copyBtn').addEventListener('click', () => {
    if (!STATE.model) return;
    navigator.clipboard.writeText(JSON.stringify(STATE.model, null, 2)).then(() => {
      showToast('Copied to clipboard', 'success');
    });
  });

  document.getElementById('importFile').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (evt) => {
      try {
        const imported = JSON.parse(evt.target.result);
        if (!imported.nodes || !imported.links || !imported.flows) {
          showToast('Invalid model: missing nodes/links/flows', 'error');
          return;
        }
        STATE.model = imported;
        syncUIFromModel();
        scheduleAutoSolve();
        showToast('Model imported successfully', 'success');
      } catch (err) {
        showToast('Import error: ' + err.message, 'error');
      }
    };
    reader.readAsText(file);
    e.target.value = '';
  });

  /* ═══════════════════════════════════════════════
     PRESET SELECTOR
     ═══════════════════════════════════════════════ */
  document.getElementById('presetSelect').addEventListener('change', function() {
    loadPreset(this.value);
  });

  /* ═══════════════════════════════════════════════
     3D VISUALIZATION
     ═══════════════════════════════════════════════ */
  const TMPL = {
    lidar_g32:    { w: 1, h: 1, d: 1, color: 0x10B981 },
    lidar_pandar: { w: 1, h: 1, d: 1, color: 0x0D9488 },
    radar:        { w: 1, h: 1, d: 1, color: 0x952aff },
    replicator:   { w: 2, h: 1.5, d: 2, color: 0xd97706 },
    switch_f:     { w: 4, h: 2, d: 4, color: 0x3B82F6 },
    switch_r:     { w: 4, h: 2, d: 4, color: 0x06B6D4 },
    ecu:          { w: 4, h: 2, d: 4, color: 0xdc2626 }
  };

  function getDeviceType(nodeId) {
    try { return realGetDeviceType(nodeId); } catch(e) {}
    if (nodeId.includes('SW') || nodeId.includes('switch')) return 'switch_f';
    if (nodeId.includes('ACU') || nodeId.includes('ECU')) return 'ecu';
    return 'lidar_g32';
  }

  function createDevice(nodeId, position, label, tilt) {
    const type = getDeviceType(nodeId);
    const t = TMPL[type] || TMPL.lidar_g32;
    const group = new THREE.Group();
    const { w, h, d } = t;

    let geometry;
    if (type === 'lidar_pandar') geometry = new THREE.CylinderGeometry(w * 0.6, w * 0.6, h * 0.8, 16);
    else if (type === 'replicator') geometry = new THREE.OctahedronGeometry(w * 0.7);
    else geometry = new THREE.BoxGeometry(w, h, d);

    const mat = new THREE.MeshPhongMaterial({
      color: t.color, emissive: t.color, emissiveIntensity: 0.5,
      specular: 0x888888, shininess: 30
    });
    const mesh = new THREE.Mesh(geometry, mat);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    group.add(mesh);

    group.add(new THREE.LineSegments(
      new THREE.EdgesGeometry(geometry),
      new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 5 })
    ));

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 512; canvas.height = 128;
    ctx.fillStyle = 'rgba(26, 26, 46, 0.9)';
    ctx.fillRect(0, 0, 512, 128);
    ctx.fillStyle = '#FFFFFF';
    ctx.font = 'bold 48px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(label, 256, 75);
    const sprite = new THREE.Sprite(
      new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) })
    );
    const ls = Math.max(w, d) * 1.2;
    sprite.scale.set(ls, ls * 0.25, 1);
    sprite.position.y = h + 1;
    group.add(sprite);

    group.position.copy(position);
    if (tilt) {
      if (tilt.x !== undefined) group.rotation.x = tilt.x;
      if (tilt.y !== undefined) group.rotation.y = tilt.y;
      if (tilt.z !== undefined) group.rotation.z = tilt.z;
    }
    return { mesh, group };
  }

  function init3D() {
    const container = document.getElementById('canvas3d');
    if (!container || typeof THREE === 'undefined') return;

    STATE.scene3d = new THREE.Scene();
    STATE.scene3d.background = new THREE.Color(0xf0f0f0);
    STATE.scene3d.fog = new THREE.Fog(0xf0f0f0, 80, 250);

    STATE.camera3d = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
    STATE.camera3d.position.set(50, 35, 70);

    STATE.renderer3d = new THREE.WebGLRenderer({ antialias: true });
    STATE.renderer3d.shadowMap.enabled = true;
    STATE.renderer3d.shadowMap.type = THREE.PCFSoftShadowMap;

    function updateSize() {
      const w = container.clientWidth, h = container.clientHeight;
      STATE.camera3d.aspect = w / h;
      STATE.camera3d.updateProjectionMatrix();
      STATE.renderer3d.setSize(w, h);
    }
    updateSize();
    container.appendChild(STATE.renderer3d.domElement);
    window.addEventListener('resize', updateSize);

    STATE.controls3d = new THREE.OrbitControls(STATE.camera3d, STATE.renderer3d.domElement);
    STATE.controls3d.enableDamping = true;
    STATE.controls3d.dampingFactor = 0.05;
    STATE.controls3d.autoRotate = true;
    STATE.controls3d.autoRotateSpeed = 1.2;
    STATE.controls3d.minDistance = 20;
    STATE.controls3d.maxDistance = 120;
    STATE.controls3d.target.set(0, 0, 0);

    STATE.scene3d.add(new THREE.AmbientLight(0xffffff, 1.2));
    const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
    mainLight.position.set(30, 50, 30);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.set(2048, 2048);
    mainLight.shadow.camera.near = 0.5;
    mainLight.shadow.camera.far = 200;
    mainLight.shadow.camera.left = -60;
    mainLight.shadow.camera.right = 60;
    mainLight.shadow.camera.top = 60;
    mainLight.shadow.camera.bottom = -60;
    STATE.scene3d.add(mainLight);
    const fillLight = new THREE.DirectionalLight(0xffffff, 1.0);
    fillLight.position.set(0, 50, 0);
    STATE.scene3d.add(fillLight);
    const pl1 = new THREE.PointLight(0x3B82F6, 2, 100);
    pl1.position.set(20, 15, 20);
    STATE.scene3d.add(pl1);
    const pl2 = new THREE.PointLight(0x06B6D4, 1.5, 80);
    pl2.position.set(-20, 15, -20);
    STATE.scene3d.add(pl2);

    const grid = new THREE.GridHelper(100, 50, 0x3B82F6, 0xCCCCCC);
    grid.material.opacity = 0.4;
    grid.material.transparent = true;
    grid.position.y = -0.5;
    STATE.scene3d.add(grid);
    const plane = new THREE.Mesh(
      new THREE.PlaneGeometry(100, 100),
      new THREE.ShadowMaterial({ opacity: 0.3 })
    );
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = -0.5;
    plane.receiveShadow = true;
    STATE.scene3d.add(plane);

    const loader = new THREE.GLTFLoader();
    loader.load('./roii.glb',
      (gltf) => {
        STATE.glbModel = gltf.scene;
        const box = new THREE.Box3().setFromObject(STATE.glbModel);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        const targetSize = 40;
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = targetSize / maxDim;
        STATE.glbModel.scale.set(scale, scale, scale);
        const scaledHeight = size.y * scale;
        STATE.glbModel.position.x = -center.x;
        STATE.glbModel.position.y = -center.y + (scaledHeight * 0.5) + 0.5;
        STATE.glbModel.position.z = -center.z;
        STATE.glbModel.traverse((child) => {
          if (!child.isMesh) return;
          const mats = Array.isArray(child.material) ? child.material : [child.material];
          mats.forEach(mat => {
            mat.transparent = true;
            mat.opacity = 0.3;
            mat.side = THREE.DoubleSide;
            mat.depthWrite = true;
            if (mat.color) mat.color.multiplyScalar(1.5);
            mat.emissive = mat.color ? mat.color.clone().multiplyScalar(0.3) : new THREE.Color(0xffffff);
            mat.emissiveIntensity = 0.4;
          });
          child.castShadow = true;
          child.receiveShadow = true;
        });
        STATE.scene3d.add(STATE.glbModel);
      },
      undefined,
      (err) => { console.warn('GLB load failed:', err); }
    );

    STATE.dynamicGroup = new THREE.Group();
    STATE.scene3d.add(STATE.dynamicGroup);

    rebuild3D(PRESETS[document.getElementById('presetSelect').value]);

    STATE.clock3d = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      STATE.controls3d.update();
      const pulse = Math.sin(STATE.clock3d.elapsedTime * 2.5) * 0.06;
      for (const m of Object.values(STATE.nodeMeshes3d)) {
        if (m && m.material) m.material.emissiveIntensity = 0.2 + pulse;
      }
      STATE.renderer3d.render(STATE.scene3d, STATE.camera3d);
    }
    animate();
  }

  function rebuild3D(mode) {
    if (!STATE.dynamicGroup) return;

    while (STATE.dynamicGroup.children.length > 0) {
      const child = STATE.dynamicGroup.children[0];
      STATE.dynamicGroup.remove(child);
      child.traverse((c) => {
        if (c.geometry) c.geometry.dispose();
        if (c.material) {
          if (Array.isArray(c.material)) c.material.forEach(m => m.dispose());
          else c.material.dispose();
        }
        if (c.material && c.material.map) c.material.map.dispose();
      });
    }
    STATE.nodeMeshes3d = {};
    STATE.linkMeshes3d = {};

    const pos3d = mode.pos3d || {};
    const labels3d = mode.labels3d || {};
    const tilts3d = mode.tilts3d || {};
    const model = mode.model;

    const nodePos3D = {};
    for (const [id, pos] of Object.entries(pos3d)) {
      const v = new THREE.Vector3(pos.x, pos.y, pos.z);
      const tilt = tilts3d[id] || null;
      const dev = createDevice(id, v, labels3d[id] || id, tilt);
      STATE.dynamicGroup.add(dev.group);
      nodePos3D[id] = v;
      STATE.nodeMeshes3d[id] = dev.mesh;
    }

    const drawnLinks = new Set();
    for (const link of model.links) {
      const key = [link.from, link.to].sort().join('|');
      if (drawnLinks.has(key)) continue;
      drawnLinks.add(key);
      const p1 = nodePos3D[link.from], p2 = nodePos3D[link.to];
      if (!p1 || !p2) continue;

      const lineGeo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
      const lineMat = new THREE.LineBasicMaterial({
        color: 0x3B82F6, transparent: true, opacity: 0.3
      });
      STATE.dynamicGroup.add(new THREE.Line(lineGeo, lineMat));

      const curve = new THREE.CatmullRomCurve3([p1.clone(), p2.clone()]);
      const tubeGeo = new THREE.TubeGeometry(curve, 20, 0.08, 8, false);
      const tubeMat = new THREE.MeshStandardMaterial({
        color: 0x3B82F6, emissive: 0x3B82F6, emissiveIntensity: 0.9,
        transparent: true, opacity: 0.95
      });
      const tubeMesh = new THREE.Mesh(tubeGeo, tubeMat);
      STATE.dynamicGroup.add(tubeMesh);

      const glowGeo = new THREE.TubeGeometry(curve, 20, 0.2, 8, false);
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0x3B82F6, transparent: true, opacity: 0.35
      });
      const glowMesh = new THREE.Mesh(glowGeo, glowMat);
      STATE.dynamicGroup.add(glowMesh);

      const linkIds = model.links.filter(l =>
        [l.from, l.to].sort().join('|') === key
      ).map(l => l.id);
      STATE.linkMeshes3d[key] = { tube: tubeMesh, glow: glowMesh, linkIds };
    }
  }

  /* ═══════════════════════════════════════════════
     INITIALIZATION
     ═══════════════════════════════════════════════ */
  initTooltip();

  // Load default preset
  loadPreset('standard');

  // Init 3D
  try { init3D(); } catch(e) { console.warn('3D init error:', e); }

  // Load GLPK in background
  (async () => {
    const badge = document.getElementById("engineBadge");
    try {
      const GLPK = (await import('./vendor/glpk.js')).default;
      STATE.glpk = await GLPK();
      const ver = typeof STATE.glpk.version === 'function' ? STATE.glpk.version() : (STATE.glpk.version || '?');
      badge.className = "engine-badge ready";
      badge.innerHTML = `&#9679; GLPK ${ver}`;
      showToast('GLPK WASM loaded', 'success');
    } catch (e) {
      console.warn('GLPK load failed (greedy works):', e);
      badge.className = "engine-badge ready";
      badge.innerHTML = "&#9679; Greedy Only";
    }
  })();
  </script>
</body>
</html>
