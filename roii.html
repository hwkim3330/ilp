<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ROii Shuttle TSN Demo &mdash; Autonomous Shuttle Network</title>
  <link rel="stylesheet" href="style.css" />
  <!-- Three.js r128 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <style>
    /* ═══════════════════════════════════════════════
       Light Theme Overrides (page-scoped)
       ═══════════════════════════════════════════════ */
    :root {
      --bg: #f8f9fa;
      --bg2: #f0f2f5;
      --card: #ffffff;
      --card-hi: #f8fafc;
      --border: rgba(59,130,246,0.2);
      --border-hi: rgba(59,130,246,0.4);
      --text: #1e293b;
      --text2: #475569;
      --text3: #64748b;
      --cyan: #0891b2;
      --blue: #3B82F6;
      --purple: #7c3aed;
      --orange: #d97706;
      --red: #dc2626;
      --green: #059669;
      --pink: #db2777;
      --flow-ctrl: #3B82F6;
      --flow-sensor: #059669;
      --flow-video: #db2777;
      --guard: #d97706;
      --be: #e2e8f0;
    }
    body {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 50%, #dee2e6 100%);
    }
    .bg-grid {
      background-image:
        radial-gradient(ellipse 80% 50% at 50% -20%, rgba(59,130,246,0.06), transparent),
        radial-gradient(ellipse 60% 40% at 80% 100%, rgba(6,182,212,0.04), transparent),
        linear-gradient(rgba(59,130,246,0.06) 1px, transparent 1px),
        linear-gradient(90deg, rgba(59,130,246,0.06) 1px, transparent 1px);
      background-size: 100% 100%, 100% 100%, 40px 40px, 40px 40px;
    }
    .card {
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      backdrop-filter: blur(20px);
      box-shadow: 0 2px 12px rgba(0,0,0,0.04);
    }
    .card:hover { border-color: rgba(59,130,246,0.3); }
    .card-title { color: var(--text2); }
    .card-title::before { background: var(--blue); }
    .metric-card {
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    }
    .metric-card::after { background: linear-gradient(90deg, var(--blue), transparent); }
    .metric-val { color: var(--blue); }
    .svg-container { background: rgba(248,250,252,0.8); }
    .tooltip {
      background: rgba(255,255,255,0.97);
      border: 1px solid rgba(59,130,246,0.25);
      color: var(--text);
      box-shadow: 0 8px 30px rgba(0,0,0,0.12);
    }
    .tooltip .tt-title { color: var(--blue); }
    .tooltip .tt-k { color: var(--text3); }
    textarea {
      background: rgba(248,250,252,0.9);
      color: var(--text);
      border-color: rgba(59,130,246,0.2);
    }
    textarea:focus { border-color: var(--blue); }
    pre {
      background: rgba(248,250,252,0.9);
      border-color: rgba(59,130,246,0.15);
      color: var(--text2);
    }
    .btn-primary {
      background: linear-gradient(135deg, #3B82F6 0%, #06B6D4 100%);
      color: #ffffff;
    }
    .btn-secondary {
      background: rgba(248,250,252,0.8);
      color: var(--text);
      border: 1px solid rgba(59,130,246,0.2);
    }
    .btn-secondary:hover {
      border-color: var(--blue);
      background: rgba(255,255,255,1);
    }
    .engine-badge.loading { background: rgba(217,119,6,0.1); color: var(--orange); border: 1px solid rgba(217,119,6,0.2); }
    .engine-badge.ready { background: rgba(5,150,105,0.1); color: var(--green); border: 1px solid rgba(5,150,105,0.2); }
    .auto-desc {
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    }
    .auto-desc h3 { color: var(--blue); }
    .auto-domain-legend .domain-tag {
      border: 1px solid rgba(59,130,246,0.15);
      background: rgba(255,255,255,0.8);
      color: var(--text2);
    }
    .pkt-table th { border-bottom: 1px solid rgba(59,130,246,0.15); color: var(--text3); }
    .pkt-table td { border-bottom: 1px solid rgba(59,130,246,0.08); }
    .pkt-table tr:hover td { background: rgba(59,130,246,0.04); }
    .topo-link { stroke: rgba(59,130,246,0.25); }
    .spinner { border-color: rgba(59,130,246,0.2); border-top-color: var(--blue); }

    /* ── KETI Logo Header ─────────────────────── */
    .keti-header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      margin-bottom: 8px;
    }
    .keti-header img {
      height: 40px;
      width: auto;
      object-fit: contain;
    }
    .keti-header .title-group {
      text-align: left;
    }
    .keti-header .title-group h1 {
      font-size: 2.2rem;
      font-weight: 800;
      letter-spacing: -0.02em;
      background: linear-gradient(135deg, #3B82F6 0%, #06B6D4 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    /* ── 3D Shuttle Card ──────────────────────── */
    .shuttle-3d-card {
      position: relative;
      border-radius: var(--radius);
      overflow: hidden;
      margin-bottom: 16px;
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      box-shadow: 0 2px 12px rgba(0,0,0,0.04);
      backdrop-filter: blur(20px);
    }
    #canvas3d {
      width: 100%;
      height: 500px;
      display: block;
      cursor: grab;
      background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
    }
    #canvas3d:active { cursor: grabbing; }
    .shuttle-3d-label {
      position: absolute;
      bottom: 12px;
      left: 16px;
      font-size: 0.72rem;
      color: var(--text3);
      background: rgba(255,255,255,0.85);
      padding: 4px 10px;
      border-radius: 8px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(59,130,246,0.1);
    }
  </style>
</head>
<body>
  <div class="bg-grid"></div>
  <div class="wrap">
    <!-- KETI Logo Header -->
    <div class="header">
      <div class="keti-header">
        <img src="keti.png" alt="KETI" onerror="this.style.display='none'">
        <div class="title-group">
          <h1>ROii Shuttle TSN Demo</h1>
        </div>
        <span class="engine-badge loading" id="engineBadge"><span class="spinner"></span>Loading GLPK/WASM...</span>
      </div>
      <div class="sub">Autonomous Shuttle LiDAR/Radar Network &mdash; IEEE 802.1Qbv GCL Scheduling</div>
    </div>

    <!-- 3D Shuttle Visualization -->
    <div class="shuttle-3d-card">
      <div class="card-title" style="padding:16px 20px 0;">3D Shuttle Network Topology</div>
      <div id="canvas3d"></div>
      <div class="shuttle-3d-label">Drag to rotate &middot; Scroll to zoom &middot; Right-click to pan</div>
    </div>

    <!-- Metrics (ILP Results) -->
    <div class="metrics" id="metricsArea"></div>

    <!-- Scenario Description -->
    <div class="auto-desc" id="scenarioDesc"></div>

    <!-- Domain Legend -->
    <div class="auto-domain-legend" id="domainLegend"></div>

    <!-- Shuttle Architecture Topology -->
    <div class="card">
      <div class="card-title">Shuttle Architecture Topology</div>
      <div class="legend" id="topoLegend"></div>
      <div class="svg-container" id="topoContainer" style="height:520px;"></div>
    </div>

    <!-- GCL Gantt -->
    <div class="card">
      <div class="card-title">Per-Link GCL Timeline (Gantt)</div>
      <div class="legend" id="gclLegend"></div>
      <div class="svg-container" id="gclContainer"></div>
    </div>

    <!-- Delay + Utilization -->
    <div class="two-col">
      <div class="card">
        <div class="card-title">Packet E2E Delay</div>
        <div class="svg-container" id="delayContainer" style="height:380px;"></div>
      </div>
      <div class="card">
        <div class="card-title">Link Utilization</div>
        <div class="svg-container" id="utilContainer" style="min-height:200px;"></div>
      </div>
    </div>

    <!-- Table -->
    <div class="card">
      <div class="card-title">Packet Schedule Table</div>
      <div style="overflow-x:auto;">
        <table class="pkt-table">
          <thead><tr>
            <th>Packet</th><th>Flow</th><th>Route</th><th>Release</th><th>End</th><th>E2E</th><th>Deadline</th><th>Slack</th><th>Status</th>
          </tr></thead>
          <tbody id="pktTableBody"></tbody>
        </table>
      </div>
    </div>

    <!-- Collapsible JSON Editor -->
    <div class="card">
      <div class="card-title collapsible" id="jsonEditorToggle">
        <span class="arrow">&#9654;</span> Customize Model (JSON)
      </div>
      <div class="collapse-body">
        <textarea id="input" style="min-height:300px;"></textarea>
        <div class="toolbar">
          <button class="btn btn-secondary" id="resetBtn">Reset to Default</button>
          <button class="btn btn-primary" id="resolveBtn" disabled>Re-Solve</button>
          <div id="status" style="margin-top:0; margin-left:8px;"></div>
        </div>
      </div>
    </div>

    <!-- Raw GCL -->
    <div class="card">
      <div class="card-title collapsible" id="gclJsonToggle">
        <span class="arrow">&#9654;</span> Raw GCL Output (JSON)
      </div>
      <div class="collapse-body">
        <pre id="jsonOut">-</pre>
      </div>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script src="vendor/d3.min.js"></script>
  <script type="module">
  import GLPK from './vendor/glpk.js';
  import {
    initTooltip, solveILP, renderMetrics, renderTopology,
    renderGCL, renderDelayChart, renderUtilization, renderTable
  } from './js/ilp-core.js';
  import {
    ROII_MODEL, getRoiiPositions,
    ROII_NODE_COLORS, ROII_3D_POSITIONS, ROII_SCENARIO
  } from './js/roii-data.js';

  /* ── 3D Shuttle + Network Topology ────────────── */
  (function init3D() {
    const container = document.getElementById('canvas3d');
    if (!container || typeof THREE === 'undefined') return;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f2f5);

    const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 1000);
    camera.position.set(40, 28, 55);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.sortObjects = true;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    function updateSize() {
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }
    updateSize();
    container.appendChild(renderer.domElement);
    window.addEventListener('resize', updateSize);

    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.2;
    controls.minDistance = 15;
    controls.maxDistance = 150;
    controls.target.set(0, 4, 0);

    // Lights — clean, no shadows
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(30, 60, 40);
    scene.add(dirLight);
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
    fillLight.position.set(-20, 40, -30);
    scene.add(fillLight);

    // Grid (subtle)
    const grid = new THREE.GridHelper(100, 20, 0xd0d0d0, 0xe8e8e8);
    grid.position.y = -0.1;
    grid.material.transparent = true;
    grid.material.opacity = 0.5;
    scene.add(grid);

    /* ── Device Templates (from original roii) ── */
    const DEVICE_TEMPLATES = {
      lidar:  { w: 2.5, h: 3.5, d: 2.5, color: 0x10B981 },
      radar:  { w: 1.3, h: 0.8, d: 1.3, color: 0xF59E0B },
      lan9662:{ w: 4,   h: 2,   d: 3,   color: 0x3B82F6 },
      lan9692:{ w: 6,   h: 2.5, d: 4,   color: 0x10B981 },
      ecu:    { w: 3,   h: 1.5, d: 2.5, color: 0x8B5CF6 }
    };

    // Map node IDs to device types
    function getDeviceType(nodeId) {
      if (nodeId.startsWith('LIDAR')) return 'lidar';
      if (nodeId.startsWith('RADAR')) return 'radar';
      if (nodeId === 'SW_REAR') return 'lan9692';
      if (nodeId.startsWith('SW')) return 'lan9662';
      if (nodeId === 'ADAS_PC') return 'ecu';
      return 'ecu';
    }

    /* ── Label Sprite ── */
    function makeLabel(text, color) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 512; canvas.height = 128;
      ctx.fillStyle = 'rgba(26, 26, 46, 0.85)';
      ctx.fillRect(0, 0, 512, 128);
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 48px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(text, 256, 75);
      const tex = new THREE.CanvasTexture(canvas);
      const sprite = new THREE.Sprite(
        new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false })
      );
      sprite.renderOrder = 10;
      return sprite;
    }

    /* ── Create Device Meshes (matching original roii shapes) ── */
    const nodePos3D = {};
    const nodeMeshes = {};

    for (const [nodeId, pos] of Object.entries(ROII_3D_POSITIONS)) {
      const nc = ROII_NODE_COLORS[nodeId];
      const devType = getDeviceType(nodeId);
      const tmpl = DEVICE_TEMPLATES[devType];
      const group = new THREE.Group();
      group.position.set(pos.x, pos.y, pos.z);

      // Build geometry based on device type
      let geometry;
      if (devType === 'lidar') {
        // Center LiDARs = small box, side LiDARs = cylinder
        const isCenter = nodeId.includes('FC') || nodeId.includes('RC');
        if (isCenter) {
          geometry = new THREE.BoxGeometry(tmpl.w * 0.5, tmpl.h * 0.5, tmpl.d * 0.5);
        } else {
          geometry = new THREE.CylinderGeometry(tmpl.w * 0.6, tmpl.w * 0.6, tmpl.h, 16);
        }
      } else {
        geometry = new THREE.BoxGeometry(tmpl.w, tmpl.h, tmpl.d);
      }

      // Main mesh
      const mat = new THREE.MeshPhongMaterial({
        color: tmpl.color,
        emissive: tmpl.color,
        emissiveIntensity: 0.2,
        shininess: 70
      });
      const mesh = new THREE.Mesh(geometry, mat);
      mesh.renderOrder = 3;
      group.add(mesh);

      // Edge wireframe
      const edges = new THREE.EdgesGeometry(geometry);
      const wireMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
      group.add(new THREE.LineSegments(edges, wireMat));

      // Port dots (up to 4)
      const portCount = (devType === 'lan9692') ? 4 : (devType === 'lan9662') ? 4 : 1;
      const portGeo = new THREE.SphereGeometry(0.3, 8, 8);
      const portMat = new THREE.MeshPhongMaterial({
        color: 0xffffff, emissive: tmpl.color, emissiveIntensity: 0.5
      });
      for (let i = 0; i < Math.min(portCount, 4); i++) {
        const angle = (i / 4) * Math.PI * 2;
        const p = new THREE.Mesh(portGeo, portMat.clone());
        p.position.set(Math.cos(angle) * tmpl.w * 0.4, 0, Math.sin(angle) * tmpl.d * 0.4);
        group.add(p);
      }

      // Label sprite (sized relative to device)
      const label = makeLabel(nc.label, nc.stroke);
      const labelScale = Math.max(tmpl.w, tmpl.d) * 1.2;
      label.scale.set(labelScale, labelScale * 0.25, 1);
      label.position.y = tmpl.h + 1.2;
      group.add(label);

      group.renderOrder = 3;
      scene.add(group);

      nodePos3D[nodeId] = new THREE.Vector3(pos.x, pos.y, pos.z);
      nodeMeshes[nodeId] = mesh;
    }

    /* ── Network Links ── */
    const drawnLinks = new Set();
    for (const link of ROII_MODEL.links) {
      const key = [link.from, link.to].sort().join('|');
      if (drawnLinks.has(key)) continue;
      drawnLinks.add(key);
      const p1 = nodePos3D[link.from], p2 = nodePos3D[link.to];
      if (!p1 || !p2) continue;

      const isSwitchLink = link.from.startsWith('SW') && link.to.startsWith('SW');
      const color = isSwitchLink ? 0x3B82F6 : 0x94a3b8;

      // Tube geometry for all links (visible thickness)
      const curve = new THREE.LineCurve3(p1, p2);
      const tubeR = isSwitchLink ? 0.18 : 0.08;
      const tubeGeo = new THREE.TubeGeometry(curve, 1, tubeR, 6, false);
      const tubeMat = new THREE.MeshPhongMaterial({
        color, emissive: color,
        emissiveIntensity: isSwitchLink ? 0.3 : 0.1,
        transparent: true, opacity: isSwitchLink ? 0.7 : 0.4,
        depthWrite: false
      });
      const tube = new THREE.Mesh(tubeGeo, tubeMat);
      tube.renderOrder = 1;
      scene.add(tube);
    }

    /* ── Animated Data Particles ── */
    const particles = [];
    const flowPaths = [
      { path: ['LIDAR_FL', 'SW_FL', 'SW_REAR', 'ADAS_PC'], color: 0x10B981 },
      { path: ['LIDAR_FC', 'SW_FL', 'SW_REAR', 'ADAS_PC'], color: 0x10B981 },
      { path: ['LIDAR_FR', 'SW_FR', 'SW_REAR', 'ADAS_PC'], color: 0x10B981 },
      { path: ['LIDAR_RC', 'SW_REAR', 'ADAS_PC'],          color: 0x10B981 },
      { path: ['RADAR_FC', 'SW_FL', 'SW_REAR', 'ADAS_PC'], color: 0x8B5CF6 },
      { path: ['RADAR_FL', 'SW_FL', 'SW_REAR', 'ADAS_PC'], color: 0x8B5CF6 },
      { path: ['RADAR_FR', 'SW_FR', 'SW_REAR', 'ADAS_PC'], color: 0x8B5CF6 },
      { path: ['RADAR_RL', 'SW_REAR', 'ADAS_PC'],          color: 0x8B5CF6 },
      { path: ['RADAR_RR', 'SW_REAR', 'ADAS_PC'],          color: 0x8B5CF6 }
    ];

    flowPaths.forEach((fp, fi) => {
      const points = fp.path.map(id => nodePos3D[id]).filter(Boolean);
      if (points.length < 2) return;

      const segs = [];
      let totalLen = 0;
      for (let i = 0; i < points.length - 1; i++) {
        const d = points[i].distanceTo(points[i+1]);
        segs.push(d); totalLen += d;
      }

      const pMat = new THREE.MeshBasicMaterial({
        color: fp.color, transparent: true, opacity: 0.95, depthWrite: false
      });
      const pMesh = new THREE.Mesh(new THREE.SphereGeometry(0.45, 8, 8), pMat);
      const pgMat = new THREE.MeshBasicMaterial({
        color: fp.color, transparent: true, opacity: 0.2, depthWrite: false
      });
      const pgMesh = new THREE.Mesh(new THREE.SphereGeometry(1.0, 8, 8), pgMat);
      pMesh.renderOrder = 5;
      pgMesh.renderOrder = 4;
      scene.add(pMesh);
      scene.add(pgMesh);

      particles.push({
        mesh: pMesh, glow: pgMesh, points, segs, totalLen,
        t: fi / flowPaths.length,
        speed: 0.12 + Math.random() * 0.06
      });
    });

    /* ── Load GLB Model (ghost overlay) ── */
    const loader = new THREE.GLTFLoader();
    loader.load('./roii.glb',
      (gltf) => {
        const model = gltf.scene;
        const box = new THREE.Box3().setFromObject(model);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());

        const targetSize = 40;
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = targetSize / maxDim;
        model.scale.set(scale, scale, scale);
        const scaledHeight = size.y * scale;
        model.position.set(
          -center.x,
          -center.y + (scaledHeight * 0.5) + 0.5,
          -center.z
        );

        // Transparent vehicle body — keep original colors, no shadows
        model.renderOrder = 0;
        model.traverse((child) => {
          if (child.isMesh && child.material) {
            const mats = Array.isArray(child.material) ? child.material : [child.material];
            mats.forEach(mat => {
              mat.transparent = true;
              mat.opacity = 0.25;
              mat.side = THREE.DoubleSide;
              mat.depthWrite = true;
              // Brighten original colors
              if (mat.color) mat.color.multiplyScalar(1.5);
              mat.emissive = mat.color
                ? mat.color.clone().multiplyScalar(0.3)
                : new THREE.Color(0xffffff);
              mat.emissiveIntensity = 0.4;
            });
            child.castShadow = false;
            child.receiveShadow = false;
            child.renderOrder = 0;
          }
        });
        scene.add(model);
      },
      undefined,
      (err) => { console.warn('GLB load failed:', err); }
    );

    /* ── Animation Loop ── */
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      controls.update();

      // Subtle pulse on nodes
      const pulse = Math.sin(clock.elapsedTime * 2.5) * 0.08;
      for (const mesh of Object.values(nodeMeshes)) {
        mesh.material.emissiveIntensity = 0.35 + pulse;
      }

      // Animate particles along flow paths
      particles.forEach(p => {
        p.t += dt * p.speed;
        if (p.t > 1) p.t -= 1;
        let dist = p.t * p.totalLen;
        let segIdx = 0;
        while (segIdx < p.segs.length - 1 && dist > p.segs[segIdx]) {
          dist -= p.segs[segIdx]; segIdx++;
        }
        const frac = dist / p.segs[segIdx];
        const pos = new THREE.Vector3().lerpVectors(p.points[segIdx], p.points[segIdx + 1], frac);
        p.mesh.position.copy(pos);
        p.glow.position.copy(pos);
        const fade = Math.min(p.t * 4, (1 - p.t) * 4, 1);
        p.mesh.material.opacity = 0.95 * fade;
        p.glow.material.opacity = 0.2 * fade;
      });

      renderer.render(scene, camera);
    }
    animate();
  })();

  /* ── State ───────────────────────────────────── */
  let glpk = null;
  let currentModel = JSON.parse(JSON.stringify(ROII_MODEL));
  let currentResult = null;

  /* ── Init ────────────────────────────────────── */
  initTooltip();

  // Render scenario description
  const descEl = document.getElementById("scenarioDesc");
  descEl.innerHTML = `
    <h3>${ROII_SCENARIO.title}</h3>
    <p>${ROII_SCENARIO.description}</p>
    <ul class="auto-flow-list">
      ${ROII_SCENARIO.flows.map(f => `<li><span class="dot" style="background:${f.color}"></span><strong>${f.name}</strong> &mdash; ${f.desc}</li>`).join("")}
    </ul>
  `;

  // Render domain legend
  const legendEl = document.getElementById("domainLegend");
  legendEl.innerHTML = ROII_SCENARIO.domains.map(d =>
    `<div class="domain-tag"><span class="dsq" style="background:${d.color}"></span>${d.name}</div>`
  ).join("");

  // Collapsibles
  document.getElementById("jsonEditorToggle").addEventListener("click", function() {
    this.classList.toggle("open");
    this.parentElement.querySelector(".collapse-body").classList.toggle("show");
  });
  document.getElementById("gclJsonToggle").addEventListener("click", function() {
    this.classList.toggle("open");
    this.parentElement.querySelector(".collapse-body").classList.toggle("show");
  });

  const inputEl = document.getElementById("input");
  const statusEl = document.getElementById("status");
  const resolveBtn = document.getElementById("resolveBtn");
  const resetBtn = document.getElementById("resetBtn");

  inputEl.value = JSON.stringify(ROII_MODEL, null, 2);

  resetBtn.addEventListener("click", () => {
    inputEl.value = JSON.stringify(ROII_MODEL, null, 2);
    statusEl.textContent = "Reset to default"; statusEl.className = "status-ok";
  });

  resolveBtn.addEventListener("click", runSolve);

  async function runSolve() {
    try {
      const model = JSON.parse(inputEl.value);
      resolveBtn.disabled = true;
      statusEl.innerHTML = '<span class="spinner"></span>Solving ILP...';
      statusEl.className = "";

      const result = await solveILP(model, glpk);
      currentModel = model;
      currentResult = result;
      renderAll();
      statusEl.textContent = `Solved in ${result.runtime_ms}ms | ${result.stats.variables} vars, ${result.stats.binaries} bins, ${result.stats.constraints} constraints`;
      statusEl.className = "status-ok";
    } catch (e) {
      statusEl.textContent = "Error: " + e.message;
      statusEl.className = "status-err";
    }
    resolveBtn.disabled = false;
  }

  function renderAll() {
    if (!currentResult) return;

    // Use ROii shuttle layout
    const container = document.getElementById("topoContainer");
    const W = container.clientWidth;
    const positions = getRoiiPositions(W, 520);

    renderMetrics(currentModel, currentResult);
    renderTopology(currentModel, currentResult, {
      nodePositions: positions,
      nodeColors: ROII_NODE_COLORS,
      height: 520
    });
    renderGCL(currentModel, currentResult);
    renderDelayChart(currentModel, currentResult);
    renderUtilization(currentModel, currentResult);
    renderTable(currentResult);
    document.getElementById("jsonOut").textContent = JSON.stringify(currentResult.gcl, null, 2);
  }

  // Responsive
  let resizeTimer;
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(renderAll, 300);
  });

  /* ── Init GLPK & Auto-Solve ──────────────────── */
  (async () => {
    const badge = document.getElementById("engineBadge");
    try {
      glpk = await GLPK();
      const ver = typeof glpk.version === 'function' ? glpk.version() : (glpk.version || '?');
      badge.className = "engine-badge ready";
      badge.innerHTML = `&#9679; GLPK ${ver} Ready`;
      resolveBtn.disabled = false;
      statusEl.textContent = "Auto-solving ROii shuttle scenario...";
      statusEl.className = "status-ok";
      await runSolve();
    } catch (e) {
      badge.className = "engine-badge loading";
      badge.innerHTML = "&#10007; GLPK Load Failed";
      statusEl.textContent = "GLPK failed: " + e.message;
      statusEl.className = "status-err";
      resolveBtn.disabled = true;
    }
  })();
  </script>
</body>
</html>
