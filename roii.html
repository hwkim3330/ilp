<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ROii Shuttle TSN Demo &mdash; Autonomous Shuttle Network</title>
  <link rel="stylesheet" href="style.css" />
  <!-- Three.js r128 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <style>
    /* ═══════════════════════════════════════════════
       Light Theme Overrides (page-scoped)
       ═══════════════════════════════════════════════ */
    :root {
      --bg: #f8f9fa;
      --bg2: #f0f2f5;
      --card: #ffffff;
      --card-hi: #f8fafc;
      --border: rgba(59,130,246,0.2);
      --border-hi: rgba(59,130,246,0.4);
      --text: #1e293b;
      --text2: #475569;
      --text3: #64748b;
      --cyan: #0891b2;
      --blue: #3B82F6;
      --purple: #7c3aed;
      --orange: #d97706;
      --red: #dc2626;
      --green: #059669;
      --pink: #db2777;
      --flow-ctrl: #3B82F6;
      --flow-sensor: #059669;
      --flow-video: #db2777;
      --guard: #d97706;
      --be: #e2e8f0;
    }
    body {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 50%, #dee2e6 100%);
    }
    .bg-grid {
      background-image:
        radial-gradient(ellipse 80% 50% at 50% -20%, rgba(59,130,246,0.06), transparent),
        radial-gradient(ellipse 60% 40% at 80% 100%, rgba(6,182,212,0.04), transparent),
        linear-gradient(rgba(59,130,246,0.06) 1px, transparent 1px),
        linear-gradient(90deg, rgba(59,130,246,0.06) 1px, transparent 1px);
      background-size: 100% 100%, 100% 100%, 40px 40px, 40px 40px;
    }
    .card {
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      backdrop-filter: blur(20px);
      box-shadow: 0 2px 12px rgba(0,0,0,0.04);
    }
    .card:hover { border-color: rgba(59,130,246,0.3); }
    .card-title { color: var(--text2); }
    .card-title::before { background: var(--blue); }
    .metric-card {
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    }
    .metric-card::after { background: linear-gradient(90deg, var(--blue), transparent); }
    .metric-val { color: var(--blue); }
    .svg-container { background: rgba(248,250,252,0.8); }
    .tooltip {
      background: rgba(255,255,255,0.97);
      border: 1px solid rgba(59,130,246,0.25);
      color: var(--text);
      box-shadow: 0 8px 30px rgba(0,0,0,0.12);
    }
    .tooltip .tt-title { color: var(--blue); }
    .tooltip .tt-k { color: var(--text3); }
    textarea {
      background: rgba(248,250,252,0.9);
      color: var(--text);
      border-color: rgba(59,130,246,0.2);
    }
    textarea:focus { border-color: var(--blue); }
    pre {
      background: rgba(248,250,252,0.9);
      border-color: rgba(59,130,246,0.15);
      color: var(--text2);
    }
    .btn-primary {
      background: linear-gradient(135deg, #3B82F6 0%, #06B6D4 100%);
      color: #ffffff;
    }
    .btn-secondary {
      background: rgba(248,250,252,0.8);
      color: var(--text);
      border: 1px solid rgba(59,130,246,0.2);
    }
    .btn-secondary:hover {
      border-color: var(--blue);
      background: rgba(255,255,255,1);
    }
    .engine-badge.loading { background: rgba(217,119,6,0.1); color: var(--orange); border: 1px solid rgba(217,119,6,0.2); }
    .engine-badge.ready { background: rgba(5,150,105,0.1); color: var(--green); border: 1px solid rgba(5,150,105,0.2); }
    .auto-desc {
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    }
    .auto-desc h3 { color: var(--blue); }
    .auto-domain-legend .domain-tag {
      border: 1px solid rgba(59,130,246,0.15);
      background: rgba(255,255,255,0.8);
      color: var(--text2);
    }
    .pkt-table th { border-bottom: 1px solid rgba(59,130,246,0.15); color: var(--text3); }
    .pkt-table td { border-bottom: 1px solid rgba(59,130,246,0.08); }
    .pkt-table tr:hover td { background: rgba(59,130,246,0.04); }
    .topo-link { stroke: rgba(59,130,246,0.25); }
    .spinner { border-color: rgba(59,130,246,0.2); border-top-color: var(--blue); }

    /* ── KETI Logo Header ─────────────────────── */
    .keti-header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      margin-bottom: 8px;
    }
    .keti-header img {
      height: 40px;
      width: auto;
      object-fit: contain;
    }
    .keti-header .title-group {
      text-align: left;
    }
    .keti-header .title-group h1 {
      font-size: 2.2rem;
      font-weight: 800;
      letter-spacing: -0.02em;
      background: linear-gradient(135deg, #3B82F6 0%, #06B6D4 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    /* ── 3D Shuttle Card ──────────────────────── */
    .shuttle-3d-card {
      position: relative;
      border-radius: var(--radius);
      overflow: hidden;
      margin-bottom: 16px;
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(59,130,246,0.15);
      box-shadow: 0 2px 12px rgba(0,0,0,0.04);
      backdrop-filter: blur(20px);
    }
    #canvas3d {
      width: 100%;
      height: 500px;
      display: block;
      cursor: grab;
      background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
    }
    #canvas3d:active { cursor: grabbing; }
    .shuttle-3d-label {
      position: absolute;
      bottom: 12px;
      left: 16px;
      font-size: 0.72rem;
      color: var(--text3);
      background: rgba(255,255,255,0.85);
      padding: 4px 10px;
      border-radius: 8px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(59,130,246,0.1);
    }
  </style>
</head>
<body>
  <div class="bg-grid"></div>
  <div class="wrap">
    <!-- KETI Logo Header -->
    <div class="header">
      <div class="keti-header">
        <img src="keti.png" alt="KETI" onerror="this.style.display='none'">
        <div class="title-group">
          <h1>ROii Shuttle TSN Demo</h1>
        </div>
        <span class="engine-badge loading" id="engineBadge"><span class="spinner"></span>Loading GLPK/WASM...</span>
      </div>
      <div class="sub">Autonomous Shuttle LiDAR/Radar Network &mdash; IEEE 802.1Qbv GCL Scheduling</div>
    </div>

    <!-- 3D Shuttle Visualization -->
    <div class="shuttle-3d-card">
      <div class="card-title" style="padding:16px 20px 0;">3D Shuttle Network Topology</div>
      <div id="canvas3d"></div>
      <div class="shuttle-3d-label">Drag to rotate &middot; Scroll to zoom &middot; Right-click to pan</div>
    </div>

    <!-- Scenario Description -->
    <div class="auto-desc" id="scenarioDesc"></div>

    <!-- Domain Legend -->
    <div class="auto-domain-legend" id="domainLegend"></div>

    <!-- Shuttle Architecture Topology -->
    <div class="card">
      <div class="card-title">Shuttle Architecture Topology</div>
      <div class="legend" id="topoLegend"></div>
      <div class="svg-container" id="topoContainer" style="height:520px;"></div>
    </div>

    <!-- Metrics -->
    <div class="metrics" id="metricsArea"></div>

    <!-- GCL Gantt -->
    <div class="card">
      <div class="card-title">Per-Link GCL Timeline (Gantt)</div>
      <div class="legend" id="gclLegend"></div>
      <div class="svg-container" id="gclContainer"></div>
    </div>

    <!-- Delay + Utilization -->
    <div class="two-col">
      <div class="card">
        <div class="card-title">Packet E2E Delay</div>
        <div class="svg-container" id="delayContainer" style="height:380px;"></div>
      </div>
      <div class="card">
        <div class="card-title">Link Utilization</div>
        <div class="svg-container" id="utilContainer" style="min-height:200px;"></div>
      </div>
    </div>

    <!-- Table -->
    <div class="card">
      <div class="card-title">Packet Schedule Table</div>
      <div style="overflow-x:auto;">
        <table class="pkt-table">
          <thead><tr>
            <th>Packet</th><th>Flow</th><th>Route</th><th>Release</th><th>End</th><th>E2E</th><th>Deadline</th><th>Slack</th><th>Status</th>
          </tr></thead>
          <tbody id="pktTableBody"></tbody>
        </table>
      </div>
    </div>

    <!-- Collapsible JSON Editor -->
    <div class="card">
      <div class="card-title collapsible" id="jsonEditorToggle">
        <span class="arrow">&#9654;</span> Customize Model (JSON)
      </div>
      <div class="collapse-body">
        <textarea id="input" style="min-height:300px;"></textarea>
        <div class="toolbar">
          <button class="btn btn-secondary" id="resetBtn">Reset to Default</button>
          <button class="btn btn-primary" id="resolveBtn" disabled>Re-Solve</button>
          <div id="status" style="margin-top:0; margin-left:8px;"></div>
        </div>
      </div>
    </div>

    <!-- Raw GCL -->
    <div class="card">
      <div class="card-title collapsible" id="gclJsonToggle">
        <span class="arrow">&#9654;</span> Raw GCL Output (JSON)
      </div>
      <div class="collapse-body">
        <pre id="jsonOut">-</pre>
      </div>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script src="vendor/d3.min.js"></script>
  <script type="module">
  import GLPK from './vendor/glpk.js';
  import {
    initTooltip, solveILP, renderMetrics, renderTopology,
    renderGCL, renderDelayChart, renderUtilization, renderTable
  } from './js/ilp-core.js';
  import {
    ROII_MODEL, getRoiiPositions,
    ROII_NODE_COLORS, ROII_3D_POSITIONS, ROII_SCENARIO
  } from './js/roii-data.js';

  /* ── 3D Shuttle + Network Topology ────────────── */
  (function init3D() {
    const container = document.getElementById('canvas3d');
    if (!container || typeof THREE === 'undefined') return;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f2f5);
    scene.fog = new THREE.Fog(0xf0f2f5, 120, 300);

    const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 1000);
    camera.position.set(40, 30, 55);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    function updateSize() {
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }
    updateSize();
    container.appendChild(renderer.domElement);
    window.addEventListener('resize', updateSize);

    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.2;
    controls.minDistance = 15;
    controls.maxDistance = 150;
    controls.target.set(0, 4, 0);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.65));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(50, 80, 60);
    dirLight.castShadow = true;
    scene.add(dirLight);
    // Accent lights (blue/cyan tint)
    const blueLight = new THREE.PointLight(0x3B82F6, 0.4, 80);
    blueLight.position.set(-15, 20, 15);
    scene.add(blueLight);
    const cyanLight = new THREE.PointLight(0x06B6D4, 0.3, 80);
    cyanLight.position.set(15, 20, -15);
    scene.add(cyanLight);

    // Grid + Ground
    const grid = new THREE.GridHelper(100, 20, 0xc0c0c0, 0xe0e0e0);
    grid.position.y = -0.1;
    scene.add(grid);
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.9 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.2;
    ground.receiveShadow = true;
    scene.add(ground);

    /* ── Text Sprite Helper ── */
    function makeLabel(text, color) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 256; canvas.height = 64;
      ctx.font = 'bold 22px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      // Background pill
      const tw = ctx.measureText(text).width;
      const px = 12, py = 6;
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      const rx = 128 - tw/2 - px, ry = 8, rw = tw + px*2, rh = 48;
      ctx.beginPath();
      ctx.roundRect(rx, ry, rw, rh, 8);
      ctx.fill(); ctx.stroke();
      // Text
      ctx.fillStyle = '#1e293b';
      ctx.fillText(text, 128, 32);
      const tex = new THREE.CanvasTexture(canvas);
      tex.minFilter = THREE.LinearFilter;
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false }));
      sprite.scale.set(7, 1.75, 1);
      return sprite;
    }

    /* ── Network Nodes & Links ── */
    const nodePos3D = {};  // THREE.Vector3 map
    const nodeMeshes = {};

    // Create node spheres
    for (const [nodeId, pos] of Object.entries(ROII_3D_POSITIONS)) {
      const nc = ROII_NODE_COLORS[nodeId];
      const strokeColor = new THREE.Color(nc.stroke);
      const isSwitch = nodeId.startsWith('SW_');
      const isPC = nodeId === 'ADAS_PC';
      const r = isPC ? 1.6 : isSwitch ? 1.4 : 1.0;

      // Outer glow ring
      const glowGeo = new THREE.SphereGeometry(r * 1.8, 16, 16);
      const glowMat = new THREE.MeshBasicMaterial({ color: strokeColor, transparent: true, opacity: 0.12 });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      glow.position.set(pos.x, pos.y, pos.z);
      scene.add(glow);

      // Core sphere
      const geo = new THREE.SphereGeometry(r, 20, 20);
      const mat = new THREE.MeshPhongMaterial({
        color: strokeColor, emissive: strokeColor, emissiveIntensity: 0.4,
        shininess: 60, transparent: true, opacity: 0.9
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(pos.x, pos.y, pos.z);
      mesh.castShadow = true;
      scene.add(mesh);

      // Label sprite
      const label = makeLabel(nc.label, nc.stroke);
      label.position.set(pos.x, pos.y + r + 2.2, pos.z);
      scene.add(label);

      nodePos3D[nodeId] = new THREE.Vector3(pos.x, pos.y, pos.z);
      nodeMeshes[nodeId] = mesh;
    }

    // Create link lines (deduplicate bidirectional)
    const drawnLinks = new Set();
    for (const link of ROII_MODEL.links) {
      const key = [link.from, link.to].sort().join('|');
      if (drawnLinks.has(key)) continue;
      drawnLinks.add(key);
      const p1 = nodePos3D[link.from], p2 = nodePos3D[link.to];
      if (!p1 || !p2) continue;

      // Determine color based on node types
      const isSwitchLink = link.from.startsWith('SW') && link.to.startsWith('SW');
      const color = isSwitchLink ? 0x3B82F6 : 0x94a3b8;

      const pts = [p1, p2];
      const lineGeo = new THREE.BufferGeometry().setFromPoints(pts);
      const lineMat = new THREE.LineBasicMaterial({
        color, transparent: true, opacity: isSwitchLink ? 0.7 : 0.45, linewidth: 1
      });
      scene.add(new THREE.Line(lineGeo, lineMat));

      // Tube for switch backbone (thicker visual)
      if (isSwitchLink) {
        const curve = new THREE.LineCurve3(p1, p2);
        const tubeGeo = new THREE.TubeGeometry(curve, 1, 0.15, 6, false);
        const tubeMat = new THREE.MeshPhongMaterial({
          color: 0x3B82F6, emissive: 0x3B82F6, emissiveIntensity: 0.3,
          transparent: true, opacity: 0.5
        });
        scene.add(new THREE.Mesh(tubeGeo, tubeMat));
      }
    }

    /* ── Animated Data Particles ── */
    const particles = [];
    // Build flow paths: sensor → switch(es) → ADAS_PC
    const flowPaths = [
      // LiDAR flows
      { path: ['LIDAR_FL', 'SW_FL', 'SW_REAR', 'ADAS_PC'], color: 0x10B981 },
      { path: ['LIDAR_FC', 'SW_FL', 'SW_REAR', 'ADAS_PC'], color: 0x10B981 },
      { path: ['LIDAR_FR', 'SW_FR', 'SW_REAR', 'ADAS_PC'], color: 0x10B981 },
      { path: ['LIDAR_RC', 'SW_REAR', 'ADAS_PC'],          color: 0x10B981 },
      // Radar flows
      { path: ['RADAR_FC', 'SW_FL', 'SW_REAR', 'ADAS_PC'], color: 0x8B5CF6 },
      { path: ['RADAR_FL', 'SW_FL', 'SW_REAR', 'ADAS_PC'], color: 0x8B5CF6 },
      { path: ['RADAR_FR', 'SW_FR', 'SW_REAR', 'ADAS_PC'], color: 0x8B5CF6 },
      { path: ['RADAR_RL', 'SW_REAR', 'ADAS_PC'],          color: 0x8B5CF6 },
      { path: ['RADAR_RR', 'SW_REAR', 'ADAS_PC'],          color: 0x8B5CF6 }
    ];

    flowPaths.forEach((fp, fi) => {
      const points = fp.path.map(id => nodePos3D[id]).filter(Boolean);
      if (points.length < 2) return;

      // Build segment lengths for parametric travel
      const segs = [];
      let totalLen = 0;
      for (let i = 0; i < points.length - 1; i++) {
        const d = points[i].distanceTo(points[i+1]);
        segs.push(d);
        totalLen += d;
      }

      // Particle sphere
      const pGeo = new THREE.SphereGeometry(0.4, 8, 8);
      const pMat = new THREE.MeshBasicMaterial({ color: fp.color, transparent: true, opacity: 0.9 });
      const pMesh = new THREE.Mesh(pGeo, pMat);
      // Glow
      const pgGeo = new THREE.SphereGeometry(0.8, 8, 8);
      const pgMat = new THREE.MeshBasicMaterial({ color: fp.color, transparent: true, opacity: 0.3 });
      const pgMesh = new THREE.Mesh(pgGeo, pgMat);

      scene.add(pMesh);
      scene.add(pgMesh);

      particles.push({
        mesh: pMesh, glow: pgMesh, points, segs, totalLen,
        t: fi / flowPaths.length,  // stagger start
        speed: 0.15 + Math.random() * 0.05
      });
    });

    /* ── Load GLB Model ── */
    const loader = new THREE.GLTFLoader();
    loader.load('./roii.glb',
      (gltf) => {
        const model = gltf.scene;
        const box = new THREE.Box3().setFromObject(model);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());

        const targetSize = 40;
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = targetSize / maxDim;
        model.scale.set(scale, scale, scale);

        const scaledHeight = size.y * scale;
        model.position.x = -center.x * scale;
        model.position.y = -center.y * scale + scaledHeight * 0.5 + 0.5;
        model.position.z = -center.z * scale;

        model.traverse((child) => {
          if (child.isMesh && child.material) {
            const mats = Array.isArray(child.material) ? child.material : [child.material];
            mats.forEach(mat => {
              mat.transparent = true;
              mat.opacity = 0.25;
              mat.side = THREE.DoubleSide;
              mat.depthWrite = false;
              if (mat.color) mat.color.multiplyScalar(1.3);
              mat.emissive = mat.color ? mat.color.clone().multiplyScalar(0.2) : new THREE.Color(0xffffff);
              mat.emissiveIntensity = 0.3;
            });
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        scene.add(model);
      },
      undefined,
      (err) => { console.warn('GLB load failed:', err); }
    );

    /* ── Animation Loop ── */
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      controls.update();

      // Pulse glow on nodes
      const pulse = 0.10 + Math.sin(clock.elapsedTime * 2) * 0.05;
      for (const mesh of Object.values(nodeMeshes)) {
        mesh.material.emissiveIntensity = 0.3 + pulse;
      }

      // Animate particles
      particles.forEach(p => {
        p.t += dt * p.speed;
        if (p.t > 1) p.t -= 1;
        // Map t to position along path
        let dist = p.t * p.totalLen;
        let segIdx = 0;
        while (segIdx < p.segs.length - 1 && dist > p.segs[segIdx]) {
          dist -= p.segs[segIdx];
          segIdx++;
        }
        const frac = dist / p.segs[segIdx];
        const pos = new THREE.Vector3().lerpVectors(p.points[segIdx], p.points[segIdx + 1], frac);
        p.mesh.position.copy(pos);
        p.glow.position.copy(pos);
        // Fade near endpoints
        const edgeFade = Math.min(p.t * 5, (1 - p.t) * 5, 1);
        p.mesh.material.opacity = 0.9 * edgeFade;
        p.glow.material.opacity = 0.3 * edgeFade;
      });

      renderer.render(scene, camera);
    }
    animate();
  })();

  /* ── State ───────────────────────────────────── */
  let glpk = null;
  let currentModel = JSON.parse(JSON.stringify(ROII_MODEL));
  let currentResult = null;

  /* ── Init ────────────────────────────────────── */
  initTooltip();

  // Render scenario description
  const descEl = document.getElementById("scenarioDesc");
  descEl.innerHTML = `
    <h3>${ROII_SCENARIO.title}</h3>
    <p>${ROII_SCENARIO.description}</p>
    <ul class="auto-flow-list">
      ${ROII_SCENARIO.flows.map(f => `<li><span class="dot" style="background:${f.color}"></span><strong>${f.name}</strong> &mdash; ${f.desc}</li>`).join("")}
    </ul>
  `;

  // Render domain legend
  const legendEl = document.getElementById("domainLegend");
  legendEl.innerHTML = ROII_SCENARIO.domains.map(d =>
    `<div class="domain-tag"><span class="dsq" style="background:${d.color}"></span>${d.name}</div>`
  ).join("");

  // Collapsibles
  document.getElementById("jsonEditorToggle").addEventListener("click", function() {
    this.classList.toggle("open");
    this.parentElement.querySelector(".collapse-body").classList.toggle("show");
  });
  document.getElementById("gclJsonToggle").addEventListener("click", function() {
    this.classList.toggle("open");
    this.parentElement.querySelector(".collapse-body").classList.toggle("show");
  });

  const inputEl = document.getElementById("input");
  const statusEl = document.getElementById("status");
  const resolveBtn = document.getElementById("resolveBtn");
  const resetBtn = document.getElementById("resetBtn");

  inputEl.value = JSON.stringify(ROII_MODEL, null, 2);

  resetBtn.addEventListener("click", () => {
    inputEl.value = JSON.stringify(ROII_MODEL, null, 2);
    statusEl.textContent = "Reset to default"; statusEl.className = "status-ok";
  });

  resolveBtn.addEventListener("click", runSolve);

  async function runSolve() {
    try {
      const model = JSON.parse(inputEl.value);
      resolveBtn.disabled = true;
      statusEl.innerHTML = '<span class="spinner"></span>Solving ILP...';
      statusEl.className = "";

      const result = await solveILP(model, glpk);
      currentModel = model;
      currentResult = result;
      renderAll();
      statusEl.textContent = `Solved in ${result.runtime_ms}ms | ${result.stats.variables} vars, ${result.stats.binaries} bins, ${result.stats.constraints} constraints`;
      statusEl.className = "status-ok";
    } catch (e) {
      statusEl.textContent = "Error: " + e.message;
      statusEl.className = "status-err";
    }
    resolveBtn.disabled = false;
  }

  function renderAll() {
    if (!currentResult) return;

    // Use ROii shuttle layout
    const container = document.getElementById("topoContainer");
    const W = container.clientWidth;
    const positions = getRoiiPositions(W, 520);

    renderMetrics(currentModel, currentResult);
    renderTopology(currentModel, currentResult, {
      nodePositions: positions,
      nodeColors: ROII_NODE_COLORS,
      height: 520
    });
    renderGCL(currentModel, currentResult);
    renderDelayChart(currentModel, currentResult);
    renderUtilization(currentModel, currentResult);
    renderTable(currentResult);
    document.getElementById("jsonOut").textContent = JSON.stringify(currentResult.gcl, null, 2);
  }

  // Responsive
  let resizeTimer;
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(renderAll, 300);
  });

  /* ── Init GLPK & Auto-Solve ──────────────────── */
  (async () => {
    const badge = document.getElementById("engineBadge");
    try {
      glpk = await GLPK();
      const ver = typeof glpk.version === 'function' ? glpk.version() : (glpk.version || '?');
      badge.className = "engine-badge ready";
      badge.innerHTML = `&#9679; GLPK ${ver} Ready`;
      resolveBtn.disabled = false;
      statusEl.textContent = "Auto-solving ROii shuttle scenario...";
      statusEl.className = "status-ok";
      await runSolve();
    } catch (e) {
      badge.className = "engine-badge loading";
      badge.innerHTML = "&#10007; GLPK Load Failed";
      statusEl.textContent = "GLPK failed: " + e.message;
      statusEl.className = "status-err";
      resolveBtn.disabled = true;
    }
  })();
  </script>
</body>
</html>
